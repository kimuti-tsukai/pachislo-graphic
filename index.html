<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>パチスロ</title>
    <style>
      body {
        font-family: "Helvetica Neue", Arial, sans-serif;
        display: flex;
        flex-direction: column;
        gap: 18px;
        align-items: center;
        padding: 32px;
        background: #111;
        color: #eee;
      }

      .game-container {
        display: flex;
        gap: 80px;
        justify-content: center;
        align-items: flex-start;
      }

      .game-unit {
        display: flex;
        gap: 20px;
        align-items: flex-start;
        position: relative;
      }

      .canvas-container {
        flex: 0 0 auto;
      }

      canvas {
        border: 2px solid #444;
        background-color: #2a2a2a;
      }

      .right-panel {
        flex: 0 0 250px;
        padding: 20px;
        position: relative;
        overflow: hidden;
      }

      .right-panel video {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        z-index: -1;
      }

      .right-panel > * {
        position: relative;
        z-index: 1;
      }

      .timer-display {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-family: "Courier New", monospace;
        font-size: 18px;
        font-weight: bold;
        z-index: 100;
        display: inline-block;
        width: auto;
        text-align: center;
        border: 2px solid rgba(255, 255, 255, 0.3);
      }

      .time-settings {
        position: absolute;
        top: 50px;
        left: 10px;
        background-color: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 15px;
        border-radius: 8px;
        z-index: 20;
        display: none;
        border: 2px solid rgba(255, 255, 255, 0.3);
        min-width: 200px;
      }

      .time-settings.visible {
        display: block;
      }

      .time-settings label {
        display: block;
        margin-bottom: 10px;
        font-size: 14px;
      }

      .time-settings input {
        width: 60px;
        padding: 4px;
        margin-left: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }

      .time-settings button {
        background-color: #4caf50;
        color: white;
        border: none;
        padding: 6px 12px;
        margin: 5px 5px 0 0;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      }

      .time-settings button:hover {
        background-color: #45a049;
      }

      .time-settings button:last-child {
        background-color: #f44336;
      }

      .time-settings button:last-child:hover {
        background-color: #da190b;
      }

      /* Lottery video overlay styles for 9:16 aspect ratio */
      .right-panel {
        position: relative;
        overflow: hidden;
        min-height: 400px;
        min-width: 200px;
      }

      .video-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 5;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: rgba(0, 0, 0, 0.8);
        border-radius: 8px;
      }

      .video-overlay video {
        max-width: 90%;
        max-height: 90%;
        width: auto;
        height: auto;
        object-fit: contain;
        border-radius: 4px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
      }

      .right-panel > *:not(.video-overlay) {
        position: relative;
        z-index: 2;
      }

      .state {
        padding: 20px;
        /*background-color: rgba(0, 0, 0, 0.7);*/
        color: white;
        border-radius: 8px;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        font-weight: bold;
        margin-bottom: 10px;
        margin-top: 60px;
      }

      .slot-container {
        margin-top: 300px;
        justify-content: center;
        align-items: center;
        display: flex;
        gap: 10px;
      }

      .slot-num {
        height: 100px;
        font-size: 50px;
        text-align: center;
        flex: 1;
      }

      :root {
        --reel-width: 120px;
        --cell-height: 64px; /* 1つの数字セルの高さ */
        --visible-cells: 3; /* 見えるセル数（中央＋上下の見切れ） */
      }

      .slot-wrap {
        display: flex;
        gap: 10px;
        justify-content: center;
        /*background-color: rgba(0, 0, 0, 0.6);*/
        padding: 15px;
        border-radius: 8px;
        margin-top: 20px;
      }

      .reel {
        width: var(--reel-width);
        height: calc(
          var(--cell-height) * 1
        ); /* 見せたい中央の高さ（中央セル1つ分） */
        position: relative;
        overflow: hidden;
        border-radius: 12px;
        background: linear-gradient(180deg, #222, #0f0f12);
        box-shadow:
          0 6px 18px rgba(0, 0, 0, 0.7),
          inset 0 2px 0 rgba(255, 255, 255, 0.02);
        display: flex;
        align-items: center;
        justify-content: center;
      }

      /* 中央の数字を大きく見せるため、内側に余白を持たせたオーバーフロー領域を用意 */
      .reel-viewport {
        position: relative;
        width: 100%;
        height: calc(var(--cell-height) * var(--visible-cells));
        top: calc(var(--cell-height) * -1); /* 中央セルを可視領域の中央に */
        overflow: hidden;
      }

      .reel-list {
        /* リールの要素一覧 */
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
      }

      .cell {
        width: 100%;
        height: var(--cell-height);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 32px;
        font-weight: 700;
        color: #fff;
      }

      /* フェードエフェクトで上下をぼかす */
      .reel:before,
      .reel:after {
        content: "";
        position: absolute;
        left: 0;
        right: 0;
        height: calc(var(--cell-height) * 0.4);
        pointer-events: none;
        z-index: 2;
      }
      .reel:before {
        top: 0;
        background: linear-gradient(
          to bottom,
          rgba(17, 17, 17, 0.9) 0%,
          transparent 100%
        );
      }
      .reel:after {
        bottom: 0;
        background: linear-gradient(
          to top,
          rgba(17, 17, 17, 0.9) 0%,
          transparent 100%
        );
      }

      /* 中央フレームの強調 */
      .center-frame {
        position: absolute;
        top: 50%;
        left: 50%;
        width: calc(100% - 8px);
        height: calc(var(--cell-height) - 8px);
        transform: translate(-50%, -50%);
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-radius: 6px;
        pointer-events: none;
        z-index: 3;
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <!-- プレイヤー1 -->
      <div class="game-unit">
        <div class="canvas-container">
          <canvas id="canvas1"></canvas>
        </div>
        <div class="right-panel" id="right-panel1">
          <div class="timer-display" id="timer-display1">5:00</div>
          <div class="time-settings" id="time-settings1">
            <label
              >Timer (minutes):
              <input type="number" id="timer-input1" value="5" min="1" max="60"
            /></label>
            <button onclick="applyTimeSettings(1)">Apply</button>
            <button onclick="toggleTimeSettings(1)">Close</button>
          </div>
          <video
            id="video1"
            autoplay
            muted
            loop
            playsinline
            onclick="toggleTimeSettings(1)"
          >
            <source src="" id="source1" />
          </video>

          <div class="state" id="state1">Uninitialized</div>

          <div class="slot-wrap" id="slot">
            <!-- 3つのリールを用意 -->
            <div class="reel" data-index="0">
              <div class="reel-viewport">
                <div class="reel-list"></div>
              </div>
              <div class="center-frame"></div>
            </div>

            <div class="reel" data-index="1">
              <div class="reel-viewport">
                <div class="reel-list"></div>
              </div>
              <div class="center-frame"></div>
            </div>

            <div class="reel" data-index="2">
              <div class="reel-viewport">
                <div class="reel-list"></div>
              </div>
              <div class="center-frame"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- プレイヤー2 -->
      <div class="game-unit">
        <div class="canvas-container">
          <canvas id="canvas2"></canvas>
        </div>
        <div class="right-panel" id="right-panel2">
          <div class="timer-display" id="timer-display2">5:00</div>
          <div class="time-settings" id="time-settings2">
            <label
              >Timer (minutes):
              <input type="number" id="timer-input2" value="5" min="1" max="60"
            /></label>
            <button onclick="applyTimeSettings(2)">Apply</button>
            <button onclick="toggleTimeSettings(2)">Close</button>
          </div>
          <video
            id="video2"
            autoplay
            muted
            loop
            playsinline
            onclick="toggleTimeSettings(2)"
          ></video>

          <div class="state" id="state2">Uninitialized</div>

          <div class="slot-wrap" id="slot2">
            <!-- 3つのリールを用意 -->
            <div class="reel" data-index="0">
              <div class="reel-viewport">
                <div class="reel-list"></div>
              </div>
              <div class="center-frame"></div>
            </div>

            <div class="reel" data-index="1">
              <div class="reel-viewport">
                <div class="reel-list"></div>
              </div>
              <div class="center-frame"></div>
            </div>

            <div class="reel" data-index="2">
              <div class="reel-viewport">
                <div class="reel-list"></div>
              </div>
              <div class="center-frame"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>

    <script type="module">
      const REPEAT = 16; // 数字列を何回繰り返すか
      const numbers = [...Array(10).keys()].reverse(); // [9,8,7,6,5,4,3,2,1,0]
      const reels1 = Array.from(document.querySelectorAll("#slot .reel"));
      const reels2 = Array.from(document.querySelectorAll("#slot2 .reel"));
      const cellH =
        parseInt(
          getComputedStyle(document.documentElement).getPropertyValue(
            "--cell-height",
          ),
        ) || 64;

      // タスクキューシステム
      class OutputTaskQueue {
        constructor(playerId, updateStateFunction) {
          this.playerId = playerId;
          this.queue = [];
          this.isProcessing = false;
          this.updateState = updateStateFunction;
        }

        // タスクをキューに追加
        addTask(taskType, taskData) {
          console.log(
            `Player ${this.playerId} task queued: ${taskType}`,
            taskData,
          );
          this.queue.push({
            type: taskType,
            data: taskData,
            timestamp: Date.now(),
          });
          this.processNext();
        }

        // 次のタスクを処理
        async processNext() {
          if (this.isProcessing || this.queue.length === 0) {
            return;
          }

          this.isProcessing = true;
          const task = this.queue.shift();
          console.log(`Player ${this.playerId} processing task: ${task.type}`);

          try {
            await this.executeTask(task);
          } catch (error) {
            console.error(`Player ${this.playerId} task error:`, error);
          }

          this.isProcessing = false;

          // 次のタスクがあれば続行
          if (this.queue.length > 0) {
            setTimeout(() => this.processNext(), 100);
          }
        }

        // タスクを実行
        async executeTask(task) {
          const { type, data } = task;

          switch (type) {
            case "default":
              this.executeDefaultTask(data);
              break;
            case "finishGame":
              this.executeFinishGameTask(data);
              break;
            case "lotteryNormal":
            case "lotteryRush":
            case "lotteryRushContinue":
              await this.executeLotteryTask(data);
              break;
            default:
              console.warn(`Unknown task type: ${type}`);
          }
        }

        // defaultタスクの実行
        executeDefaultTask(transition) {
          console.log(`P${this.playerId} Transition:`, transition);
          if (transition.after) {
            this.updateState(this.playerId, transition.after);
          }
        }

        // finishGameタスクの実行
        executeFinishGameTask(gameState) {
          console.log(`P${this.playerId} Game Finished:`, gameState);
          this.updateState(this.playerId, gameState);
        }

        // 抽選タスクの実行（映像再生とスロット回転）
        async executeLotteryTask(data) {
          const { lotteryResult, slotResult, taskType } = data;
          console.log(
            `P${this.playerId} ${taskType}:`,
            lotteryResult,
            slotResult,
          );

          const slot = slotResult[1] || slotResult[0];

          // 抽選結果に基づいて映像フォルダを決定
          let videoFolder = "";
          console.log(
            `P${this.playerId} Lottery result structure:`,
            lotteryResult,
          );

          // Handle different possible lottery result formats
          if (lotteryResult.Win !== undefined) {
            // Rust-style enum format: { Win: "Default" } or { Win: "FakeWin" }
            videoFolder =
              lotteryResult.Win === "Default" ? "images/win" : "images/fakewin";
          } else if (lotteryResult.Lose !== undefined) {
            // Rust-style enum format: { Lose: "Default" } or { Lose: "FakeLose" }
            videoFolder =
              lotteryResult.Lose === "FakeLose" ? "images/lose" : "images/lose";
          } else if (lotteryResult.type === "Win") {
            // JavaScript-style format: { type: "Win", winType: "Default" }
            videoFolder =
              lotteryResult.winType === "Default"
                ? "images/win"
                : "images/fakewin";
          } else if (lotteryResult.type === "Lose") {
            // JavaScript-style format: { type: "Lose", loseType: "Default" }
            videoFolder =
              lotteryResult.loseType === "FakeLose"
                ? "images/lose"
                : "images/lose";
          }

          console.log(
            `P${this.playerId} Selected video folder: ${videoFolder}`,
          );

          try {
            // フォルダから映像ファイルを取得してランダム選択
            const videoFile = await this.selectRandomVideo(videoFolder);
            if (!videoFile) {
              console.warn(
                `No video found in ${videoFolder}, using default slot animation`,
              );
              await this.fallbackToDefaultSlot(slot);
              return;
            }

            console.log(`P${this.playerId} Selected video: ${videoFile}`);

            try {
              // 映像を背景で再生し、長さを取得
              const videoDuration = await this.playBackgroundVideo(videoFile);
              console.log(
                `P${this.playerId} Playing ${videoFile} for ${videoDuration}ms`,
              );

              // スロットをその長さだけ回転させる
              await this.spinSlotForDuration(slot, videoDuration);
            } catch (videoError) {
              console.warn(
                `P${this.playerId} Video playback failed:`,
                videoError.message,
              );
              console.log(
                `P${this.playerId} Falling back to default slot animation`,
              );
              await this.fallbackToDefaultSlot(slot);
            }
          } catch (error) {
            console.error(
              `P${this.playerId} Error in lottery task execution:`,
              error,
            );
            await this.fallbackToDefaultSlot(slot);
          }

          console.log(`Player ${this.playerId} lottery task completed`);
        }

        // フォルダからランダムに映像ファイルを選択（フォールバック付き）
        async selectRandomVideo(folderPath) {
          // Static fallback files for each folder
          const fallbackFiles = {
            "images/win": ["once-input-win.mov"],
            "images/fakewin": ["once-input-fakewin.mov"],
            "images/lose": ["once-input-lose.mov"],
          };

          try {
            const response = await fetch("/api/list-videos", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ folder: folderPath }),
            });

            if (response.ok) {
              const videos = await response.json();
              if (videos.length > 0) {
                const randomIndex = Math.floor(Math.random() * videos.length);
                return `${folderPath}/${videos[randomIndex]}`;
              }
            }

            console.warn(`API failed for ${folderPath}, using fallback`);
          } catch (error) {
            console.warn(
              `API error for ${folderPath}, using fallback:`,
              error.message,
            );
          }

          // Use fallback files if API fails or returns empty
          const fallback = fallbackFiles[folderPath];
          if (fallback && fallback.length > 0) {
            const randomIndex = Math.floor(Math.random() * fallback.length);
            return `${folderPath}/${fallback[randomIndex]}`;
          }

          return null;
        }

        // right-panel内で映像を再生し、長さを取得（9:16動画対応）
        async playBackgroundVideo(videoPath) {
          return new Promise((resolve, reject) => {
            const video = document.createElement("video");
            video.style.position = "absolute";
            video.style.top = "50%";
            video.style.left = "50%";
            video.style.transform = "translate(-50%, -50%)";
            video.style.maxWidth = "100%";
            video.style.maxHeight = "100%";
            video.style.width = "auto";
            video.style.height = "auto";
            video.style.objectFit = "contain";
            video.style.zIndex = "5";
            video.style.backgroundColor = "rgba(0, 0, 0, 0.9)";
            video.style.borderRadius = "8px";
            video.style.boxShadow = "0 4px 20px rgba(0, 0, 0, 0.6)";
            video.muted = true;
            video.autoplay = true;
            video.playsInline = true;

            // Timeout for loading
            const loadTimeout = setTimeout(() => {
              console.warn(`Video loading timeout: ${videoPath}`);
              reject(new Error(`Video loading timeout: ${videoPath}`));
            }, 10000); // 10秒タイムアウト

            video.onloadedmetadata = () => {
              clearTimeout(loadTimeout);
              const duration = video.duration * 1000; // ミリ秒に変換
              console.log(
                `Video loaded successfully: ${videoPath}, duration: ${duration}ms`,
              );

              // Safely append to right-panel with proper setup
              try {
                const rightPanel = document.getElementById(
                  `right-panel${this.playerId}`,
                );
                if (rightPanel) {
                  // Ensure right-panel is set up for video overlay
                  rightPanel.style.position = "relative";
                  rightPanel.style.overflow = "hidden";

                  // Create video overlay container for better control
                  const videoOverlay = document.createElement("div");
                  videoOverlay.className = "video-overlay";
                  videoOverlay.style.position = "absolute";
                  videoOverlay.style.top = "0";
                  videoOverlay.style.left = "0";
                  videoOverlay.style.width = "100%";
                  videoOverlay.style.height = "100%";
                  videoOverlay.style.zIndex = "5";
                  videoOverlay.style.display = "flex";
                  videoOverlay.style.alignItems = "center";
                  videoOverlay.style.justifyContent = "center";
                  videoOverlay.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
                  videoOverlay.style.borderRadius = "8px";

                  videoOverlay.appendChild(video);
                  rightPanel.appendChild(videoOverlay);

                  // Store reference for cleanup
                  video._overlayContainer = videoOverlay;
                } else {
                  console.warn(
                    `Right panel not found for player ${this.playerId}`,
                  );
                  reject(
                    new Error(
                      `Right panel not found for player ${this.playerId}`,
                    ),
                  );
                  return;
                }
              } catch (error) {
                console.warn(`Failed to append video to right-panel:`, error);
                reject(error);
                return;
              }

              // 映像終了後に削除（エラーハンドリング付き）
              video.onended = () => {
                try {
                  if (
                    video._overlayContainer &&
                    video._overlayContainer.parentNode
                  ) {
                    video._overlayContainer.parentNode.removeChild(
                      video._overlayContainer,
                    );
                  } else if (video.parentNode) {
                    video.parentNode.removeChild(video);
                  }
                } catch (error) {
                  console.warn(`Failed to remove video element:`, error);
                }
              };

              // Default duration fallback if video duration is invalid
              resolve(duration > 0 ? duration : 3000); // 最低3秒
            };

            video.onerror = (error) => {
              clearTimeout(loadTimeout);
              console.error(`Video error for ${videoPath}:`, error);
              reject(new Error(`Failed to load video: ${videoPath}`));
            };

            // Set source and handle immediate errors
            try {
              video.src = videoPath;
            } catch (error) {
              clearTimeout(loadTimeout);
              reject(new Error(`Invalid video path: ${videoPath}`));
            }
          });
        }

        // フォールバック：デフォルトスロットアニメーション
        async fallbackToDefaultSlot(slot) {
          console.log(`P${this.playerId} Executing fallback slot animation`);
          if (this.playerId === 1) {
            spinTo1(slot);
          } else {
            spinTo2(slot);
          }
          await this.waitForSlotAnimation();
        }

        // 指定時間だけスロットを回転
        async spinSlotForDuration(slot, duration) {
          // Ensure minimum and maximum duration limits
          const minDuration = 2000; // 最低2秒
          const maxDuration = 10000; // 最大10秒
          const safeDuration = Math.max(
            minDuration,
            Math.min(maxDuration, duration),
          );

          if (safeDuration !== duration) {
            console.warn(
              `P${this.playerId} Duration adjusted from ${duration}ms to ${safeDuration}ms`,
            );
          }

          // スロット回転開始
          console.log(
            `P${this.playerId} Starting slot spin for ${safeDuration}ms`,
          );
          if (this.playerId === 1) {
            spinTo1(slot);
          } else {
            spinTo2(slot);
          }

          // 指定時間待機
          await new Promise((resolve) => setTimeout(resolve, safeDuration));

          // スロット回転完了を待つ
          console.log(
            `P${this.playerId} Waiting for slot animation to complete`,
          );
          await this.waitForSlotAnimation();
        }

        // スロットアニメーション完了を待つ
        waitForSlotAnimation() {
          return new Promise((resolve) => {
            const checkInterval = setInterval(() => {
              const status = getSlotStatus(this.playerId);
              if (!status.isSpinning && status.queueLength === 0) {
                clearInterval(checkInterval);

                // ゲーム側のスロット回転状態をリセット
                if (this.playerId === 1 && window.game1) {
                  window.game1.setSlotSpinning(false);
                  console.log(
                    `Player ${this.playerId} slot spinning state reset`,
                  );
                  // 状態表示を更新
                  this.updateState(this.playerId, window.game1.getState());
                } else if (this.playerId === 2 && window.game2) {
                  window.game2.setSlotSpinning(false);
                  console.log(
                    `Player ${this.playerId} slot spinning state reset`,
                  );
                  // 状態表示を更新
                  this.updateState(this.playerId, window.game2.getState());
                }

                // 少し余裕を持って完了を待つ
                setTimeout(resolve, 300);
              }
            }, 100);

            // 最大10秒でタイムアウト
            setTimeout(() => {
              clearInterval(checkInterval);
              console.warn(`Player ${this.playerId} slot animation timeout`);

              // タイムアウト時もスロット回転状態をリセット
              if (this.playerId === 1 && window.game1) {
                window.game1.setSlotSpinning(false);
                console.log(
                  `Player ${this.playerId} slot spinning state reset (timeout)`,
                );
                // 状態表示を更新
                this.updateState(this.playerId, window.game1.getState());
              } else if (this.playerId === 2 && window.game2) {
                window.game2.setSlotSpinning(false);
                console.log(
                  `Player ${this.playerId} slot spinning state reset (timeout)`,
                );
                // 状態表示を更新
                this.updateState(this.playerId, window.game2.getState());
              }

              resolve();
            }, 10000);
          });
        }

        // キューの状態を取得
        getStatus() {
          return {
            queueLength: this.queue.length,
            isProcessing: this.isProcessing,
            queue: [...this.queue],
          };
        }

        // キューをクリア
        clear() {
          this.queue = [];
          this.isProcessing = false;
          console.log(`Player ${this.playerId} task queue cleared`);
        }
      }

      // プレイヤー別のタスクキュー（updateState関数はmain関数内で定義されるため、後で設定）
      let taskQueue1;
      let taskQueue2;

      // 排他制御用の変数（スロットレベル）
      let isSpinning1 = false;
      let isSpinning2 = false;
      let spinQueue1 = [];
      let spinQueue2 = [];

      // スロット状態チェック関数
      function getSlotStatus(playerId) {
        if (playerId === 1) {
          return {
            isSpinning: isSpinning1,
            queueLength: spinQueue1.length,
            queue: [...spinQueue1],
          };
        } else if (playerId === 2) {
          return {
            isSpinning: isSpinning2,
            queueLength: spinQueue2.length,
            queue: [...spinQueue2],
          };
        }
        return null;
      }

      // 強制的にスロット状態をリセットする関数（デバッグ用）
      function forceResetSlotState(playerId) {
        if (playerId === 1) {
          isSpinning1 = false;
          spinQueue1 = [];
          if (taskQueue1) {
            taskQueue1.clear();
          }
          console.log(
            "プレイヤー1: スロット状態とタスクキューを強制リセットしました",
          );
        } else if (playerId === 2) {
          isSpinning2 = false;
          spinQueue2 = [];
          if (taskQueue2) {
            taskQueue2.clear();
          }
          console.log(
            "プレイヤー2: スロット状態とタスクキューを強制リセットしました",
          );
        } else if (playerId === "both") {
          isSpinning1 = false;
          isSpinning2 = false;
          spinQueue1 = [];
          spinQueue2 = [];
          if (taskQueue1) {
            taskQueue1.clear();
          }
          if (taskQueue2) {
            taskQueue2.clear();
          }
          console.log(
            "両プレイヤー: スロット状態とタスクキューを強制リセットしました",
          );
        }
      }

      // 初期化: 各リールに繰り返し数字リストを作成
      function buildReelList(reelEl) {
        const list = reelEl.querySelector(".reel-list");
        list.innerHTML = "";

        // REPEAT回分の数字を作成
        for (let r = 0; r < REPEAT; r++) {
          for (const n of numbers) {
            const div = document.createElement("div");
            div.className = "cell";
            div.textContent = n;
            list.appendChild(div);
          }
        }

        // さらに1周分追加してスクロール端での空白を防ぐ
        for (const n of numbers) {
          const div = document.createElement("div");
          div.className = "cell";
          div.textContent = n;
          list.appendChild(div);
        }

        // 初期位置: 中央ブロックの最初（0）が見えるように設定（表示位置を2つ下に調整）
        const centerBlockStart = Math.floor(REPEAT / 2) * numbers.length;
        list.style.transform = `translateY(-${(centerBlockStart - 2) * cellH}px)`;
      }

      reels1.forEach(buildReelList);
      reels2.forEach(buildReelList);

      // 指定された3つの数字を即座に表示
      function setDigits(digits, reelArray = reels1) {
        digits = normalizeDigits(digits);
        reelArray.forEach((reelEl, idx) => {
          const list = reelEl.querySelector(".reel-list");
          const targetNumber = digits[idx] % 10;

          // 中央ブロックでの目標位置を計算（表示位置を2つ下に調整）
          const centerBlockStart = Math.floor(REPEAT / 2) * numbers.length;
          const targetPositionInBlock = numbers.indexOf(targetNumber);
          const finalPosition = centerBlockStart + targetPositionInBlock - 2;
          const offset = finalPosition * cellH;

          // トランジションなしで即座に移動
          list.style.transition = "none";
          list.style.transform = `translateY(-${offset}px)`;

          // 次回のアニメーション用にトランジションを復活
          requestAnimationFrame(() => {
            list.style.transition = "transform 600ms cubic-bezier(.2,.8,.2,1)";
          });
        });
      }

      // スロット風回転: 必ず上から下へ回転して目標数字で停止
      // spinDurations: リールごとの時間指定
      //   - null: デフォルトのランダム時間
      //   - 数値: 全リール共通の基本時間（後方互換）
      //   - 配列: [reel0_duration, reel1_duration, reel2_duration] 各リール個別時間
      //   例: spinTo1([1,2,3], [1000, 1500, 2000]) // 1桁目1秒、2桁目1.5秒、3桁目2秒
      function spinTo(digits, reelArray = reels1, spinDurations = null) {
        // 排他制御: どちらのリールセットかを判定
        const isReel1 = reelArray === reels1;
        const isSpinning = isReel1 ? isSpinning1 : isSpinning2;
        const spinQueue = isReel1 ? spinQueue1 : spinQueue2;

        // 現在スピン中の場合はキューに追加して終了
        if (isSpinning) {
          console.log(
            `Player ${isReel1 ? 1 : 2} slot is spinning, adding to queue:`,
            digits,
          );
          spinQueue.push({ digits, spinDurations });
          return;
        }

        // スピン開始フラグをセット
        if (isReel1) {
          isSpinning1 = true;
        } else {
          isSpinning2 = true;
        }

        console.log(`Player ${isReel1 ? 1 : 2} slot spin started:`, digits);

        digits = normalizeDigits(digits);
        const spinTimeouts = [];
        let completedReelsCount = 0; // 完了したリール数をカウント
        let isSpinCompleted = false; // スピン完了フラグ（重複処理防止）

        reelArray.forEach((reelEl, idx) => {
          const list = reelEl.querySelector(".reel-list");

          // 回転時間の計算
          let baseDuration, duration;
          if (spinDurations !== null && spinDurations[idx] !== undefined) {
            // 指定された各リールの時間を使用
            baseDuration = spinDurations[idx];
            const extra = Math.random() * 100; // 少しのランダム要素を残す
            duration = baseDuration + extra;
          } else if (
            spinDurations !== null &&
            typeof spinDurations === "number"
          ) {
            // 単一の数値が指定された場合（後方互換性）
            baseDuration = spinDurations;
            const extra = idx * 100 + Math.random() * 100;
            duration = baseDuration + extra;
          } else {
            // デフォルトの時間計算（後のリールほど長く、ばらつきを減らして自然に）
            baseDuration = 1800 + Math.random() * 600;
            const extra = idx * 400 + Math.random() * 200;
            duration = baseDuration + extra;
          }

          const targetNumber = digits[idx] % 10;

          // 現在位置を取得
          const currentTransform = parseTransformY(list);
          const currentPosition = currentTransform / cellH;

          // 最低3周以上回転（スロット風）
          const minSpins = 3 + Math.floor(Math.random() * 2);
          const totalRotationCells = minSpins * numbers.length;

          const targetPositionInBlock = numbers.indexOf(targetNumber);

          // 目標位置を中央ブロック基準で直接計算
          const centerBlockStart = Math.floor(REPEAT / 2) * numbers.length;
          const baseTargetPosition =
            centerBlockStart + targetPositionInBlock - 2;

          // 現在位置から最低回転数を保証した目標位置を計算
          let targetPosition = currentPosition + totalRotationCells;

          // 目標位置を中央ブロックの正しい位置に調整
          const positionDifference =
            (baseTargetPosition - targetPosition) % numbers.length;
          if (positionDifference < 0) {
            targetPosition += numbers.length + positionDifference;
          } else {
            targetPosition += positionDifference;
          }

          const targetOffset = targetPosition * cellH;

          // より自然な減速アニメーション
          list.style.transition = `transform ${duration}ms cubic-bezier(0.23, 1, 0.320, 1)`;

          // カスケード効果で順次開始
          setTimeout(() => {
            list.style.transform = `translateY(-${targetOffset}px)`;

            // transitionendイベントでアニメーション完了を確実に検知
            const handleTransitionEnd = (event) => {
              // transform プロパティのトランジション完了のみ処理
              if (event.propertyName === "transform") {
                list.removeEventListener("transitionend", handleTransitionEnd);

                // アニメーションなしで中央ブロック内の適切な位置にリセット
                const centerBlockStart =
                  Math.floor(REPEAT / 2) * numbers.length;
                const resetTargetPosition =
                  centerBlockStart + targetPositionInBlock - 2;
                const resetOffset = resetTargetPosition * cellH;

                // トランジションを無効化してリセット
                list.style.transition = "none";
                list.style.transform = `translateY(-${resetOffset}px)`;

                // 少し遅れてトランジションを復活
                setTimeout(() => {
                  list.style.transition =
                    "transform 400ms cubic-bezier(.2,.8,.2,1)";
                }, 10);

                // 完了したリール数をインクリメント
                completedReelsCount++;
                console.log(
                  `Player ${isReel1 ? 1 : 2} reel ${idx} completed (${completedReelsCount}/${reelArray.length})`,
                );

                // 全リールが完了したかチェック（重複処理防止）
                if (
                  completedReelsCount === reelArray.length &&
                  !isSpinCompleted
                ) {
                  isSpinCompleted = true;
                  console.log(
                    `Player ${isReel1 ? 1 : 2} all reels completed, waiting for settlement...`,
                  );

                  // 全リール完了時の処理（少し長めに待機して確実にアニメーションが完了してから）
                  setTimeout(() => {
                    // スピン完了フラグをリセット
                    if (isReel1) {
                      isSpinning1 = false;
                    } else {
                      isSpinning2 = false;
                    }

                    console.log(
                      `Player ${isReel1 ? 1 : 2} slot spin completed and ready for next`,
                    );

                    // キューに待機中のスピンがあれば実行
                    if (spinQueue.length > 0) {
                      const nextSpin = spinQueue.shift();
                      console.log(
                        `Player ${isReel1 ? 1 : 2} executing queued spin:`,
                        nextSpin.digits,
                      );
                      setTimeout(
                        () =>
                          spinTo(
                            nextSpin.digits,
                            reelArray,
                            nextSpin.spinDurations,
                          ),
                        300,
                      );
                    }
                  }, 200); // アニメーションが確実に完了するまで待機
                }
              }
            };

            list.addEventListener("transitionend", handleTransitionEnd);

            // フォールバックタイムアウト（イベントが発火しない場合の保険）
            // 最大アニメーション時間を考慮して十分に長めに設定
            const maxDuration =
              spinDurations !== null &&
              (Array.isArray(spinDurations) ||
                typeof spinDurations === "number")
                ? baseDuration +
                  (reelArray.length - 1) * 100 +
                  Math.random() * 100
                : baseDuration +
                  (reelArray.length - 1) * 400 +
                  Math.random() * 200;
            const fallbackTimeout = setTimeout(() => {
              if (!isSpinCompleted) {
                console.warn(
                  `Player ${isReel1 ? 1 : 2} reel ${idx} fallback timeout triggered`,
                );
                list.removeEventListener("transitionend", handleTransitionEnd);
                handleTransitionEnd({ propertyName: "transform" });
              }
            }, maxDuration + 1500);

            spinTimeouts.push(fallbackTimeout);
          }, idx * 200);
        });

        // 停止用の関数を返す
        return function stop() {
          spinTimeouts.forEach((id) => clearTimeout(id));

          // スピン状態をリセット
          if (isReel1) {
            isSpinning1 = false;
          } else {
            isSpinning2 = false;
          }

          // 各リールを即座に目標位置に移動
          reelArray.forEach((reelEl, idx) => {
            const list = reelEl.querySelector(".reel-list");
            list.style.transition = "transform 300ms ease-out";
          });
          setDigits(digits, reelArray);

          console.log(`Player ${isReel1 ? 1 : 2} slot spin stopped`);
        };
      }

      // ユーティリティ: 数字配列の正規化
      function normalizeDigits(d) {
        console.log("normalizeDigits", d);
        if (!Array.isArray(d)) throw new Error("配列で渡してください: [a,b,c]");
        if (d.length !== 3) throw new Error("要素数は3つ必要です");
        return d.map((x) => Number(x) || 0).map((x) => ((x % 10) + 10) % 10);
      }

      // ユーティリティ: 現在のtranslateY値を取得
      function parseTransformY(list) {
        const t = getComputedStyle(list).transform;
        if (!t || t === "none") return 0;

        // matrix形式
        const matrixMatch = t.match(
          /matrix\(([^,]+),\s*([^,]+),\s*([^,]+),\s*([^,]+),\s*([^,]+),\s*([^\)]+)\)/,
        );
        if (matrixMatch) {
          return Math.abs(parseFloat(matrixMatch[6]));
        }

        // translateY形式
        const translateMatch = t.match(/translateY\((-?\d+(?:\.\d+)?)px\)/);
        if (translateMatch) {
          return Math.abs(parseFloat(translateMatch[1]));
        }

        // translate3d形式
        const translate3dMatch = t.match(
          /translate3d\(([^,]+),\s*(-?\d+(?:\.\d+)?)px,\s*([^\)]+)\)/,
        );
        if (translate3dMatch) {
          return Math.abs(parseFloat(translate3dMatch[2]));
        }

        return 0;
      }

      // プレイヤー1用のエイリアス関数
      function setDigits1(digits) {
        console.log("Player 1 setDigits called:", digits);
        return setDigits(digits, reels1);
      }

      function spinTo1(digits, spinDurations = null) {
        console.log("Player 1 spinTo called:", digits);
        return spinTo(digits, reels1, spinDurations);
      }

      // プレイヤー2用のエイリアス関数
      function setDigits2(digits) {
        console.log("Player 2 setDigits called:", digits);
        return setDigits(digits, reels2);
      }

      function spinTo2(digits, spinDurations = null) {
        console.log("Player 2 spinTo called:", digits);
        return spinTo(digits, reels2, spinDurations);
      }

      // 両プレイヤー同時操作用のエイリアス関数
      function setDigitsBoth(digits) {
        console.log("Both players setDigits called:", digits);
        setDigits1(digits);
        setDigits2(digits);
      }

      function spinToBoth(digits, spinDurations = null) {
        spinTo1(digits, spinDurations);
        spinTo2(digits, spinDurations);
      }

      // デバッグ関数をグローバルスコープに公開
      window.getSlotStatus = getSlotStatus;
      window.forceResetSlotState = forceResetSlotState;
      window.debugSlots = () => {
        console.log("=== スロット状態 ===");
        console.log("プレイヤー1:", getSlotStatus(1));
        console.log("プレイヤー2:", getSlotStatus(2));
      };
      window.getTaskQueueStatus = (playerId) => {
        if (playerId === 1) return taskQueue1 ? taskQueue1.getStatus() : null;
        if (playerId === 2) return taskQueue2 ? taskQueue2.getStatus() : null;
        return {
          player1: taskQueue1 ? taskQueue1.getStatus() : null,
          player2: taskQueue2 ? taskQueue2.getStatus() : null,
        };
      };
      window.debugTaskQueues = () => {
        console.log("=== タスクキュー状態 ===");
        console.log(
          "プレイヤー1:",
          taskQueue1 ? taskQueue1.getStatus() : "未初期化",
        );
        console.log(
          "プレイヤー2:",
          taskQueue2 ? taskQueue2.getStatus() : "未初期化",
        );
      };

      window.debugSpinningState = () => {
        console.log("=== スロット回転状態 ===");
        console.log("UI側スロット状態:");
        console.log("  プレイヤー1:", getSlotStatus(1));
        console.log("  プレイヤー2:", getSlotStatus(2));
        console.log("ゲーム側スロット状態:");
        console.log(
          "  プレイヤー1:",
          window.game1 ? window.game1.isSlotCurrentlySpinning() : "未初期化",
        );
        console.log(
          "  プレイヤー2:",
          window.game2 ? window.game2.isSlotCurrentlySpinning() : "未初期化",
        );
      };

      // テスト用のデバッグ関数
      window.testSlotTiming = (playerId = 1, count = 3, interval = 500) => {
        console.log(`=== プレイヤー${playerId}のスロット連続テスト開始 ===`);
        const spinFunc = playerId === 1 ? spinTo1 : spinTo2;

        for (let i = 0; i < count; i++) {
          setTimeout(() => {
            const digits = [
              Math.floor(Math.random() * 10),
              Math.floor(Math.random() * 10),
              Math.floor(Math.random() * 10),
            ];
            console.log(`テスト ${i + 1}/${count}:`, digits);
            spinFunc(digits);
          }, i * interval);
        }
      };

      // 両プレイヤー同時回転テスト
      window.testBothSlots = (count = 2, interval = 1000) => {
        console.log("=== 両プレイヤー同時スロットテスト開始 ===");
        for (let i = 0; i < count; i++) {
          setTimeout(() => {
            const digits1 = [
              Math.floor(Math.random() * 10),
              Math.floor(Math.random() * 10),
              Math.floor(Math.random() * 10),
            ];
            const digits2 = [
              Math.floor(Math.random() * 10),
              Math.floor(Math.random() * 10),
              Math.floor(Math.random() * 10),
            ];
            console.log(`両プレイヤーテスト ${i + 1}/${count}:`, {
              player1: digits1,
              player2: digits2,
            });
            spinTo1(digits1);
            spinTo2(digits2);
          }, i * interval);
        }
      };

      // 各リール個別時間指定テスト
      window.testIndividualReelTiming = (playerId = 1) => {
        console.log(`=== プレイヤー${playerId}の各リール個別時間テスト ===`);
        const spinFunc = playerId === 1 ? spinTo1 : spinTo2;

        // テストパターン1: 左から右へ順次長く
        setTimeout(() => {
          const digits = [7, 7, 7];
          const durations = [1000, 1500, 2000]; // 1秒、1.5秒、2秒
          console.log("パターン1 - 左から右へ順次長く:", { digits, durations });
          spinFunc(digits, durations);
        }, 0);

        // テストパターン2: 右から左へ順次長く
        setTimeout(() => {
          const digits = [3, 3, 3];
          const durations = [2000, 1500, 1000]; // 2秒、1.5秒、1秒
          console.log("パターン2 - 右から左へ順次長く:", { digits, durations });
          spinFunc(digits, durations);
        }, 4000);

        // テストパターン3: 中央だけ長く
        setTimeout(() => {
          const digits = [1, 2, 3];
          const durations = [1000, 3000, 1000]; // 1秒、3秒、1秒
          console.log("パターン3 - 中央だけ長く:", { digits, durations });
          spinFunc(digits, durations);
        }, 8000);

        // テストパターン4: 全リール同じ時間（配列指定）
        setTimeout(() => {
          const digits = [5, 5, 5];
          const durations = [1800, 1800, 1800]; // 全て1.8秒
          console.log("パターン4 - 全リール同じ時間（配列）:", {
            digits,
            durations,
          });
          spinFunc(digits, durations);
        }, 12000);

        // テストパターン5: 従来の数値指定（後方互換性確認）
        setTimeout(() => {
          const digits = [9, 8, 7];
          const duration = 2500; // 単一数値
          console.log("パターン5 - 従来の数値指定:", { digits, duration });
          spinFunc(digits, duration);
        }, 16000);
      };

      // タスクキューのテスト関数
      window.testTaskQueue = (playerId = 1, count = 3) => {
        console.log(`=== プレイヤー${playerId}のタスクキューテスト開始 ===`);
        const taskQueue = playerId === 1 ? taskQueue1 : taskQueue2;

        if (!taskQueue) {
          console.error("タスクキューが未初期化です");
          return;
        }

        for (let i = 0; i < count; i++) {
          const digits = [
            Math.floor(Math.random() * 10),
            Math.floor(Math.random() * 10),
            Math.floor(Math.random() * 10),
          ];

          // 抽選タスクを直接キューに追加
          taskQueue.addTask("lotteryNormal", {
            lotteryResult: { type: "Normal", value: Math.random() * 100 },
            slotResult: [digits, digits],
            taskType: `Test Normal Lottery ${i + 1}`,
          });

          // 状態更新タスクも追加
          taskQueue.addTask("default", {
            after: {
              type: "Normal",
              balls: 1000 - i * 10,
            },
          });
        }
      };

      window.testMixedTasks = (playerId = 1) => {
        console.log(`=== プレイヤー${playerId}の混合タスクテスト開始 ===`);
        const taskQueue = playerId === 1 ? taskQueue1 : taskQueue2;

        if (!taskQueue) {
          console.error("タスクキューが未初期化です");
          return;
        }

        // 通常抽選
        taskQueue.addTask("lotteryNormal", {
          lotteryResult: { type: "Win" },
          slotResult: [
            [1, 2, 3],
            [4, 5, 6],
          ],
          taskType: "Mixed Test Normal",
        });

        // 状態更新
        taskQueue.addTask("default", {
          after: { type: "Normal", balls: 950 },
        });

        // ラッシュ抽選
        taskQueue.addTask("lotteryRush", {
          lotteryResult: { type: "Rush" },
          slotResult: [
            [7, 7, 7],
            [7, 7, 7],
          ],
          taskType: "Mixed Test Rush",
        });

        // さらに状態更新
        taskQueue.addTask("default", {
          after: { type: "Rush", balls: 900, rushBalls: 50, n: 1 },
        });
      };

      // 統合デバッグ関数
      window.debugAll = () => {
        console.log("=== 統合デバッグ情報 ===");
        console.log("=== スロット状態 ===");
        console.log("プレイヤー1:", getSlotStatus(1));
        console.log("プレイヤー2:", getSlotStatus(2));
        console.log("=== タスクキュー状態 ===");
        console.log(
          "プレイヤー1:",
          taskQueue1 ? taskQueue1.getStatus() : "未初期化",
        );
        console.log(
          "プレイヤー2:",
          taskQueue2 ? taskQueue2.getStatus() : "未初期化",
        );
      };

      setDigitsBoth([0, 0, 0]);

      import {
        init,
        WasmGame,
        ControlFlow,
        Config,
        BallsConfig,
        Probability,
        SlotProbability,
        JsInput,
        JsOutput,
      } from "./pachislo.js";

      // Matter.jsの主要モジュールを取得
      const {
        Engine,
        Render,
        Runner,
        Bodies,
        Composite,
        Events,
        Mouse,
        MouseConstraint,
      } = Matter;

      // パチンコゲームコンポーネントクラス
      class PachinkoGame {
        constructor(
          canvasId,
          playerId,
          keyBinding,
          nails,
          wasmGame,
          recreateWasmGame,
        ) {
          this.canvasId = canvasId;
          this.playerId = playerId;
          this.keyBinding = keyBinding;
          this.fallingBalls = [];
          this.nails_index = nails;
          this.wasmgame = wasmGame;
          this.recreateWasmGame = recreateWasmGame; // WASMGame再作成用の関数
          this.lastLaunchTime = 0; // 最後のボール発射時刻を記録
          this.gameTimer = null; // ゲーム終了タイマー
          this.gameDuration = 5 * 60 * 1000; // デフォルト5分
          this.gameStartTime = null; // ゲーム開始時刻
          this.displayTimer = null; // タイマー表示用インターバル

          this.init(); // canvasと物理エンジンは最初から初期化
        }

        run_step_with_command(command) {
          this.wasmgame.run_step_with_command(command);
        }

        init() {
          // エンジンを作成
          this.engine = Engine.create();
          this.world = this.engine.world;
          this.engine.world.gravity.y = 0.8;

          // レンダラーを作成
          this.setupRenderer();

          // ゲーム要素を作成
          this.createWalls();
          this.createNails();
          this.createTargetZones();
          this.setupMouseControl();
          this.setupEventListeners();

          // 世界にオブジェクトを追加
          this.addToWorld();

          // エンジンを開始
          this.start();
        }

        async startWasmGame() {
          console.log(
            `プレイヤー${this.playerId}: startWasmGame()が呼ばれました。現在のisGameStarted: ${this.wasmgame.isGameStarted()}`,
          );

          if (this.wasmgame.isGameStarted()) {
            console.log(
              `プレイヤー${this.playerId}: 既にゲーム開始済みのため処理をスキップします`,
            );
            return; // 既にゲーム開始済みの場合は何もしない
          }

          // パチスロゲームを開始
          console.log(
            `プレイヤー${this.playerId}: StartGameコマンドを実行します`,
          );
          this.run_step_with_command("StartGame");

          // 既存のタイマーをクリア
          if (this.displayTimer) {
            clearInterval(this.displayTimer);
            this.displayTimer = null;
          }

          // ゲーム開始時刻を記録
          this.gameStartTime = Date.now();

          // 設定時間後にゲームを終了させるタイマーを設定
          this.gameTimer = setTimeout(async () => {
            await this.endGame();
          }, this.gameDuration);

          // タイマー表示を開始
          this.startTimerDisplay();

          console.log(
            `プレイヤー${this.playerId}: ゲーム開始！5分後に自動終了します。isGameStarted: ${this.wasmgame.isGameStarted()}`,
          );
        }

        async endGame() {
          if (!this.wasmgame.isGameStarted()) {
            console.log(
              `プレイヤー${this.playerId}: endGame()が呼ばれましたが、既にゲームは終了状態です`,
            );
            return;
          }

          console.log(`プレイヤー${this.playerId}: ゲーム終了！`);

          // タイマーをクリア
          if (this.gameTimer) {
            clearTimeout(this.gameTimer);
            this.gameTimer = null;
          }

          // タイマー表示をクリア
          if (this.displayTimer) {
            clearInterval(this.displayTimer);
            this.displayTimer = null;
          }

          // タイマー表示をリセット
          const timerDisplay = document.getElementById(
            `timer-display${this.playerId}`,
          );
          if (timerDisplay) {
            const minutes = Math.floor(this.gameDuration / 60000);
            timerDisplay.textContent = `${minutes}:00`;
            timerDisplay.style.color = "white";
            timerDisplay.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
          }

          // ゲーム開始時刻をリセット
          this.gameStartTime = null;

          // ゲーム終了処理
          console.log(
            `プレイヤー${this.playerId}: FinishGameコマンドを実行します`,
          );
          this.run_step_with_command("FinishGame");

          // FinishGameコマンドの処理完了を待つ
          console.log(
            `プレイヤー${this.playerId}: ゲーム終了処理の完了を待機中...`,
          );
          await new Promise((resolve) => setTimeout(resolve, 100));

          // 新しいWASMGameインスタンスを作成
          console.log(
            `プレイヤー${this.playerId}: 新しいWASMGameインスタンスを作成します`,
          );
          this.wasmgame = this.recreateWasmGame();

          // windowオブジェクトも更新
          if (this.playerId === 1) {
            window.game1 = this.wasmgame;
          } else if (this.playerId === 2) {
            window.game2 = this.wasmgame;
          }

          console.log(
            `プレイヤー${this.playerId}: ゲーム終了処理完了。isGameStarted: ${this.wasmgame.isGameStarted()}`,
          );
        }

        startTimerDisplay() {
          this.displayTimer = setInterval(() => {
            if (this.gameStartTime) {
              const elapsed = Date.now() - this.gameStartTime;
              const remaining = Math.max(0, this.gameDuration - elapsed);
              const minutes = Math.floor(remaining / 60000);
              const seconds = Math.floor((remaining % 60000) / 1000);
              const timeString = `${minutes}:${seconds.toString().padStart(2, "0")}`;

              const timerDisplay = document.getElementById(
                `timer-display${this.playerId}`,
              );
              if (timerDisplay) {
                timerDisplay.textContent = timeString;
                if (remaining <= 30000) {
                  // 30秒以下で赤色警告
                  timerDisplay.style.color = "#ff4444";
                  timerDisplay.style.backgroundColor = "rgba(255, 68, 68, 0.2)";
                }
              }

              if (remaining === 0 && this.displayTimer) {
                clearInterval(this.displayTimer);
                this.displayTimer = null;
              }
            }
          }, 1000);
        }

        setGameDuration(minutes) {
          this.gameDuration = minutes * 60 * 1000;
          // タイマー表示も更新
          const timerDisplay = document.getElementById(
            `timer-display${this.playerId}`,
          );
          if (timerDisplay) {
            timerDisplay.textContent = `${minutes}:00`;
            timerDisplay.style.color = "white";
            timerDisplay.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
          }
        }

        setupRenderer() {
          const canvas = document.getElementById(this.canvasId);
          this.render = Render.create({
            canvas: canvas,
            engine: this.engine,
            options: {
              width: 200,
              height: 800,
              wireframes: false,
              background: "transparent",
              showAngleIndicator: true,
              showVelocity: false,
            },
          });
        }

        createWalls() {
          this.walls = [
            Bodies.rectangle(0, 400, 30, 800, {
              isStatic: true,
              render: { fillStyle: "#444" },
            }),
            Bodies.rectangle(200, 400, 30, 800, {
              isStatic: true,
              render: { fillStyle: "#444" },
            }),
          ];
        }

        createNails() {
          this.nails = [];

          const nailRadius = 2;

          for (let { x, y } of this.nails_index) {
            const nail = Bodies.circle(x, y, nailRadius, {
              isStatic: true,
              render: {
                fillStyle: "#e74c3c",
                strokeStyle: "#c0392b",
                lineWidth: 0.5,
              },
            });

            this.nails.push(nail);
          }
        }

        createTargetZones() {
          // あたりエリア（緑）
          this.winZone = Bodies.rectangle(100, 770, 30, 30, {
            isSensor: true,
            isStatic: true,
            render: {
              fillStyle: "#2ecc71",
              strokeStyle: "#27ae60",
              lineWidth: 2,
              opacity: 0.8,
            },
          });

          // 通常エリア（赤）
          this.normalZone = Bodies.rectangle(100, 770, 160, 30, {
            isSensor: true,
            isStatic: true,
            render: {
              fillStyle: "#e74c3c",
              strokeStyle: "#c0392b",
              lineWidth: 1,
              opacity: 0.5,
            },
          });
        }

        setupMouseControl() {
          const mouse = Mouse.create(this.render.canvas);
          this.mouseConstraint = MouseConstraint.create(this.engine, {
            mouse: mouse,
            constraint: {
              stiffness: 0.2,
              render: { visible: false },
            },
          });
        }

        setupEventListeners() {
          // 衝突検知イベント
          Events.on(this.engine, "collisionStart", (event) => {
            this.handleCollisions(event.pairs);
          });
        }

        handleCollisions(pairs) {
          pairs.forEach((pair) => {
            const { bodyA, bodyB } = pair;

            if (bodyA === this.winZone || bodyB === this.winZone) {
              const ball = bodyA === this.winZone ? bodyB : bodyA;

              if (this.fallingBalls.includes(ball)) {
                console.log(
                  `🎉 プレイヤー${this.playerId}: あたり！球が当たりエリアを通過しました！ (Ball ID: ${ball.id}, 位置: x=${Math.round(ball.position.x)}, y=${Math.round(ball.position.y)})`,
                );

                this.run_step_with_command("CauseLottery");

                const index = this.fallingBalls.indexOf(ball);
                if (index > -1) {
                  this.fallingBalls.splice(index, 1);
                }
              }
            }
          });
        }

        addToWorld() {
          Composite.add(this.world, [
            ...this.walls,
            ...this.nails,
            this.normalZone,
            this.winZone,
            this.mouseConstraint,
          ]);
        }

        start() {
          Render.run(this.render);
          this.runner = Runner.create();
          Runner.run(this.runner, this.engine);
        }

        launchBall() {
          // 発射時刻を更新
          this.lastLaunchTime = Date.now();

          // ゲーム状態をチェック
          const gameState = this.wasmgame.getState();
          if (gameState.type === "Uninitialized") {
            console.log(
              `プレイヤー${this.playerId}: ゲームが未初期化のため球を打てません - StartGameコマンドでゲームを開始してください`,
            );
            console.log(
              `プレイヤー${this.playerId}: 現在のゲーム状態:`,
              gameState,
            );
            return;
          }

          // スロット回転状態をチェック
          if (this.wasmgame.isSlotCurrentlySpinning()) {
            console.log(
              `プレイヤー${this.playerId}: ゲーム側でスロット回転中のため球を打てません - 回転終了まで待機`,
            );
            return;
          }

          // スロットが実際に回転中かもチェック
          const slotStatus = getSlotStatus(this.playerId);
          if (slotStatus && slotStatus.isSpinning) {
            console.log(
              `プレイヤー${this.playerId}: UI側でスロット回転中のため球を打てません - キュー長: ${slotStatus.queueLength}`,
            );
            return;
          }

          let bigBall = null;

          try {
            bigBall = Bodies.circle(50 + Math.random() * 100, 30, 6, {
              render: {
                fillStyle: "#3498db",
                strokeStyle: "#2980b9",
                lineWidth: 1.5,
              },
              restitution: 0.6,
              friction: 0.3,
            });

            this.fallingBalls.push(bigBall);
            Composite.add(this.world, bigBall);

            this.run_step_with_command("LaunchBall");

            console.log(
              `プレイヤー${this.playerId}: 新しい球を落下開始 (ID: ${bigBall.id})`,
            );
          } catch (error) {
            console.log(
              `プレイヤー${this.playerId}: 球の発射に失敗: ${error.message}`,
            );
            return;
          }

          // 5秒後にボールを自動削除
          setTimeout(() => {
            // bigBallが正常に作成されていることを確認
            if (bigBall) {
              // ボールが配列に存在するかチェック
              const ballIndex = this.fallingBalls.findIndex(
                (ball) => ball.id === bigBall.id,
              );
              if (ballIndex !== -1) {
                // 配列から削除
                this.fallingBalls.splice(ballIndex, 1);
                // 物理世界から削除
                Composite.remove(this.world, bigBall);
                console.log(
                  `プレイヤー${this.playerId}: 球を自動削除 (ID: ${bigBall.id})`,
                );
              }
            }
          }, 7000);
        }

        resetSimulation() {
          this.fallingBalls.forEach((ball) => {
            Composite.remove(this.world, ball);
          });
          this.fallingBalls = [];

          this.run_step_with_command("FinishGame");

          // スロット状態とタスクキューもリセット
          if (this.playerId === 1) {
            isSpinning1 = false;
            spinQueue1 = [];
            if (taskQueue1) {
              taskQueue1.clear();
            }
            console.log(
              "プレイヤー1: スロット状態とタスクキューをリセットしました",
            );
          } else if (this.playerId === 2) {
            isSpinning2 = false;
            spinQueue2 = [];
            if (taskQueue2) {
              taskQueue2.clear();
            }
            console.log(
              "プレイヤー2: スロット状態とタスクキューをリセットしました",
            );
          }

          console.log(
            `プレイヤー${this.playerId}: シミュレーションをリセットしました`,
          );
        }

        // キー入力処理
        handleKeyInput(key) {
          if (key === this.keyBinding) {
            this.launchBall();
            console.log(
              `プレイヤー${this.playerId}: ${this.keyBinding.toUpperCase()}キーで球を落下`,
            );
          }
        }
      }

      async function main() {
        await init();

        let nails1 = [];
        let nails2 = [];

        const nails_count = 100;

        for (let i = 0; i < nails_count; i++) {
          {
            const x = 20 + Math.random() * 160;
            const y = 100 + Math.random() * 600;
            nails1.push({ x: x, y: y });
          }

          {
            const x = 20 + Math.random() * 160;
            const y = 100 + Math.random() * 600;
            nails2.push({ x: x, y: y });
          }
        }

        // スロット番号を更新する関数
        function updateSlots(playerId, slot) {
          if (playerId === 1) {
            spinTo(slot, reels1);
          } else if (playerId === 2) {
            spinTo(slot, reels2);
          }
        }

        // ゲーム状態を更新する関数
        function updateState(playerId, state) {
          console.log(`Player ${playerId} State Updated:`, state);

          const element = document.getElementById(`state${playerId}`);
          const rightPanel = document.getElementById(`right-panel${playerId}`);

          if (element && rightPanel) {
            // ゲームが開始されているかチェック
            const game = playerId === 1 ? game1 : game2;
            if (!game.wasmgame.isGameStarted()) {
              const startKey = playerId === 1 ? "S" : "K";
              element.textContent = `未開始 - ${startKey}キーでスタート`;
              return;
            }

            // スロット回転状態を取得
            const slotStatus = getSlotStatus(playerId);
            const gameSpinningState =
              playerId === 1
                ? window.game1
                  ? window.game1.isSlotCurrentlySpinning()
                  : false
                : window.game2
                  ? window.game2.isSlotCurrentlySpinning()
                  : false;

            const spinStatusText =
              (slotStatus && slotStatus.isSpinning) || gameSpinningState
                ? ""
                : "";

            switch (state.type) {
              case "Normal":
                element.textContent = `通常モード - 球数: ${state.balls}${spinStatusText}`;
                // rightPanel.style.backgroundColor = "black";
                break;
              case "Rush":
                element.textContent = `ラッシュモード - 球数: ${state.balls}, ラッシュ球: ${state.rushBalls}, 回数: ${state.n}${spinStatusText}`;
                // rightPanel.style.backgroundColor = "white";
                break;
              default:
                element.textContent = `未初期化${spinStatusText}`;
            }
          }
        }

        function setTemporalyBackGroundVideo(playerId, videoPath) {
          const beforeVideo = document.getElementById(`video${playerId}`);
          const beforeSource = document.getElementById(`source${playerId}`);
          const beforeVideoPath = beforeSource.getAttribute("src") ?? "";

          beforeVideo.removeAttribute("autoplay");
          beforeVideo.removeAttribute("loop");
          beforeVideo.removeAttribute("muted");

          beforeSource.setAttribute("src", videoPath);

          const video = document.getElementById(`video${playerId}`);
          video.play();
          video.addEventListener("ended", () => {
            beforeSource.setAttribute("src", beforeVideoPath);
            beforeVideo.setAttribute("autoplay", "");
            beforeVideo.setAttribute("loop", "");
            beforeVideo.setAttribute("muted", "");
            video.load();
            video.removeEventListener("ended");
          });
        }

        // タスクキューを初期化（updateState関数が定義された後）
        taskQueue1 = new OutputTaskQueue(1, updateState);
        taskQueue2 = new OutputTaskQueue(2, updateState);

        const input1 = new JsInput();

        const input2 = new JsInput();

        const outputFunctions1 = {
          default: (transition) => {
            taskQueue1.addTask("default", transition);
          },
          finishGame: (gameState) => {
            taskQueue1.addTask("finishGame", gameState);
          },
          lotteryNormal: (lotteryResult, slotResult) => {
            taskQueue1.addTask("lotteryNormal", {
              lotteryResult,
              slotResult,
              taskType: "Normal Lottery",
            });
          },
          lotteryRush: (lotteryResult, slotResult) => {
            taskQueue1.addTask("lotteryRush", {
              lotteryResult,
              slotResult,
              taskType: "Rush Lottery",
            });
          },
          lotteryRushContinue: (lotteryResult, slotResult) => {
            taskQueue1.addTask("lotteryRushContinue", {
              lotteryResult,
              slotResult,
              taskType: "Rush Continue",
            });
          },
          startGame: (state) => {
            updateState(1, state);
          },
        };

        const outputFunctions2 = {
          default: (transition) => {
            taskQueue2.addTask("default", transition);
          },
          finishGame: (gameState) => {
            taskQueue2.addTask("finishGame", gameState);
          },
          lotteryNormal: (lotteryResult, slotResult) => {
            taskQueue2.addTask("lotteryNormal", {
              lotteryResult,
              slotResult,
              taskType: "Normal Lottery",
            });
          },
          lotteryRush: (lotteryResult, slotResult) => {
            taskQueue2.addTask("lotteryRush", {
              lotteryResult,
              slotResult,
              taskType: "Rush Lottery",
            });
          },
          lotteryRushContinue: (lotteryResult, slotResult) => {
            taskQueue2.addTask("lotteryRushContinue", {
              lotteryResult,
              slotResult,
              taskType: "Rush Continue",
            });
          },
          startGame: (state) => {
            updateState(2, state);
          },
        };

        const output1 = new JsOutput(
          outputFunctions1.default,
          outputFunctions1.finishGame,
          outputFunctions1.startGame,
          outputFunctions1.lotteryNormal,
          outputFunctions1.lotteryRush,
          outputFunctions1.lotteryRushContinue,
        );

        const output2 = new JsOutput(
          outputFunctions2.default,
          outputFunctions2.finishGame,
          outputFunctions2.startGame,
          outputFunctions2.lotteryNormal,
          outputFunctions2.lotteryRush,
          outputFunctions2.lotteryRushContinue,
        );

        const config1 = new Config(
          new BallsConfig(100, 15, 30),
          new Probability(
            new SlotProbability(0.16, 0.3, 0.15),
            new SlotProbability(0.48, 0.2, 0.05),
            new SlotProbability(0.5, 0.25, 0.1),
            (n) => {
              return 0.3 ** (n - 1);
            },
          ),
        );

        const config2 = new Config(
          new BallsConfig(1000, 15, 300),
          new Probability(
            new SlotProbability(0.16, 0.3, 0.15),
            new SlotProbability(0.48, 0.2, 0.05),
            new SlotProbability(0.8, 0.25, 0.1),
            (n) => {
              return 0.6 ** (n - 1);
            },
          ),
        );

        // 2つのゲームインスタンスを作成
        const wasmGame1 = new WasmGame(input1, output1, config1);
        const wasmGame2 = new WasmGame(input2, output2, config2);

        // WASMGame再作成用の関数
        const recreateWasmGame1 = () => {
          const newInput1 = new JsInput();
          const newOutput1 = new JsOutput(
            outputFunctions1.default,
            outputFunctions1.finishGame,
            outputFunctions1.startGame,
            outputFunctions1.lotteryNormal,
            outputFunctions1.lotteryRush,
            outputFunctions1.lotteryRushContinue,
          );
          return new WasmGame(newInput1, newOutput1, config1);
        };

        const recreateWasmGame2 = () => {
          const newInput2 = new JsInput();
          const newOutput2 = new JsOutput(
            outputFunctions2.default,
            outputFunctions2.finishGame,
            outputFunctions2.startGame,
            outputFunctions2.lotteryNormal,
            outputFunctions2.lotteryRush,
            outputFunctions2.lotteryRushContinue,
          );
          return new WasmGame(newInput2, newOutput2, config2);
        };

        const game1 = new PachinkoGame(
          "canvas1",
          1,
          "a",
          nails1,
          wasmGame1,
          recreateWasmGame1,
        );
        const game2 = new PachinkoGame(
          "canvas2",
          2,
          "l",
          nails2,
          wasmGame2,
          recreateWasmGame2,
        );

        // グローバルアクセスのためwindowオブジェクトに設定（WasmGameインスタンス）
        window.game1 = wasmGame1;
        window.game2 = wasmGame2;

        // ボタンから呼び出される関数
        function launchBall1() {
          game1.launchBall();
        }
        function resetSimulation1() {
          game1.resetSimulation();
        }
        function dropBall2() {
          game2.launchBall();
        }
        function resetSimulation2() {
          game2.resetSimulation();
        }

        // ゲームを開始

        // game1.run();
        // game2.run();

        // キーボードイベントリスナー（長押し対応）
        const pressedKeys = new Set();
        const keyIntervals = new Map(); // キーごとのインターバルIDを管理
        const lastLaunchTimes = new Map(); // キーごとの最後の発射時刻を管理
        const LONG_PRESS_INTERVAL = 700; // 0.7秒間隔

        // 連打制限付きのキー処理（初回押下時用）
        async function handleKeyPress(key) {
          const now = Date.now();
          const lastLaunchTime = lastLaunchTimes.get(key) || 0;

          // 0.7秒間隔のチェック（連打対応）
          if (now - lastLaunchTime < LONG_PRESS_INTERVAL) {
            console.log(
              `キー ${key} は0.7秒間隔制限により無視されました (残り時間: ${LONG_PRESS_INTERVAL - (now - lastLaunchTime)}ms)`,
            );
            return;
          }

          // 発射時刻を更新
          lastLaunchTimes.set(key, now);

          await executeKeyAction(key);
        }

        // 長押し時のキー処理（制限なし）
        async function handleLongPress(key) {
          await executeKeyAction(key);
        }

        // 実際のキーアクション実行
        async function executeKeyAction(key) {
          // スタートキーのチェック
          if (key === "s") {
            console.log(
              `Sキーが押されました。game1.isGameStarted: ${game1.wasmgame.isGameStarted()}`,
            );
            if (!game1.wasmgame.isGameStarted()) {
              console.log("プレイヤー1のゲームを開始します");
              await game1.startWasmGame();
              return;
            } else {
              console.log("プレイヤー1は既にゲーム開始済みです");
            }
          }
          if (key === "k") {
            console.log(
              `Kキーが押されました。game2.isGameStarted: ${game2.wasmgame.isGameStarted()}`,
            );
            if (!game2.wasmgame.isGameStarted()) {
              console.log("プレイヤー2のゲームを開始します");
              await game2.startWasmGame();
              return;
            } else {
              console.log("プレイヤー2は既にゲーム開始済みです");
            }
          }

          // 通常のキー処理（ゲーム開始後のみ）
          if (key === game1.keyBinding && game1.wasmgame.isGameStarted()) {
            game1.handleKeyInput(game1.keyBinding);
          }
          if (key === game2.keyBinding && game2.wasmgame.isGameStarted()) {
            game2.handleKeyInput(game2.keyBinding);
          }
        }

        document.addEventListener("keydown", (event) => {
          const key = event.key.toLowerCase();

          // 既に押されているキーの場合は無視（リピートイベント防止）
          if (pressedKeys.has(key)) {
            return;
          }

          pressedKeys.add(key);

          // 最初のキー入力を即座に実行（連打制限付き）
          handleKeyPress(key).catch(console.error);

          // 長押し用のインターバルを設定
          if (key === game1.keyBinding || key === game2.keyBinding) {
            const intervalId = setInterval(() => {
              if (pressedKeys.has(key)) {
                console.log(`Long press: ${key}`);
                handleLongPress(key).catch(console.error);
              } else {
                clearInterval(intervalId);
                keyIntervals.delete(key);
              }
            }, LONG_PRESS_INTERVAL);

            keyIntervals.set(key, intervalId);
          }
        });

        document.addEventListener("keyup", (event) => {
          const key = event.key.toLowerCase();
          pressedKeys.delete(key);

          // インターバルをクリア
          if (keyIntervals.has(key)) {
            clearInterval(keyIntervals.get(key));
            keyIntervals.delete(key);
          }
        });

        // ウィンドウフォーカス外れ時にキー状態をリセット
        window.addEventListener("blur", () => {
          console.log("Window lost focus, resetting key states");
          pressedKeys.clear();
          lastLaunchTimes.clear();

          // 全てのインターバルをクリア
          keyIntervals.forEach((intervalId, key) => {
            clearInterval(intervalId);
          });
          keyIntervals.clear();
        });

        // ページの可視性が変わった時もリセット
        document.addEventListener("visibilitychange", () => {
          if (document.hidden) {
            console.log("Page hidden, resetting key states");
            pressedKeys.clear();
            lastLaunchTimes.clear();

            keyIntervals.forEach((intervalId, key) => {
              clearInterval(intervalId);
            });
            keyIntervals.clear();
          }
        });

        // デバッグ用：長押し状態確認関数
        window.debugKeyStates = () => {
          console.log("=== キー状態デバッグ ===");
          console.log("押されているキー:", Array.from(pressedKeys));
          console.log("長押しインターバル:", Array.from(keyIntervals.keys()));
          console.log("インターバル数:", keyIntervals.size);
          console.log("最後の発射時刻:", Object.fromEntries(lastLaunchTimes));
          const now = Date.now();
          lastLaunchTimes.forEach((time, key) => {
            const elapsed = now - time;
            console.log(
              `キー ${key}: ${elapsed}ms前に発射 (次回発射まで${Math.max(0, LONG_PRESS_INTERVAL - elapsed)}ms)`,
            );
          });
        };

        window.clearAllKeyStates = () => {
          console.log("全てのキー状態を強制クリア");
          pressedKeys.clear();
          lastLaunchTimes.clear();
          keyIntervals.forEach((intervalId, key) => {
            clearInterval(intervalId);
          });
          keyIntervals.clear();
        };

        // 背景動画を設定するためのヘルパー関数
        window.setBackgroundVideo = (playerId, videoSrc) => {
          const video = document.getElementById(`video${playerId}`);
          if (video && videoSrc) {
            video.src = videoSrc;
            video.load(); // 新しいソースを読み込み
            console.log(`Player ${playerId}の背景動画を設定: ${videoSrc}`);
          }
        };

        // 両方のプレイヤーに同じ動画を設定するヘルパー関数
        window.setBackgroundVideoForBoth = (videoSrc) => {
          window.setBackgroundVideo(1, videoSrc);
          window.setBackgroundVideo(2, videoSrc);
        };

        // 初期状態の表示を更新
        const element1 = document.getElementById("state1");
        const element2 = document.getElementById("state2");
        if (element1) element1.textContent = "未開始 - Sキーでスタート";
        if (element2) element2.textContent = "未開始 - Kキーでスタート";

        console.log("🎮 デュアルパチンコゲーム準備完了！");
        console.log(
          "プレイヤー1: Sキーでゲーム開始、Aキーで球を落とす (長押し対応 - 0.7秒間隔)",
        );
        console.log(
          "プレイヤー2: Kキーでゲーム開始、Lキーで球を落とす (長押し対応 - 0.7秒間隔)",
        );
        console.log(
          "デバッグコマンド: window.debugKeyStates(), window.clearAllKeyStates()",
        );
      }

      // タイマー設定関数
      function toggleTimeSettings(playerId) {
        const settings = document.getElementById(`time-settings${playerId}`);
        settings.classList.toggle("visible");
      }

      function applyTimeSettings(playerId) {
        const input = document.getElementById(`timer-input${playerId}`);
        const minutes = parseInt(input.value);

        if (minutes < 1 || minutes > 60) {
          alert("Please enter a time between 1 and 60 minutes.");
          return;
        }

        // 対応するゲームインスタンスを取得して時間を設定
        const game = playerId === 1 ? game1 : game2;
        if (game) {
          game.setGameDuration(minutes);
        }

        // 設定パネルを閉じる
        toggleTimeSettings(playerId);
      }

      main();
    </script>
  </body>
</html>
