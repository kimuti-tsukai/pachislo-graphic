<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>„Éë„ÉÅ„Çπ„É≠</title>
    <style>
      body {
        font-family: "Helvetica Neue", Arial, sans-serif;
        display: flex;
        flex-direction: column;
        gap: 18px;
        align-items: center;
        padding: 32px;
        background: #111;
        color: #eee;
      }

      .game-container {
        display: flex;
        gap: 90px;
        justify-content: center;
        align-items: flex-start;
      }

      .game-unit {
        display: flex;
        gap: 30px;
        align-items: flex-start;
        position: relative;
      }

      .canvas-container {
        flex: 0 0 auto;
      }

      canvas {
        border: 2px solid #444;
        background-color: #2a2a2a;
      }

      .right-panel {
        flex: 0 0 350px;
        height: 500px;
        padding: 10px;
        position: relative;
        overflow: visible;
      }

      .right-panel video {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        z-index: -999;
        transform: translateZ(-1px);
        will-change: transform;
      }

      .right-panel > * {
        position: relative;
        z-index: 1;
      }

      .timer-display {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-family: "Courier New", monospace;
        font-size: 18px;
        font-weight: bold;
        z-index: 100;
        display: inline-block;
        width: auto;
        text-align: center;
        border: 2px solid rgba(255, 255, 255, 0.3);
      }

      .time-settings {
        position: absolute;
        top: 50px;
        left: 10px;
        background-color: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 15px;
        border-radius: 8px;
        z-index: 20;
        display: none;
        border: 2px solid rgba(255, 255, 255, 0.3);
        min-width: 200px;
      }

      .time-settings.visible {
        display: block;
      }

      .time-settings label {
        display: block;
        margin-bottom: 10px;
        font-size: 14px;
      }

      .time-settings input {
        width: 60px;
        padding: 4px;
        margin-left: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }

      .time-settings button {
        background-color: #4caf50;
        color: white;
        border: none;
        padding: 6px 12px;
        margin: 5px 5px 0 0;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      }

      .time-settings button:hover {
        background-color: #45a049;
      }

      .time-settings button:last-child {
        background-color: #f44336;
      }

      .time-settings button:last-child:hover {
        background-color: #da190b;
      }

      /* Lottery video overlay styles for 9:16 aspect ratio */
      .right-panel {
        position: relative;
        overflow: visible;
        height: 500px;
        min-width: 200px;
      }

      .video-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -998;
        border-radius: 8px;
        transform: translateZ(-1px);
        will-change: transform;
      }

      .video-overlay video {
        width: 100%;
        height: 100%;
        object-fit: fill;
        border-radius: 4px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
        z-index: -999;
        transform: translateZ(-2px);
        will-change: transform;
      }

      /*.right-panel > *:not(.video-overlay) {
        position: relative;
        z-index: 2;
      }*/

      .background-video {
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -999;
        border-radius: 4px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
        transform: translateZ(-2px);
        will-change: transform;
      }

      .state {
        padding: 20px;
        /*background-color: rgba(0, 0, 0, 0.7);*/
        color: white;
        border-radius: 8px;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        background-color: rgba(0, 0, 0, 0.5);
        text-align: center;
        font-size: 20px;
        font-weight: bold;
        position: absolute;
        top: 80px;
        right: 20px;
        width: 310px;
        z-index: 100;
      }

      .slot-container {
        margin-top: 300px;
        justify-content: center;
        align-items: center;
        display: flex;
        gap: 10px;
      }

      .slot-num {
        height: 100px;
        font-size: 50px;
        text-align: center;
        flex: 1;
      }

      :root {
        --reel-width: 120px;
        --cell-height: 80px; /* 1„Å§„ÅÆÊï∞Â≠ó„Çª„É´„ÅÆÈ´ò„Åï */
        --visible-cells: 3; /* Ë¶ã„Åà„Çã„Çª„É´Êï∞Ôºà‰∏≠Â§ÆÔºã‰∏ä‰∏ã„ÅÆË¶ãÂàá„ÇåÔºâ */
      }

      .slot-wrap {
        display: flex;
        gap: 10px;
        justify-content: center;
        /*background-color: rgba(0, 0, 0, 0.6);*/
        padding: 15px;
        border-radius: 8px;
        position: absolute;
        top: 160px;
        right: 20px;
        width: 310px;
        z-index: 100;
      }

      .reel {
        width: var(--reel-width);
        height: calc(
          var(--cell-height) * 1
        ); /* Ë¶ã„Åõ„Åü„ÅÑ‰∏≠Â§Æ„ÅÆÈ´ò„ÅïÔºà‰∏≠Â§Æ„Çª„É´1„Å§ÂàÜÔºâ */
        position: relative;
        overflow: hidden;
        border-radius: 12px;
        background: linear-gradient(
          180deg,
          rgba(2, 2, 2, 0.5),
          rgba(16, 16, 18, 0.5)
        );
        box-shadow:
          0 6px 18px rgba(0, 0, 0, 0.7),
          inset 0 2px 0 rgba(255, 255, 255, 0.02);
        display: flex;
        align-items: center;
        justify-content: center;
      }

      /* ‰∏≠Â§Æ„ÅÆÊï∞Â≠ó„ÇíÂ§ß„Åç„ÅèË¶ã„Åõ„Çã„Åü„ÇÅ„ÄÅÂÜÖÂÅ¥„Å´‰ΩôÁôΩ„ÇíÊåÅ„Åü„Åõ„Åü„Ç™„Éº„Éê„Éº„Éï„É≠„ÉºÈ†òÂüü„ÇíÁî®ÊÑè */
      .reel-viewport {
        position: relative;
        width: 100%;
        height: calc(var(--cell-height) * var(--visible-cells));
        top: calc(var(--cell-height) * -1); /* ‰∏≠Â§Æ„Çª„É´„ÇíÂèØË¶ñÈ†òÂüü„ÅÆ‰∏≠Â§Æ„Å´ */
        overflow: hidden;
      }

      .reel-list {
        /* „É™„Éº„É´„ÅÆË¶ÅÁ¥†‰∏ÄË¶ß */
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
      }

      .cell {
        width: 100%;
        height: var(--cell-height);
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: hidden;
      }

      .cell img {
        width: 90%;
        height: 90%;
        object-fit: contain;
        image-rendering: -webkit-optimize-contrast;
        image-rendering: crisp-edges;
      }

      /* „Éï„Çß„Éº„Éâ„Ç®„Éï„Çß„ÇØ„Éà„Åß‰∏ä‰∏ã„Çí„Åº„Åã„Åô */
      .reel:before,
      .reel:after {
        content: "";
        position: absolute;
        left: 0;
        right: 0;
        height: calc(var(--cell-height) * 0.4);
        pointer-events: none;
        z-index: 2;
      }
      .reel:before {
        top: 0;
        background: linear-gradient(
          to bottom,
          rgba(17, 17, 17, 0.9) 0%,
          transparent 100%
        );
      }
      .reel:after {
        bottom: 0;
        background: linear-gradient(
          to top,
          rgba(17, 17, 17, 0.9) 0%,
          transparent 100%
        );
      }

      /* ‰∏≠Â§Æ„Éï„É¨„Éº„É†„ÅÆÂº∑Ë™ø */
      .center-frame {
        position: absolute;
        top: 50%;
        left: 50%;
        width: calc(100% - 8px);
        height: calc(var(--cell-height) - 8px);
        transform: translate(-50%, -50%);
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-radius: 6px;
        pointer-events: none;
        z-index: 3;
      }

      /* Configuration Modal Styles */
      .config-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        z-index: 1000;
      }

      .config-modal.visible {
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .config-content {
        background-color: #222;
        color: white;
        padding: 30px;
        border-radius: 12px;
        max-width: 90vw;
        max-height: 90vh;
        overflow-y: auto;
        position: relative;
        border: 2px solid #444;
      }

      .config-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 25px;
        border-bottom: 2px solid #444;
        padding-bottom: 15px;
      }

      .config-header h2 {
        margin: 0;
        color: #eee;
        font-size: 24px;
      }

      .config-close {
        background: #e74c3c;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
      }

      .config-close:hover {
        background: #c0392b;
      }

      .config-main {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 30px;
      }

      .config-section {
        background-color: #2a2a2a;
        padding: 20px;
        border-radius: 8px;
        border: 1px solid #444;
      }

      .config-section h3 {
        margin: 0 0 15px 0;
        color: #eee;
        font-size: 18px;
        border-bottom: 1px solid #444;
        padding-bottom: 10px;
      }

      .nail-canvas-container {
        position: relative;
        border: 2px solid #444;
        background-color: #2a2a2a;
        border-radius: 8px;
        overflow: hidden;
      }

      .nail-canvas {
        cursor: crosshair;
      }

      .nail-controls {
        margin-top: 15px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .nail-controls button {
        background: #3498db;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
      }

      .nail-controls button:hover {
        background: #2980b9;
      }

      .nail-controls button.danger {
        background: #e74c3c;
      }

      .nail-controls button.danger:hover {
        background: #c0392b;
      }

      .config-form {
        display: grid;
        gap: 15px;
      }

      .config-group {
        display: grid;
        gap: 10px;
      }

      .config-group label {
        font-size: 14px;
        font-weight: bold;
        color: #ccc;
      }

      .config-group input,
      .config-group textarea {
        background: #333;
        border: 1px solid #555;
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 14px;
      }

      .config-group input:focus,
      .config-group textarea:focus {
        outline: none;
        border-color: #3498db;
      }

      .config-group textarea {
        min-height: 120px;
        font-family: monospace;
        resize: vertical;
      }

      .data-controls {
        margin-top: 15px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .data-controls button {
        background: #27ae60;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
      }

      .data-controls button:hover {
        background: #229954;
      }

      .data-controls button.load {
        background: #f39c12;
      }

      .data-controls button.load:hover {
        background: #e67e22;
      }

      .config-footer {
        margin-top: 30px;
        text-align: center;
        border-top: 2px solid #444;
        padding-top: 20px;
      }

      .apply-config {
        background: #27ae60;
        color: white;
        border: none;
        padding: 12px 30px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
      }

      .apply-config:hover {
        background: #229954;
      }

      .config-instructions {
        background: #34495e;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        font-size: 14px;
        line-height: 1.5;
      }

      .config-instructions strong {
        color: #3498db;
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <!-- „Éó„É¨„Ç§„É§„Éº1 -->
      <div class="game-unit">
        <div class="canvas-container">
          <canvas id="canvas1"></canvas>
        </div>
        <div class="right-panel" id="right-panel1">
          <div class="timer-display" id="timer-display1">5:00</div>
          <div class="time-settings" id="time-settings1">
            <label
              >Timer (minutes):
              <input type="number" id="timer-input1" value="5" min="1" max="60"
            /></label>
            <button onclick="applyTimeSettings(1)">Apply</button>
            <button onclick="toggleTimeSettings(1)">Close</button>
          </div>
          <video
            class="background-video"
            id="video1"
            autoplay
            muted
            loop
            playsinline
          >
            <source
              src="images/background/background-normal.mp4"
              id="source1"
            />
          </video>
        </div>

        <div class="state" id="state1">Uninitialized</div>

        <div class="slot-wrap" id="slot1">
          <!-- 3„Å§„ÅÆ„É™„Éº„É´„ÇíÁî®ÊÑè -->
          <div class="reel" data-index="0">
            <div class="reel-viewport">
              <div class="reel-list"></div>
            </div>
            <div class="center-frame"></div>
          </div>

          <div class="reel" data-index="1">
            <div class="reel-viewport">
              <div class="reel-list"></div>
            </div>
            <div class="center-frame"></div>
          </div>

          <div class="reel" data-index="2">
            <div class="reel-viewport">
              <div class="reel-list"></div>
            </div>
            <div class="center-frame"></div>
          </div>
        </div>
      </div>

      <!-- „Éó„É¨„Ç§„É§„Éº2 -->
      <div class="game-unit">
        <div class="canvas-container">
          <canvas id="canvas2"></canvas>
        </div>
        <div class="right-panel" id="right-panel2">
          <div class="timer-display" id="timer-display2">5:00</div>
          <div class="time-settings" id="time-settings2">
            <label
              >Timer (minutes):
              <input type="number" id="timer-input2" value="5" min="1" max="60"
            /></label>
            <button onclick="applyTimeSettings(2)">Apply</button>
            <button onclick="toggleTimeSettings(2)">Close</button>
          </div>
          <video
            class="background-video"
            id="video2"
            autoplay
            muted
            loop
            playsinline
          >
            <source
              src="images/background/background-normal.mp4"
              id="source2"
            />
          </video>
        </div>

        <div class="state" id="state2">Uninitialized</div>

        <div class="slot-wrap" id="slot2">
          <!-- 3„Å§„ÅÆ„É™„Éº„É´„ÇíÁî®ÊÑè -->
          <div class="reel" data-index="0">
            <div class="reel-viewport">
              <div class="reel-list"></div>
            </div>
            <div class="center-frame"></div>
          </div>

          <div class="reel" data-index="1">
            <div class="reel-viewport">
              <div class="reel-list"></div>
            </div>
            <div class="center-frame"></div>
          </div>

          <div class="reel" data-index="2">
            <div class="reel-viewport">
              <div class="reel-list"></div>
            </div>
            <div class="center-frame"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Configuration Modal for Player 1 -->
    <div id="config-modal-1" class="config-modal">
      <div class="config-content">
        <div class="config-header">
          <h2>Player 1 Configuration</h2>
          <button class="config-close" id="config-close-1">Close</button>
        </div>

        <div class="config-instructions">
          <strong>Instructions:</strong> Click on the nail canvas to add/remove
          nails. Edit configuration values below. Changes will be applied when
          you close this modal.
        </div>

        <div class="config-main">
          <!-- Nail Editor Section -->
          <div class="config-section">
            <h3>Nail Editor</h3>
            <div class="nail-canvas-container">
              <canvas
                id="nail-canvas-1"
                class="nail-canvas"
                width="200"
                height="400"
              ></canvas>
            </div>
            <div class="nail-controls">
              <button id="clear-nails-1">Clear All</button>
              <button id="random-nails-1">Random Nails</button>
              <button class="danger" id="remove-last-nail-1">
                Remove Last
              </button>
            </div>

            <div class="config-group">
              <label>Nail Data (JSON format):</label>
              <textarea
                id="nail-data-1"
                placeholder='[{"x": 50, "y": 100}, {"x": 150, "y": 200}]'
              ></textarea>
              <div class="data-controls">
                <button id="export-nail-data-1">Export Data</button>
                <button class="load" id="import-nail-data-1">
                  Import Data
                </button>
              </div>
            </div>
          </div>

          <!-- Config Editor Section -->
          <div class="config-section">
            <h3>Game Configuration</h3>
            <div class="config-form">
              <div class="config-group">
                <label>Initial Balls:</label>
                <input
                  type="number"
                  id="config-init-balls-1"
                  min="1"
                  max="10000"
                  value="1000"
                />
              </div>
              <div class="config-group">
                <label>Incremental Balls:</label>
                <input
                  type="number"
                  id="config-incremental-balls-1"
                  min="1"
                  max="1000"
                  value="15"
                />
              </div>
              <div class="config-group">
                <label>Incremental Rush:</label>
                <input
                  type="number"
                  id="config-incremental-rush-1"
                  min="1"
                  max="1000"
                  value="300"
                />
              </div>

              <div class="config-group">
                <label>Normal Win Probability:</label>
                <input
                  type="number"
                  id="config-normal-win-1"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.16"
                />
              </div>
              <div class="config-group">
                <label>Normal Fake Win Probability:</label>
                <input
                  type="number"
                  id="config-normal-fake-win-1"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.3"
                />
              </div>
              <div class="config-group">
                <label>Normal Fake Lose Probability:</label>
                <input
                  type="number"
                  id="config-normal-fake-lose-1"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.15"
                />
              </div>

              <div class="config-group">
                <label>Into Rush Win Probability:</label>
                <input
                  type="number"
                  id="config-into-rush-win-1"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.8"
                />
              </div>
              <div class="config-group">
                <label>Into Rush Fake Win Probability:</label>
                <input
                  type="number"
                  id="config-into-rush-fake-win-1"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.1"
                />
              </div>
              <div class="config-group">
                <label>Into Rush Fake Lose Probability:</label>
                <input
                  type="number"
                  id="config-into-rush-fake-lose-1"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.1"
                />
              </div>

              <div class="config-group">
                <label>Rush Win Probability:</label>
                <input
                  type="number"
                  id="config-rush-win-1"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.48"
                />
              </div>
              <div class="config-group">
                <label>Rush Fake Win Probability:</label>
                <input
                  type="number"
                  id="config-rush-fake-win-1"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.2"
                />
              </div>
              <div class="config-group">
                <label>Rush Fake Lose Probability:</label>
                <input
                  type="number"
                  id="config-rush-fake-lose-1"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.05"
                />
              </div>

              <div class="config-group">
                <label>Rush Continue Win Probability:</label>
                <input
                  type="number"
                  id="config-rush-continue-win-1"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.5"
                />
              </div>
              <div class="config-group">
                <label>Rush Continue Fake Win Probability:</label>
                <input
                  type="number"
                  id="config-rush-continue-fake-win-1"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.25"
                />
              </div>
              <div class="config-group">
                <label>Rush Continue Fake Lose Probability:</label>
                <input
                  type="number"
                  id="config-rush-continue-fake-lose-1"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.1"
                />
              </div>
            </div>
          </div>
        </div>

        <div class="config-footer">
          <button class="apply-config" id="apply-config-1">
            Apply Configuration
          </button>
        </div>
      </div>
    </div>

    <!-- Configuration Modal for Player 2 -->
    <div id="config-modal-2" class="config-modal">
      <div class="config-content">
        <div class="config-header">
          <h2>Player 2 Configuration</h2>
          <button class="config-close" id="config-close-2">Close</button>
        </div>

        <div class="config-instructions">
          <strong>Instructions:</strong> Click on the nail canvas to add/remove
          nails. Edit configuration values below. Changes will be applied when
          you close this modal.
        </div>

        <div class="config-main">
          <!-- Nail Editor Section -->
          <div class="config-section">
            <h3>Nail Editor</h3>
            <div class="nail-canvas-container">
              <canvas
                id="nail-canvas-2"
                class="nail-canvas"
                width="200"
                height="400"
              ></canvas>
            </div>
            <div class="nail-controls">
              <button id="clear-nails-2">Clear All</button>
              <button id="random-nails-2">Random Nails</button>
              <button class="danger" id="remove-last-nail-2">
                Remove Last
              </button>
            </div>

            <div class="config-group">
              <label>Nail Data (JSON format):</label>
              <textarea
                id="nail-data-2"
                placeholder='[{"x": 50, "y": 100}, {"x": 150, "y": 200}]'
              ></textarea>
              <div class="data-controls">
                <button id="export-nail-data-2">Export Data</button>
                <button class="load" id="import-nail-data-2">
                  Import Data
                </button>
              </div>
            </div>
          </div>

          <!-- Config Editor Section -->
          <div class="config-section">
            <h3>Game Configuration</h3>
            <div class="config-form">
              <div class="config-group">
                <label>Initial Balls:</label>
                <input
                  type="number"
                  id="config-init-balls-2"
                  min="1"
                  max="10000"
                  value="1000"
                />
              </div>
              <div class="config-group">
                <label>Incremental Balls:</label>
                <input
                  type="number"
                  id="config-incremental-balls-2"
                  min="1"
                  max="1000"
                  value="15"
                />
              </div>
              <div class="config-group">
                <label>Incremental Rush:</label>
                <input
                  type="number"
                  id="config-incremental-rush-2"
                  min="1"
                  max="1000"
                  value="300"
                />
              </div>

              <div class="config-group">
                <label>Normal Win Probability:</label>
                <input
                  type="number"
                  id="config-normal-win-2"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.16"
                />
              </div>
              <div class="config-group">
                <label>Normal Fake Win Probability:</label>
                <input
                  type="number"
                  id="config-normal-fake-win-2"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.3"
                />
              </div>
              <div class="config-group">
                <label>Normal Fake Lose Probability:</label>
                <input
                  type="number"
                  id="config-normal-fake-lose-2"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.15"
                />
              </div>

              <div class="config-group">
                <label>Into Rush Win Probability:</label>
                <input
                  type="number"
                  id="config-into-rush-win-2"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.8"
                />
              </div>
              <div class="config-group">
                <label>Into Rush Fake Win Probability:</label>
                <input
                  type="number"
                  id="config-into-rush-fake-win-2"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.1"
                />
              </div>
              <div class="config-group">
                <label>Into Rush Fake Lose Probability:</label>
                <input
                  type="number"
                  id="config-into-rush-fake-lose-2"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.1"
                />
              </div>

              <div class="config-group">
                <label>Rush Win Probability:</label>
                <input
                  type="number"
                  id="config-rush-win-2"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.48"
                />
              </div>
              <div class="config-group">
                <label>Rush Fake Win Probability:</label>
                <input
                  type="number"
                  id="config-rush-fake-win-2"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.2"
                />
              </div>
              <div class="config-group">
                <label>Rush Fake Lose Probability:</label>
                <input
                  type="number"
                  id="config-rush-fake-lose-2"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.05"
                />
              </div>

              <div class="config-group">
                <label>Rush Continue Win Probability:</label>
                <input
                  type="number"
                  id="config-rush-continue-win-2"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.8"
                />
              </div>
              <div class="config-group">
                <label>Rush Continue Fake Win Probability:</label>
                <input
                  type="number"
                  id="config-rush-continue-fake-win-2"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.25"
                />
              </div>
              <div class="config-group">
                <label>Rush Continue Fake Lose Probability:</label>
                <input
                  type="number"
                  id="config-rush-continue-fake-lose-2"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.1"
                />
              </div>
            </div>
          </div>
        </div>

        <div class="config-footer">
          <button class="apply-config" id="apply-config-2">
            Apply Configuration
          </button>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>

    <script type="module">
      // „Ç∞„É≠„Éº„Éê„É´„Éì„Éá„Ç™„É™„Çπ„Éà„Ç≠„É£„ÉÉ„Ç∑„É•
      let globalVideoList = null;

      // video-list.json„Çí‰∫ãÂâç„Å´Ë™≠„ÅøËæº„ÇÄÈñ¢Êï∞
      async function preloadVideoList() {
        try {
          const response = await fetch("video-list.json");
          if (response.ok) {
            globalVideoList = await response.json();
            console.log(
              "üìö video-list.json preloaded successfully:",
              globalVideoList,
            );
          } else {
            console.error(
              `‚ùå Failed to preload video-list.json: ${response.status}`,
            );
            globalVideoList = null;
          }
        } catch (error) {
          console.error("üí• Error preloading video-list.json:", error);
          globalVideoList = null;
        }
      }

      const REPEAT = 30; // Êï∞Â≠óÂàó„Çí‰ΩïÂõûÁπ∞„ÇäËøî„Åô„Åã
      const numbers = [1, 2, 3, 4, 5, 6, 7, 8]; // [1,2,3,4,5,6,7,8]
      const reels1 = Array.from(document.querySelectorAll("#slot1 .reel"));
      const reels2 = Array.from(document.querySelectorAll("#slot2 .reel"));
      const cellH =
        parseInt(
          getComputedStyle(document.documentElement).getPropertyValue(
            "--cell-height",
          ),
        ) || 64;

      const backgroundVideoPaths = {
        normal: "images/background/background-normal.mp4",
        rush: "images/background/background-rush.mp4",
      };

      let isProcessingFinishTask1 = false;
      let isProcessingFinishTask2 = false;

      function setIsProcessingFinishTask(playerId, isFinish) {
        console.log(
          `Player ${playerId} isProcessingFinishTask set to ${isFinish}`,
        );
        if (playerId === 1) {
          isProcessingFinishTask1 = isFinish;
        } else if (playerId === 2) {
          isProcessingFinishTask2 = isFinish;
        }
      }

      // „Çø„Çπ„ÇØ„Ç≠„É•„Éº„Ç∑„Çπ„ÉÜ„É†
      class OutputTaskQueue {
        constructor(playerId, updateStateFunction) {
          this.playerId = playerId;
          this.queue = [];
          this.isProcessing = false;
          this.updateState = updateStateFunction;
        }

        // „Çø„Çπ„ÇØ„Çí„Ç≠„É•„Éº„Å´ËøΩÂä†
        addTask(taskType, taskData) {
          console.log(
            `Player ${this.playerId} task queued: ${taskType}`,
            taskData,
          );
          this.queue.push({
            type: taskType,
            data: taskData,
            timestamp: Date.now(),
          });
          this.processNext();
        }

        // Ê¨°„ÅÆ„Çø„Çπ„ÇØ„ÇíÂá¶ÁêÜ
        async processNext() {
          if (this.isProcessing || this.queue.length === 0) {
            return;
          }

          console.log(`Player ${this.playerId} queue: ${this.queue}`);

          this.isProcessing = true;
          const task = this.queue.shift();
          console.log(`Player ${this.playerId} processing task: ${task.type}`);

          try {
            await this.executeTask(task);
          } catch (error) {
            console.error(`Player ${this.playerId} task error:`, error);
          }

          this.isProcessing = false;

          // Ê¨°„ÅÆ„Çø„Çπ„ÇØ„Åå„ÅÇ„Çå„Å∞Á∂öË°å
          if (this.queue.length > 0) {
            setTimeout(() => this.processNext(), 100);
          }
        }

        // „Çø„Çπ„ÇØ„ÇíÂÆüË°å
        async executeTask(task) {
          const { type, data } = task;

          switch (type) {
            case "default":
              this.executeDefaultTask(data);
              break;
            case "finishGame":
              this.executeFinishGameTask(data);
              break;
            case "lotteryNormal":
              await this.executeNormalLotteryTask(data);
              break;
            case "lotteryIntoRush":
              await this.executeIntoRushLotteryTask(data);
              break;
            case "lotteryRush":
              await this.executeRushLotteryTask(data);
              break;
            case "lotteryRushContinue":
              await this.executeRushContinueTask(data);
              break;
            default:
              console.warn(`Unknown task type: ${type}`);
          }
        }

        // default„Çø„Çπ„ÇØ„ÅÆÂÆüË°å
        executeDefaultTask(transition) {
          console.log(`P${this.playerId} Transition:`, transition);
          if (transition.after) {
            if (transition.before) {
              if (
                transition.before.type === "Normal" &&
                transition.after.type === "Rush"
              ) {
                this.changeBackgroundVideo(backgroundVideoPaths.rush);
              } else if (
                transition.before.type === "Rush" &&
                transition.after.type === "Normal"
              ) {
                this.changeBackgroundVideo(backgroundVideoPaths.normal);
              }
            }
            this.updateState(this.playerId, transition.after);
          }
        }

        // finishGame„Çø„Çπ„ÇØ„ÅÆÂÆüË°å
        executeFinishGameTask(gameState) {
          console.log(`P${this.playerId} Game Finished:`, gameState);
          this.updateState(this.playerId, gameState, "ÁµÇ‰∫Ü„Åó„Åæ„Åó„Åü");
          this.changeBackgroundVideo(backgroundVideoPaths.normal);
        }

        async executeNormalLotteryTask(data) {
          await this.executeLotteryTask(data);
        }

        async executeIntoRushLotteryTask(data) {
          await this.executeLotteryTask(data);
        }

        async executeRushLotteryTask(data) {
          await this.executeLotteryTask(data);
        }

        async executeRushContinueTask(data) {
          await this.executeLotteryTask(data);
        }

        // ÊäΩÈÅ∏„Çø„Çπ„ÇØ„ÅÆÂÆüË°åÔºàÊò†ÂÉèÂÜçÁîü„Å®„Çπ„É≠„ÉÉ„ÉàÂõûËª¢Ôºâ
        async executeLotteryTask(data) {
          const { lotteryResult, slotResult, taskType } = data;
          console.log(
            `P${this.playerId} ${taskType}:`,
            lotteryResult,
            slotResult,
          );

          const slot = slotResult[1] || slotResult[0];

          // ÊäΩÈÅ∏ÁµêÊûú„Å´Âü∫„Å•„ÅÑ„Å¶Êò†ÂÉè„Éï„Ç©„É´„ÉÄ„ÇíÊ±∫ÂÆö
          let videoFolder = "";
          console.log(
            `P${this.playerId} Lottery result structure:`,
            lotteryResult,
          );

          // Handle different possible lottery result formats
          if (lotteryResult.Win !== undefined) {
            // Rust-style enum format: { Win: "Default" } or { Win: "FakeWin" }
            videoFolder =
              lotteryResult.Win === "Default" ? "images/win" : "images/fakewin";
          } else if (lotteryResult.Lose !== undefined) {
            // Rust-style enum format: { Lose: "Default" } or { Lose: "FakeLose" }
            videoFolder =
              lotteryResult.Lose === "FakeLose" ? "images/lose" : "";
          } else if (lotteryResult.type === "Win") {
            // JavaScript-style format: { type: "Win", winType: "Default" }
            videoFolder =
              lotteryResult.winType === "Default"
                ? "images/win"
                : "images/fakewin";
          } else if (lotteryResult.type === "Lose") {
            // JavaScript-style format: { type: "Lose", loseType: "Default" }
            videoFolder =
              lotteryResult.loseType === "FakeLose" ? "images/lose" : "";
          }

          console.log(
            `P${this.playerId} Selected video folder: ${videoFolder}`,
          );

          // If no video folder specified (regular lose), just spin slots
          if (!videoFolder) {
            console.log(
              `P${this.playerId} No video needed for regular lose, spinning slots only`,
            );
            await this.fallbackToDefaultSlot(slot);
            return;
          }

          try {
            // „Éï„Ç©„É´„ÉÄ„Åã„ÇâÊò†ÂÉè„Éï„Ç°„Ç§„É´„ÇíÂèñÂæó„Åó„Å¶„É©„É≥„ÉÄ„É†ÈÅ∏Êäû
            const videoFile = await this.selectRandomVideo(videoFolder);
            if (!videoFile) {
              console.warn(
                `No video found in ${videoFolder}, using default slot animation`,
              );
              await this.fallbackToDefaultSlot(slot);
              return;
            }

            console.log(`P${this.playerId} Selected video: ${videoFile}`);

            try {
              // Êò†ÂÉè„ÇíËÉåÊôØ„ÅßÂÜçÁîü„Åó„ÄÅÈï∑„Åï„ÇíÂèñÂæó
              const videoDuration = await this.playBackgroundVideo(
                videoFile,
                defaultDuration + 2 * defaultLag,
              );
              console.log(
                `P${this.playerId} Playing ${videoFile} for ${videoDuration}ms`,
              );

              // „Çπ„É≠„ÉÉ„Éà„Çí„Åù„ÅÆÈï∑„Åï„Å†„ÅëÂõûËª¢„Åï„Åõ„Çã
              await this.spinSlotForVideoDuration(slot, videoDuration);
            } catch (videoError) {
              console.warn(
                `P${this.playerId} Video playback failed:`,
                videoError.message,
              );
              console.log(
                `P${this.playerId} Falling back to default slot animation`,
              );
              await this.fallbackToDefaultSlot(slot);
            }
          } catch (error) {
            console.error(
              `P${this.playerId} Error in lottery task execution:`,
              error,
            );
            await this.fallbackToDefaultSlot(slot);
          }

          console.log(`Player ${this.playerId} lottery task completed`);
        }

        // „Éï„Ç©„É´„ÉÄ„Åã„Çâ„É©„É≥„ÉÄ„É†„Å´Êò†ÂÉè„Éï„Ç°„Ç§„É´„ÇíÈÅ∏ÊäûÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ‰ªò„ÅçÔºâ
        async selectRandomVideo(folderPath) {
          console.log(
            `üéØ Loading videos from cached JSON for folder: ${folderPath}`,
          );

          const folderName = folderPath.split("/").pop(); // Extract folder name (win, fakewin, lose, etc.)

          // „Ç∞„É≠„Éº„Éê„É´„Ç≠„É£„ÉÉ„Ç∑„É•„Åã„ÇâÂèñÂæó„ÇíË©¶Ë°å
          let fallbackFiles = {};
          if (globalVideoList) {
            const videos = globalVideoList[folderName] || [];

            console.log(`üé¨ Found ${videos.length} videos:`, videos);
            if (videos.length > 0) {
              const randomIndex = Math.floor(Math.random() * videos.length);
              const selectedVideo = `${folderPath}/${videos[randomIndex]}`;
              console.log(`‚úÖ Selected video: ${selectedVideo}`);
              return selectedVideo;
            }

            // Update fallbackFiles from cached video-list.json
            fallbackFiles = {
              "images/win": globalVideoList["win"] || [],
              "images/fakewin": globalVideoList["fakewin"] || [],
              "images/lose": globalVideoList["lose"] || [],
            };
          } else {
            console.warn(
              `‚ö†Ô∏è Global video list not available, using static fallback`,
            );
            // Static fallback files if global video list is not available
            fallbackFiles = {
              "images/win": ["once-input-win.mov"],
              "images/fakewin": ["once-input-fakewin.mov"],
              "images/lose": ["once-input-lose.mov"],
            };
          }

          // Use fallback files if API fails or returns empty
          const fallback = fallbackFiles[folderPath];
          if (fallback && fallback.length > 0) {
            const randomIndex = Math.floor(Math.random() * fallback.length);
            const fallbackVideo = `${folderPath}/${fallback[randomIndex]}`;
            console.log(`üîÑ Using fallback video: ${fallbackVideo}`);
            return fallbackVideo;
          }

          console.error(`‚ùå No fallback available for folder: ${folderPath}`);
          return null;
        }

        async changeBackgroundVideo(videoPath) {
          const originalVideo = document.getElementById(
            `video${this.playerId}`,
          );
          const originalVideoSource = document.getElementById(
            `source${this.playerId}`,
          );
          if (!originalVideoSource) {
            console.error(
              `‚ùå Source element not found for player ${this.playerId}`,
            );
            return;
          }
          originalVideoSource.src = videoPath;
          await originalVideo.load();
        }

        // Êñ∞„Åó„ÅÑvideo„Çø„Ç∞„Çí‰ΩúÊàê„ÅóÊó¢Â≠ò„Çø„Ç∞„Å®ÂÖ•„ÇåÊõø„Åà„Å¶Êò†ÂÉè„ÇíÂÜçÁîü
        async playBackgroundVideo(videoPath, withSleep = 0) {
          return new Promise((resolve, reject) => {
            const rightPanel = document.getElementById(
              `right-panel${this.playerId}`,
            );
            const originalVideo = document.getElementById(
              `video${this.playerId}`,
            );

            if (!rightPanel || !originalVideo) {
              reject(
                new Error(
                  `Required elements not found for player ${this.playerId}`,
                ),
              );
              return;
            }

            // Êñ∞„Åó„ÅÑvideo„Çø„Ç∞„Çí‰ΩúÊàê
            const newVideo = document.createElement("video");
            const newSource = document.createElement("source");

            // Êñ∞„Åó„ÅÑvideo„Çø„Ç∞„ÅÆË®≠ÂÆö
            newVideo.id = `temp-video${this.playerId}`;
            newVideo.style.position = "absolute";
            newVideo.style.top = "0";
            newVideo.style.left = "0";
            newVideo.style.width = "100%";
            newVideo.style.height = "100%";
            newVideo.style.objectFit = "cover";
            newVideo.style.zIndex = "5";
            newVideo.style.borderRadius = "8px";
            newVideo.muted = false;
            newVideo.autoplay = false;
            newVideo.playsInline = true;
            newVideo.preload = "auto";

            newSource.src = videoPath;
            newVideo.appendChild(newSource);

            // Timeout for loading
            const loadTimeout = setTimeout(() => {
              console.warn(`Video loading timeout: ${videoPath}`);
              reject(new Error(`Video loading timeout: ${videoPath}`));
            }, 10000); // 10Áßí„Çø„Ç§„É†„Ç¢„Ç¶„Éà

            const onLoadedMetadata = () => {
              clearTimeout(loadTimeout);
              const duration = newVideo.duration * 1000; // „Éü„É™Áßí„Å´Â§âÊèõ
              console.log(
                `Video loaded successfully: ${videoPath}, duration: ${duration}ms`,
              );

              const playerId = this.playerId;
              const stateElement = document.getElementById(`state${playerId}`);
              const slotWrap = document.getElementById(`slot${playerId}`);

              // Êò†ÂÉè„ÅÆÊ∫ñÂÇôÂÆå‰∫Ü„ÇíÂæÖ„Å§
              const waitForCanPlay = () => {
                return new Promise((resolve) => {
                  if (newVideo.readyState >= 3) {
                    // HAVE_FUTURE_DATA‰ª•‰∏ä
                    resolve();
                  } else {
                    const onCanPlay = () => {
                      newVideo.removeEventListener("canplay", onCanPlay);
                      resolve();
                    };
                    newVideo.addEventListener("canplay", onCanPlay);
                  }
                });
              };

              // Êò†ÂÉè„ÅÆÊ∫ñÂÇô„ÇíÈñãÂßã
              waitForCanPlay()
                .then(() => {
                  console.log(`Video ready for playback: ${videoPath}`);

                  // „Çπ„É≠„ÉÉ„ÉàÈñãÂßã„ÅÆ„Çø„Ç§„Éü„É≥„Ç∞„ÅßÊò†ÂÉè„ÇíÂÖ•„ÇåÊõø„Åà„Å¶ÈñãÂßã
                  setTimeout(() => {
                    // Êò†ÂÉèÂÜçÁîüÊôÇ„Å´Êó¢Â≠ò„ÅÆvideo„Çø„Ç∞„Å®ÂÖ•„ÇåÊõø„Åà
                    originalVideo.style.display = "none";
                    rightPanel.appendChild(newVideo);

                    // „Çπ„ÉÜ„Éº„ÉàË¶ÅÁ¥†„ÇíÈùûË°®Á§∫„Å´
                    stateElement.style.display = "none";
                    slotWrap.style.transform =
                      "translate(50px, -170px) scale(0.8)";

                    // DOMÊìç‰Ωú„Å®„Éñ„É©„Ç¶„Ç∂„É¨„É≥„ÉÄ„É™„É≥„Ç∞„ÅÆÂÆå‰∫Ü„ÇíÂæÖ„Å£„Å¶„Åã„ÇâÂÜçÁîüÈñãÂßã
                    requestAnimationFrame(() => {
                      requestAnimationFrame(() => {
                        newVideo.currentTime = 0; // ÂÜçÁîü‰ΩçÁΩÆ„ÇíÁ¢∫ÂÆü„Å´„É™„Çª„ÉÉ„Éà
                        newVideo.play().catch((error) => {
                          console.warn(
                            `Failed to play video: ${error.message}`,
                          );
                        });
                      });
                    });
                  }, withSleep);
                })
                .catch((error) => {
                  console.warn(`Video preparation failed: ${error.message}`);
                  // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂá¶ÁêÜ
                  setTimeout(
                    () => {
                      originalVideo.style.display = "none";
                      rightPanel.appendChild(newVideo);
                      requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                          newVideo.play().catch((error) => {
                            console.warn(
                              `Fallback video play failed: ${error.message}`,
                            );
                          });
                        });
                      });
                    },
                    defaultDuration + 2 * defaultLag,
                  );
                });

              // Êò†ÂÉèÁµÇ‰∫ÜÂæå„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
              const onVideoEnded = () => {
                try {
                  // Êñ∞„Åó„ÅÑvideo„Çø„Ç∞„ÇíÂâäÈô§
                  if (newVideo.parentNode) {
                    newVideo.parentNode.removeChild(newVideo);
                  }

                  // ÂÖÉ„ÅÆvideo„Çø„Ç∞„ÇíË°®Á§∫„Å´Êàª„Åô
                  originalVideo.style.display = "";

                  console.log(
                    `Player ${this.playerId} video replaced back to original`,
                  );

                  // „Çπ„ÉÜ„Éº„ÉàË¶ÅÁ¥†„ÇíË°®Á§∫„Å´Êàª„Åô
                  stateElement.style.display = "";
                  slotWrap.style.transform = "";
                } catch (error) {
                  console.warn(`Failed to restore video elements:`, error);
                }

                // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíÂâäÈô§
                newVideo.removeEventListener("ended", onVideoEnded);
                newVideo.removeEventListener(
                  "loadedmetadata",
                  onLoadedMetadata,
                );
                newVideo.removeEventListener("error", onVideoError);
              };

              newVideo.addEventListener("ended", onVideoEnded);

              // Default duration fallback if video duration is invalid
              resolve(duration > 0 ? duration : 3000); // ÊúÄ‰Ωé3Áßí
            };

            const onVideoError = (error) => {
              clearTimeout(loadTimeout);
              console.error(`Video error for ${videoPath}:`, error);

              // „Ç®„É©„ÉºÊôÇ„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
              try {
                if (newVideo.parentNode) {
                  newVideo.parentNode.removeChild(newVideo);
                }
                originalVideo.style.display = "";
              } catch (cleanupError) {
                console.warn(
                  `Failed to cleanup after video error:`,
                  cleanupError,
                );
              }

              // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíÂâäÈô§
              newVideo.removeEventListener("loadedmetadata", onLoadedMetadata);
              newVideo.removeEventListener("error", onVideoError);

              reject(new Error(`Failed to load video: ${videoPath}`));
            };

            newVideo.addEventListener("loadedmetadata", onLoadedMetadata);
            newVideo.addEventListener("error", onVideoError);

            console.log(
              `Player ${this.playerId} loading new video: ${videoPath}`,
            );
          });
        }

        // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºö„Éá„Éï„Ç©„É´„Éà„Çπ„É≠„ÉÉ„Éà„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
        async fallbackToDefaultSlot(slot) {
          console.log(`P${this.playerId} Executing fallback slot animation`);
          if (this.playerId === 1) {
            spinTo1(slot);
          } else {
            spinTo2(slot);
          }
          await this.waitForSlotAnimation();
        }

        // ÊåáÂÆöÊôÇÈñì„Å†„Åë„Çπ„É≠„ÉÉ„Éà„ÇíÂõûËª¢
        async spinSlotForVideoDuration(slot, duration) {
          duration += defaultDuration + 2 * defaultLag - 1000;

          // „Çπ„É≠„ÉÉ„ÉàÂõûËª¢ÈñãÂßã
          console.log(`P${this.playerId} Starting slot spin for ${duration}ms`);
          if (this.playerId === 1) {
            spinTo1(slot, [defaultDuration, duration, defaultDuration]);
          } else {
            spinTo2(slot, [defaultDuration, duration, defaultDuration]);
          }

          // ÊåáÂÆöÊôÇÈñìÂæÖÊ©ü
          await new Promise((resolve) => setTimeout(resolve, duration));

          // „Çπ„É≠„ÉÉ„ÉàÂõûËª¢ÂÆå‰∫Ü„ÇíÂæÖ„Å§
          console.log(
            `P${this.playerId} Waiting for slot animation to complete`,
          );
          await this.waitForSlotAnimation();
        }

        // „Çπ„É≠„ÉÉ„Éà„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÂÆå‰∫Ü„ÇíÂæÖ„Å§
        waitForSlotAnimation() {
          return new Promise((resolve) => {
            const checkInterval = setInterval(() => {
              const status = getSlotStatus(this.playerId);
              if (!status.isSpinning && status.queueLength === 0) {
                clearInterval(checkInterval);

                // „Ç≤„Éº„É†ÂÅ¥„ÅÆ„Çπ„É≠„ÉÉ„ÉàÂõûËª¢Áä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
                if (this.playerId === 1 && window.game1) {
                  window.game1.setSlotSpinning(false);
                  console.log(
                    `Player ${this.playerId} slot spinning state reset`,
                  );
                  // Áä∂ÊÖãË°®Á§∫„ÇíÊõ¥Êñ∞
                  // this.updateState(this.playerId, window.game1.getState());
                } else if (this.playerId === 2 && window.game2) {
                  window.game2.setSlotSpinning(false);
                  console.log(
                    `Player ${this.playerId} slot spinning state reset`,
                  );
                  // Áä∂ÊÖãË°®Á§∫„ÇíÊõ¥Êñ∞
                  // this.updateState(this.playerId, window.game2.getState());
                }

                // Â∞ë„Åó‰ΩôË£ï„ÇíÊåÅ„Å£„Å¶ÂÆå‰∫Ü„ÇíÂæÖ„Å§
                setTimeout(resolve, 300);
              }
            }, 100);

            // const timeOutTime = 10000;

            // // ÊúÄÂ§ß timeOutTime ms „Åß„Çø„Ç§„É†„Ç¢„Ç¶„Éà
            // setTimeout(() => {
            //   clearInterval(checkInterval);
            //   console.warn(`Player ${this.playerId} slot animation timeout`);

            //   // „Çø„Ç§„É†„Ç¢„Ç¶„ÉàÊôÇ„ÇÇ„Çπ„É≠„ÉÉ„ÉàÂõûËª¢Áä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
            //   if (this.playerId === 1 && window.game1) {
            //     window.game1.setSlotSpinning(false);
            //     console.log(
            //       `Player ${this.playerId} slot spinning state reset (timeout)`,
            //     );
            //     // Áä∂ÊÖãË°®Á§∫„ÇíÊõ¥Êñ∞
            //     this.updateState(this.playerId, window.game1.getState());
            //   } else if (this.playerId === 2 && window.game2) {
            //     window.game2.setSlotSpinning(false);
            //     console.log(
            //       `Player ${this.playerId} slot spinning state reset (timeout)`,
            //     );
            //     // Áä∂ÊÖãË°®Á§∫„ÇíÊõ¥Êñ∞
            //     this.updateState(this.playerId, window.game2.getState());
            //   }

            //   resolve();
            // }, timeOutTime);
          });
        }

        // „Ç≠„É•„Éº„ÅÆÁä∂ÊÖã„ÇíÂèñÂæó
        getStatus() {
          return {
            queueLength: this.queue.length,
            isProcessing: this.isProcessing,
            queue: [...this.queue],
          };
        }

        // „Ç≠„É•„Éº„Çí„ÇØ„É™„Ç¢
        clear() {
          this.queue = [];
          this.isProcessing = false;
          console.log(`Player ${this.playerId} task queue cleared`);
        }
      }

      // „Éó„É¨„Ç§„É§„ÉºÂà•„ÅÆ„Çø„Çπ„ÇØ„Ç≠„É•„ÉºÔºàupdateStateÈñ¢Êï∞„ÅØmainÈñ¢Êï∞ÂÜÖ„ÅßÂÆöÁæ©„Åï„Çå„Çã„Åü„ÇÅ„ÄÅÂæå„ÅßË®≠ÂÆöÔºâ
      let taskQueue1;
      let taskQueue2;

      // Êéí‰ªñÂà∂Âæ°Áî®„ÅÆÂ§âÊï∞Ôºà„Çπ„É≠„ÉÉ„Éà„É¨„Éô„É´Ôºâ
      let isSpinning1 = false;
      let isSpinning2 = false;
      let spinQueue1 = [];
      let spinQueue2 = [];

      // „Çπ„É≠„ÉÉ„ÉàÁä∂ÊÖã„ÉÅ„Çß„ÉÉ„ÇØÈñ¢Êï∞
      function getSlotStatus(playerId) {
        if (playerId === 1) {
          return {
            isSpinning: isSpinning1,
            queueLength: spinQueue1.length,
            queue: [...spinQueue1],
          };
        } else if (playerId === 2) {
          return {
            isSpinning: isSpinning2,
            queueLength: spinQueue2.length,
            queue: [...spinQueue2],
          };
        }
        return null;
      }

      // Âº∑Âà∂ÁöÑ„Å´„Çπ„É≠„ÉÉ„ÉàÁä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà„Åô„ÇãÈñ¢Êï∞Ôºà„Éá„Éê„ÉÉ„Ç∞Áî®Ôºâ
      function forceResetSlotState(playerId) {
        if (playerId === 1) {
          isSpinning1 = false;
          spinQueue1 = [];
          if (taskQueue1) {
            taskQueue1.clear();
          }
          console.log(
            "„Éó„É¨„Ç§„É§„Éº1: „Çπ„É≠„ÉÉ„ÉàÁä∂ÊÖã„Å®„Çø„Çπ„ÇØ„Ç≠„É•„Éº„ÇíÂº∑Âà∂„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü",
          );
        } else if (playerId === 2) {
          isSpinning2 = false;
          spinQueue2 = [];
          if (taskQueue2) {
            taskQueue2.clear();
          }
          console.log(
            "„Éó„É¨„Ç§„É§„Éº2: „Çπ„É≠„ÉÉ„ÉàÁä∂ÊÖã„Å®„Çø„Çπ„ÇØ„Ç≠„É•„Éº„ÇíÂº∑Âà∂„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü",
          );
        } else if (playerId === "both") {
          isSpinning1 = false;
          isSpinning2 = false;
          spinQueue1 = [];
          spinQueue2 = [];
          if (taskQueue1) {
            taskQueue1.clear();
          }
          if (taskQueue2) {
            taskQueue2.clear();
          }
          console.log(
            "‰∏°„Éó„É¨„Ç§„É§„Éº: „Çπ„É≠„ÉÉ„ÉàÁä∂ÊÖã„Å®„Çø„Çπ„ÇØ„Ç≠„É•„Éº„ÇíÂº∑Âà∂„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü",
          );
        }
      }

      // ÂàùÊúüÂåñ: ÂêÑ„É™„Éº„É´„Å´Áπ∞„ÇäËøî„ÅóÊï∞Â≠ó„É™„Çπ„Éà„Çí‰ΩúÊàê
      function buildReelList(reelEl) {
        const list = reelEl.querySelector(".reel-list");
        list.innerHTML = "";

        // REPEATÂõûÂàÜ„ÅÆÊï∞Â≠ó„Çí‰ΩúÊàê
        for (let r = 0; r < REPEAT; r++) {
          for (const n of numbers) {
            const div = document.createElement("div");
            div.className = "cell";
            const img = document.createElement("img");
            img.src = `images/numbers/num${n}.png`;
            img.alt = n.toString();
            div.appendChild(img);
            list.appendChild(div);
          }
        }

        // „Åï„Çâ„Å´1Âë®ÂàÜËøΩÂä†„Åó„Å¶„Çπ„ÇØ„É≠„Éº„É´Á´Ø„Åß„ÅÆÁ©∫ÁôΩ„ÇíÈò≤„Åê
        for (const n of numbers) {
          const div = document.createElement("div");
          div.className = "cell";
          const img = document.createElement("img");
          img.src = `images/numbers/num${n}.png`;
          img.alt = n.toString();
          div.appendChild(img);
          list.appendChild(div);
        }

        // ÂàùÊúü‰ΩçÁΩÆ: ‰∏≠Â§Æ„Éñ„É≠„ÉÉ„ÇØ„ÅÆÊúÄÂàùÔºà1Ôºâ„ÅåË¶ã„Åà„Çã„Çà„ÅÜ„Å´Ë®≠ÂÆöÔºàË°®Á§∫‰ΩçÁΩÆ„Çí2„Å§‰∏ã„Å´Ë™øÊï¥Ôºâ
        const centerBlockStart = Math.floor(REPEAT / 2) * numbers.length;
        list.style.transform = `translateY(-${(centerBlockStart - 2) * cellH}px)`;
      }

      reels1.forEach(buildReelList);
      reels2.forEach(buildReelList);

      // ÊåáÂÆö„Åï„Çå„Åü3„Å§„ÅÆÊï∞Â≠ó„ÇíÂç≥Â∫ß„Å´Ë°®Á§∫
      function setDigits(digits, reelArray = reels1) {
        digits = normalizeDigits(digits);
        reelArray.forEach((reelEl, idx) => {
          const list = reelEl.querySelector(".reel-list");
          const targetNumber = digits[idx];

          // ‰∏≠Â§Æ„Éñ„É≠„ÉÉ„ÇØ„Åß„ÅÆÁõÆÊ®ô‰ΩçÁΩÆ„ÇíË®àÁÆóÔºàË°®Á§∫‰ΩçÁΩÆ„Çí2„Å§‰∏ã„Å´Ë™øÊï¥Ôºâ
          const centerBlockStart = Math.floor(REPEAT / 2) * numbers.length;
          const targetPositionInBlock = numbers.indexOf(targetNumber);
          const finalPosition = centerBlockStart + targetPositionInBlock - 2;
          const offset = finalPosition * cellH;

          // „Éà„É©„É≥„Ç∏„Ç∑„Éß„É≥„Å™„Åó„ÅßÂç≥Â∫ß„Å´ÁßªÂãï
          list.style.transition = "none";
          list.style.transform = `translateY(-${offset}px)`;

          // Ê¨°Âõû„ÅÆ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Áî®„Å´„Éà„É©„É≥„Ç∏„Ç∑„Éß„É≥„ÇíÂæ©Ê¥ª
          requestAnimationFrame(() => {
            list.style.transition = "transform 600ms cubic-bezier(.2,.8,.2,1)";
          });
        });
      }

      const defaultDuration = 800;
      const defaultLag = 300;

      // „Çπ„É≠„ÉÉ„ÉàÈ¢®ÂõûËª¢: ÂøÖ„Åö‰∏ä„Åã„Çâ‰∏ã„Å∏ÂõûËª¢„Åó„Å¶ÁõÆÊ®ôÊï∞Â≠ó„ÅßÂÅúÊ≠¢
      // spinDurations: „É™„Éº„É´„Åî„Å®„ÅÆÊôÇÈñìÊåáÂÆö
      //   - null: „Éá„Éï„Ç©„É´„Éà„ÅÆ„É©„É≥„ÉÄ„É†ÊôÇÈñì
      //   - Êï∞ÂÄ§: ÂÖ®„É™„Éº„É´ÂÖ±ÈÄö„ÅÆÂü∫Êú¨ÊôÇÈñìÔºàÂæåÊñπ‰∫íÊèõÔºâ
      //   - ÈÖçÂàó: [reel0_duration, reel1_duration, reel2_duration] ÂêÑ„É™„Éº„É´ÂÄãÂà•ÊôÇÈñì
      //   ‰æã: spinTo1([1,2,3], [1000, 1500, 2000]) // 1Ê°ÅÁõÆ1Áßí„ÄÅ2Ê°ÅÁõÆ1.5Áßí„ÄÅ3Ê°ÅÁõÆ2Áßí
      function spinTo(digits, reelArray = reels1, spinDurations = null) {
        // Êéí‰ªñÂà∂Âæ°: „Å©„Å°„Çâ„ÅÆ„É™„Éº„É´„Çª„ÉÉ„Éà„Åã„ÇíÂà§ÂÆö
        const isReel1 = reelArray === reels1;
        const isSpinning = isReel1 ? isSpinning1 : isSpinning2;
        const spinQueue = isReel1 ? spinQueue1 : spinQueue2;

        // ÁèæÂú®„Çπ„Éî„É≥‰∏≠„ÅÆÂ†¥Âêà„ÅØ„Ç≠„É•„Éº„Å´ËøΩÂä†„Åó„Å¶ÁµÇ‰∫Ü
        if (isSpinning) {
          console.log(
            `Player ${isReel1 ? 1 : 2} slot is spinning, adding to queue:`,
            digits,
          );
          spinQueue.push({ digits, spinDurations });
          return;
        }

        // „Çπ„Éî„É≥ÈñãÂßã„Éï„É©„Ç∞„Çí„Çª„ÉÉ„Éà
        if (isReel1) {
          isSpinning1 = true;
        } else {
          isSpinning2 = true;
        }

        console.log(`Player ${isReel1 ? 1 : 2} slot spin started:`, digits);

        digits = normalizeDigits(digits);
        const spinTimeouts = [];
        let completedReelsCount = 0; // ÂÆå‰∫Ü„Åó„Åü„É™„Éº„É´Êï∞„Çí„Ç´„Ç¶„É≥„Éà
        let isSpinCompleted = false; // „Çπ„Éî„É≥ÂÆå‰∫Ü„Éï„É©„Ç∞ÔºàÈáçË§áÂá¶ÁêÜÈò≤Ê≠¢Ôºâ

        reelArray.forEach((reelEl, idx) => {
          const list = reelEl.querySelector(".reel-list");

          // ÂõûËª¢ÊôÇÈñì„ÅÆË®àÁÆó
          let baseDuration, duration;
          if (spinDurations !== null && spinDurations[idx] !== undefined) {
            // ÊåáÂÆö„Åï„Çå„ÅüÂêÑ„É™„Éº„É´„ÅÆÊôÇÈñì„Çí‰ΩøÁî®
            baseDuration = spinDurations[idx];
            const extra = Math.random() * 100; // Â∞ë„Åó„ÅÆ„É©„É≥„ÉÄ„É†Ë¶ÅÁ¥†„ÇíÊÆã„Åô
            duration = baseDuration + extra;
          } else if (
            spinDurations !== null &&
            typeof spinDurations === "number"
          ) {
            // Âçò‰∏Ä„ÅÆÊï∞ÂÄ§„ÅåÊåáÂÆö„Åï„Çå„ÅüÂ†¥ÂêàÔºàÂæåÊñπ‰∫íÊèõÊÄßÔºâ
            baseDuration = spinDurations;
            const extra = idx * 100 + Math.random() * 100;
            duration = baseDuration + extra;
          } else {
            // „Éá„Éï„Ç©„É´„Éà„ÅÆÊôÇÈñìË®àÁÆóÔºàÂæå„ÅÆ„É™„Éº„É´„Åª„Å©Èï∑„Åè„ÄÅ„Å∞„Çâ„Å§„Åç„ÇíÊ∏õ„Çâ„Åó„Å¶Ëá™ÁÑ∂„Å´Ôºâ
            baseDuration = defaultDuration + Math.random() * 600;
            const extra = idx * defaultLag + Math.random() * 200;
            duration = baseDuration + extra;
          }

          const targetNumber = digits[idx];

          // ÁèæÂú®‰ΩçÁΩÆ„ÇíÂèñÂæó
          const currentTransform = parseTransformY(list);
          const currentPosition = currentTransform / cellH;

          // „Çà„ÇäÁèæÂÆüÁöÑ„Å™ÂõûËª¢Êï∞Ë®àÁÆóÔºàÂØæÊï∞ÁöÑÂ¢óÂä†Ôºâ
          // Âü∫Êú¨3ÂõûËª¢ + ÂØæÊï∞ÁöÑ„Å´Â¢óÂä†„Åô„ÇãËøΩÂä†ÂõûËª¢ÔºàÊúÄÂ§ß15ÂõûËª¢„Åæ„ÅßÔºâ
          const baseSpins = 1; // ÊúÄ‰ΩéÂõûËª¢Êï∞
          const timeBasedSpins = Math.floor(Math.log(duration / 100) * 2); // ÂØæÊï∞ÁöÑÂ¢óÂä†
          const maxTimeBasedSpins = 15; // ÊúÄÂ§ßËøΩÂä†ÂõûËª¢Êï∞„ÇíÂà∂Èôê
          const actualTimeBasedSpins = Math.min(
            Math.max(timeBasedSpins, 0),
            maxTimeBasedSpins,
          );
          const randomSpins = Math.floor(Math.random() * 1.5); // „É©„É≥„ÉÄ„É†Ë¶ÅÁ¥†
          const minSpins = baseSpins + actualTimeBasedSpins + randomSpins;

          console.log(
            `Player ${isReel1 ? 1 : 2} reel ${idx}: duration=${duration}ms, spins=${minSpins} (base=${baseSpins}, time-based=${actualTimeBasedSpins}/${timeBasedSpins}, random=${randomSpins})`,
          );
          const totalRotationCells = minSpins * numbers.length;

          const targetPositionInBlock = numbers.indexOf(targetNumber);

          // ÁõÆÊ®ô‰ΩçÁΩÆ„Çí‰∏≠Â§Æ„Éñ„É≠„ÉÉ„ÇØÂü∫Ê∫ñ„ÅßÁõ¥Êé•Ë®àÁÆó
          const centerBlockStart = Math.floor(REPEAT / 2) * numbers.length;
          const baseTargetPosition =
            centerBlockStart + targetPositionInBlock - 2;

          // ÁèæÂú®‰ΩçÁΩÆ„Åã„ÇâÊúÄ‰ΩéÂõûËª¢Êï∞„Çí‰øùË®º„Åó„ÅüÁõÆÊ®ô‰ΩçÁΩÆ„ÇíË®àÁÆó
          let targetPosition = currentPosition + totalRotationCells;

          // ÁõÆÊ®ô‰ΩçÁΩÆ„Çí‰∏≠Â§Æ„Éñ„É≠„ÉÉ„ÇØ„ÅÆÊ≠£„Åó„ÅÑ‰ΩçÁΩÆ„Å´Ë™øÊï¥
          const positionDifference =
            (baseTargetPosition - targetPosition) % numbers.length;
          if (positionDifference < 0) {
            targetPosition += numbers.length + positionDifference;
          } else {
            targetPosition += positionDifference;
          }

          const targetOffset = targetPosition * cellH;

          // „Çà„ÇäËá™ÁÑ∂„Å™Ê∏õÈÄü„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
          list.style.transition = `transform ${duration}ms cubic-bezier(0.23, 1, 0.320, 1)`;

          // „Ç´„Çπ„Ç±„Éº„ÉâÂäπÊûú„ÅßÈ†ÜÊ¨°ÈñãÂßã
          setTimeout(() => {
            list.style.transform = `translateY(-${targetOffset}px)`;

            // transitionend„Ç§„Éô„É≥„Éà„Åß„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÂÆå‰∫Ü„ÇíÁ¢∫ÂÆü„Å´Ê§úÁü•
            const handleTransitionEnd = (event) => {
              // transform „Éó„É≠„Éë„ÉÜ„Ç£„ÅÆ„Éà„É©„É≥„Ç∏„Ç∑„Éß„É≥ÂÆå‰∫Ü„ÅÆ„ÅøÂá¶ÁêÜ
              if (event.propertyName === "transform") {
                list.removeEventListener("transitionend", handleTransitionEnd);

                // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„Å™„Åó„Åß‰∏≠Â§Æ„Éñ„É≠„ÉÉ„ÇØÂÜÖ„ÅÆÈÅ©Âàá„Å™‰ΩçÁΩÆ„Å´„É™„Çª„ÉÉ„Éà
                const centerBlockStart =
                  Math.floor(REPEAT / 2) * numbers.length;
                const resetTargetPosition =
                  centerBlockStart + targetPositionInBlock - 2;
                const resetOffset = resetTargetPosition * cellH;

                // „Éà„É©„É≥„Ç∏„Ç∑„Éß„É≥„ÇíÁÑ°ÂäπÂåñ„Åó„Å¶„É™„Çª„ÉÉ„Éà
                list.style.transition = "none";
                list.style.transform = `translateY(-${resetOffset}px)`;

                // Â∞ë„ÅóÈÅÖ„Çå„Å¶„Éà„É©„É≥„Ç∏„Ç∑„Éß„É≥„ÇíÂæ©Ê¥ª
                setTimeout(() => {
                  list.style.transition =
                    "transform 400ms cubic-bezier(.2,.8,.2,1)";
                }, 10);

                // ÂÆå‰∫Ü„Åó„Åü„É™„Éº„É´Êï∞„Çí„Ç§„É≥„ÇØ„É™„É°„É≥„Éà
                completedReelsCount++;
                console.log(
                  `Player ${isReel1 ? 1 : 2} reel ${idx} completed (${completedReelsCount}/${reelArray.length})`,
                );

                // ÂÖ®„É™„Éº„É´„ÅåÂÆå‰∫Ü„Åó„Åü„Åã„ÉÅ„Çß„ÉÉ„ÇØÔºàÈáçË§áÂá¶ÁêÜÈò≤Ê≠¢Ôºâ
                if (
                  completedReelsCount === reelArray.length &&
                  !isSpinCompleted
                ) {
                  isSpinCompleted = true;
                  console.log(
                    `Player ${isReel1 ? 1 : 2} all reels completed, waiting for settlement...`,
                  );

                  // ÂÖ®„É™„Éº„É´ÂÆå‰∫ÜÊôÇ„ÅÆÂá¶ÁêÜÔºàÂ∞ë„ÅóÈï∑„ÇÅ„Å´ÂæÖÊ©ü„Åó„Å¶Á¢∫ÂÆü„Å´„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÅåÂÆå‰∫Ü„Åó„Å¶„Åã„ÇâÔºâ
                  setTimeout(() => {
                    // „Çπ„Éî„É≥ÂÆå‰∫Ü„Éï„É©„Ç∞„Çí„É™„Çª„ÉÉ„Éà
                    if (isReel1) {
                      isSpinning1 = false;
                    } else {
                      isSpinning2 = false;
                    }

                    console.log(
                      `Player ${isReel1 ? 1 : 2} slot spin completed and ready for next`,
                    );

                    // „Ç≠„É•„Éº„Å´ÂæÖÊ©ü‰∏≠„ÅÆ„Çπ„Éî„É≥„Åå„ÅÇ„Çå„Å∞ÂÆüË°å
                    if (spinQueue.length > 0) {
                      const nextSpin = spinQueue.shift();
                      console.log(
                        `Player ${isReel1 ? 1 : 2} executing queued spin:`,
                        nextSpin.digits,
                      );
                      setTimeout(
                        () =>
                          spinTo(
                            nextSpin.digits,
                            reelArray,
                            nextSpin.spinDurations,
                          ),
                        300,
                      );
                    }
                  }, 200); // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÅåÁ¢∫ÂÆü„Å´ÂÆå‰∫Ü„Åô„Çã„Åæ„ÅßÂæÖÊ©ü
                }
              }
            };

            list.addEventListener("transitionend", handleTransitionEnd);

            // // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Çø„Ç§„É†„Ç¢„Ç¶„ÉàÔºà„Ç§„Éô„É≥„Éà„ÅåÁô∫ÁÅ´„Åó„Å™„ÅÑÂ†¥Âêà„ÅÆ‰øùÈô∫Ôºâ
            // // ÊúÄÂ§ß„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÊôÇÈñì„ÇíËÄÉÊÖÆ„Åó„Å¶ÂçÅÂàÜ„Å´Èï∑„ÇÅ„Å´Ë®≠ÂÆö
            // const maxDuration =
            //   spinDurations !== null &&
            //   (Array.isArray(spinDurations) ||
            //     typeof spinDurations === "number")
            //     ? baseDuration +
            //       (reelArray.length - 1) * 100 +
            //       Math.random() * 100
            //     : baseDuration +
            //       (reelArray.length - 1) * 400 +
            //       Math.random() * 200;
            // const fallbackTimeout = setTimeout(() => {
            //   if (!isSpinCompleted) {
            //     console.warn(
            //       `Player ${isReel1 ? 1 : 2} reel ${idx} fallback timeout triggered`,
            //     );
            //     list.removeEventListener("transitionend", handleTransitionEnd);
            //     handleTransitionEnd({ propertyName: "transform" });
            //   }
            // }, maxDuration + 1500);

            // spinTimeouts.push(fallbackTimeout);
          }, idx * 200);
        });

        // ÂÅúÊ≠¢Áî®„ÅÆÈñ¢Êï∞„ÇíËøî„Åô
        return function stop() {
          spinTimeouts.forEach((id) => clearTimeout(id));

          // „Çπ„Éî„É≥Áä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
          if (isReel1) {
            isSpinning1 = false;
          } else {
            isSpinning2 = false;
          }

          // ÂêÑ„É™„Éº„É´„ÇíÂç≥Â∫ß„Å´ÁõÆÊ®ô‰ΩçÁΩÆ„Å´ÁßªÂãï
          reelArray.forEach((reelEl, idx) => {
            const list = reelEl.querySelector(".reel-list");
            list.style.transition = "transform 300ms ease-out";
          });
          setDigits(digits, reelArray);

          console.log(`Player ${isReel1 ? 1 : 2} slot spin stopped`);
        };
      }

      // „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£: Êï∞Â≠óÈÖçÂàó„ÅÆÊ≠£Ë¶èÂåñ
      function normalizeDigits(d) {
        console.log("normalizeDigits", d);
        if (!Array.isArray(d)) throw new Error("ÈÖçÂàó„ÅßÊ∏°„Åó„Å¶„Åè„Å†„Åï„ÅÑ: [a,b,c]");
        if (d.length !== 3) throw new Error("Ë¶ÅÁ¥†Êï∞„ÅØ3„Å§ÂøÖË¶Å„Åß„Åô");
        return d.map((x) => Number(x) || 1).map((x) => ((x - 1) % 8) + 1);
      }

      // „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£: ÁèæÂú®„ÅÆtranslateYÂÄ§„ÇíÂèñÂæó
      function parseTransformY(list) {
        const t = getComputedStyle(list).transform;
        if (!t || t === "none") return 0;

        // matrixÂΩ¢Âºè
        const matrixMatch = t.match(
          /matrix\(([^,]+),\s*([^,]+),\s*([^,]+),\s*([^,]+),\s*([^,]+),\s*([^\)]+)\)/,
        );
        if (matrixMatch) {
          return Math.abs(parseFloat(matrixMatch[6]));
        }

        // translateYÂΩ¢Âºè
        const translateMatch = t.match(/translateY\((-?\d+(?:\.\d+)?)px\)/);
        if (translateMatch) {
          return Math.abs(parseFloat(translateMatch[1]));
        }

        // translate3dÂΩ¢Âºè
        const translate3dMatch = t.match(
          /translate3d\(([^,]+),\s*(-?\d+(?:\.\d+)?)px,\s*([^\)]+)\)/,
        );
        if (translate3dMatch) {
          return Math.abs(parseFloat(translate3dMatch[2]));
        }

        return 0;
      }

      // „Éó„É¨„Ç§„É§„Éº1Áî®„ÅÆ„Ç®„Ç§„É™„Ç¢„ÇπÈñ¢Êï∞
      function setDigits1(digits) {
        console.log("Player 1 setDigits called:", digits);
        return setDigits(digits, reels1);
      }

      function spinTo1(digits, spinDurations = null) {
        console.log("Player 1 spinTo called:", digits);
        return spinTo(digits, reels1, spinDurations);
      }

      // „Éó„É¨„Ç§„É§„Éº2Áî®„ÅÆ„Ç®„Ç§„É™„Ç¢„ÇπÈñ¢Êï∞
      function setDigits2(digits) {
        console.log("Player 2 setDigits called:", digits);
        return setDigits(digits, reels2);
      }

      function spinTo2(digits, spinDurations = null) {
        console.log("Player 2 spinTo called:", digits);
        return spinTo(digits, reels2, spinDurations);
      }

      // ‰∏°„Éó„É¨„Ç§„É§„ÉºÂêåÊôÇÊìç‰ΩúÁî®„ÅÆ„Ç®„Ç§„É™„Ç¢„ÇπÈñ¢Êï∞
      function setDigitsBoth(digits) {
        console.log("Both players setDigits called:", digits);
        setDigits1(digits);
        setDigits2(digits);
      }

      function spinToBoth(digits, spinDurations = null) {
        spinTo1(digits, spinDurations);
        spinTo2(digits, spinDurations);
      }

      // „Éá„Éê„ÉÉ„Ç∞Èñ¢Êï∞„Çí„Ç∞„É≠„Éº„Éê„É´„Çπ„Ç≥„Éº„Éó„Å´ÂÖ¨Èñã
      window.getSlotStatus = getSlotStatus;
      window.forceResetSlotState = forceResetSlotState;
      window.debugSlots = () => {
        console.log("=== „Çπ„É≠„ÉÉ„ÉàÁä∂ÊÖã ===");
        console.log("„Éó„É¨„Ç§„É§„Éº1:", getSlotStatus(1));
        console.log("„Éó„É¨„Ç§„É§„Éº2:", getSlotStatus(2));
      };
      window.getTaskQueueStatus = (playerId) => {
        if (playerId === 1) return taskQueue1 ? taskQueue1.getStatus() : null;
        if (playerId === 2) return taskQueue2 ? taskQueue2.getStatus() : null;
        return {
          player1: taskQueue1 ? taskQueue1.getStatus() : null,
          player2: taskQueue2 ? taskQueue2.getStatus() : null,
        };
      };
      window.debugTaskQueues = () => {
        console.log("=== „Çø„Çπ„ÇØ„Ç≠„É•„ÉºÁä∂ÊÖã ===");
        console.log(
          "„Éó„É¨„Ç§„É§„Éº1:",
          taskQueue1 ? taskQueue1.getStatus() : "Êú™ÂàùÊúüÂåñ",
        );
        console.log(
          "„Éó„É¨„Ç§„É§„Éº2:",
          taskQueue2 ? taskQueue2.getStatus() : "Êú™ÂàùÊúüÂåñ",
        );
      };

      window.debugSpinningState = () => {
        console.log("=== „Çπ„É≠„ÉÉ„ÉàÂõûËª¢Áä∂ÊÖã ===");
        console.log("UIÂÅ¥„Çπ„É≠„ÉÉ„ÉàÁä∂ÊÖã:");
        console.log("  „Éó„É¨„Ç§„É§„Éº1:", getSlotStatus(1));
        console.log("  „Éó„É¨„Ç§„É§„Éº2:", getSlotStatus(2));
        console.log("„Ç≤„Éº„É†ÂÅ¥„Çπ„É≠„ÉÉ„ÉàÁä∂ÊÖã:");
        console.log(
          "  „Éó„É¨„Ç§„É§„Éº1:",
          window.game1 ? window.game1.isSlotCurrentlySpinning() : "Êú™ÂàùÊúüÂåñ",
        );
        console.log(
          "  „Éó„É¨„Ç§„É§„Éº2:",
          window.game2 ? window.game2.isSlotCurrentlySpinning() : "Êú™ÂàùÊúüÂåñ",
        );
      };

      // „ÉÜ„Çπ„ÉàÁî®„ÅÆ„Éá„Éê„ÉÉ„Ç∞Èñ¢Êï∞
      window.testSlotTiming = (playerId = 1, count = 3, interval = 500) => {
        console.log(`=== „Éó„É¨„Ç§„É§„Éº${playerId}„ÅÆ„Çπ„É≠„ÉÉ„ÉàÈÄ£Á∂ö„ÉÜ„Çπ„ÉàÈñãÂßã ===`);
        const spinFunc = playerId === 1 ? spinTo1 : spinTo2;

        for (let i = 0; i < count; i++) {
          setTimeout(() => {
            const digits = [
              Math.floor(Math.random() * 8) + 1,
              Math.floor(Math.random() * 8) + 1,
              Math.floor(Math.random() * 8) + 1,
            ];
            console.log(`„ÉÜ„Çπ„Éà ${i + 1}/${count}:`, digits);
            spinFunc(digits);
          }, i * interval);
        }
      };

      // ‰∏°„Éó„É¨„Ç§„É§„ÉºÂêåÊôÇÂõûËª¢„ÉÜ„Çπ„Éà
      window.testBothSlots = (count = 2, interval = 1000) => {
        console.log("=== ‰∏°„Éó„É¨„Ç§„É§„ÉºÂêåÊôÇ„Çπ„É≠„ÉÉ„Éà„ÉÜ„Çπ„ÉàÈñãÂßã ===");
        for (let i = 0; i < count; i++) {
          setTimeout(() => {
            const digits1 = [
              Math.floor(Math.random() * 8) + 1,
              Math.floor(Math.random() * 8) + 1,
              Math.floor(Math.random() * 8) + 1,
            ];
            const digits2 = [
              Math.floor(Math.random() * 8) + 1,
              Math.floor(Math.random() * 8) + 1,
              Math.floor(Math.random() * 8) + 1,
            ];
            console.log(`‰∏°„Éó„É¨„Ç§„É§„Éº„ÉÜ„Çπ„Éà ${i + 1}/${count}:`, {
              player1: digits1,
              player2: digits2,
            });
            spinTo1(digits1);
            spinTo2(digits2);
          }, i * interval);
        }
      };

      // ÂêÑ„É™„Éº„É´ÂÄãÂà•ÊôÇÈñìÊåáÂÆö„ÉÜ„Çπ„Éà
      window.testIndividualReelTiming = (playerId = 1) => {
        console.log(`=== „Éó„É¨„Ç§„É§„Éº${playerId}„ÅÆÂêÑ„É™„Éº„É´ÂÄãÂà•ÊôÇÈñì„ÉÜ„Çπ„Éà ===`);
        const spinFunc = playerId === 1 ? spinTo1 : spinTo2;

        // „ÉÜ„Çπ„Éà„Éë„Çø„Éº„É≥1: Â∑¶„Åã„ÇâÂè≥„Å∏È†ÜÊ¨°Èï∑„Åè
        setTimeout(() => {
          const digits = [7, 7, 7];
          const durations = [1000, 1500, 2000]; // 1Áßí„ÄÅ1.5Áßí„ÄÅ2Áßí
          console.log("„Éë„Çø„Éº„É≥1 - Â∑¶„Åã„ÇâÂè≥„Å∏È†ÜÊ¨°Èï∑„Åè:", { digits, durations });
          spinFunc(digits, durations);
        }, 0);

        // „ÉÜ„Çπ„Éà„Éë„Çø„Éº„É≥2: Âè≥„Åã„ÇâÂ∑¶„Å∏È†ÜÊ¨°Èï∑„Åè
        setTimeout(() => {
          const digits = [3, 3, 3];
          const durations = [2000, 1500, 1000]; // 2Áßí„ÄÅ1.5Áßí„ÄÅ1Áßí
          console.log("„Éë„Çø„Éº„É≥2 - Âè≥„Åã„ÇâÂ∑¶„Å∏È†ÜÊ¨°Èï∑„Åè:", { digits, durations });
          spinFunc(digits, durations);
        }, 4000);

        // „ÉÜ„Çπ„Éà„Éë„Çø„Éº„É≥3: ‰∏≠Â§Æ„Å†„ÅëÈï∑„Åè
        setTimeout(() => {
          const digits = [1, 2, 3];
          const durations = [1000, 3000, 1000]; // 1Áßí„ÄÅ3Áßí„ÄÅ1Áßí
          console.log("„Éë„Çø„Éº„É≥3 - ‰∏≠Â§Æ„Å†„ÅëÈï∑„Åè:", { digits, durations });
          spinFunc(digits, durations);
        }, 8000);

        // „ÉÜ„Çπ„Éà„Éë„Çø„Éº„É≥4: ÂÖ®„É™„Éº„É´Âêå„ÅòÊôÇÈñìÔºàÈÖçÂàóÊåáÂÆöÔºâ
        setTimeout(() => {
          const digits = [5, 5, 5];
          const durations = [1800, 1800, 1800]; // ÂÖ®„Å¶1.8Áßí
          console.log("„Éë„Çø„Éº„É≥4 - ÂÖ®„É™„Éº„É´Âêå„ÅòÊôÇÈñìÔºàÈÖçÂàóÔºâ:", {
            digits,
            durations,
          });
          spinFunc(digits, durations);
        }, 12000);
      };

      // ÂõûËª¢ÊôÇÈñì„Å®ÂõûËª¢Êï∞„ÅÆÊØî‰æãÈñ¢‰øÇ„ÉÜ„Çπ„Éà
      window.testRotationCountByDuration = (playerId = 1) => {
        console.log(
          `=== „Éó„É¨„Ç§„É§„Éº${playerId}„ÅÆÂõûËª¢ÊôÇÈñì„ÉªÂõûËª¢Êï∞ÊØî‰æã„ÉÜ„Çπ„Éà ===`,
        );
        const spinFunc = playerId === 1 ? spinTo1 : spinTo2;

        // „ÉÜ„Çπ„ÉàÁµêÊûúË°®Á§∫Áî®„ÅÆË¶ÅÁ¥†„Çí‰ΩúÊàê
        let testResultDiv = document.getElementById("rotation-test-results");
        if (!testResultDiv) {
          testResultDiv = document.createElement("div");
          testResultDiv.id = "rotation-test-results";
          testResultDiv.style.cssText = `
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            max-width: 300px;
            z-index: 1000;
          `;
          document.body.appendChild(testResultDiv);
        }
        testResultDiv.innerHTML = `<h4>ÂõûËª¢Êï∞„ÉÜ„Çπ„ÉàÁµêÊûú (Player ${playerId})</h4>`;

        const addResult = (duration, expectedSpins) => {
          const resultLine = document.createElement("div");
          resultLine.textContent = `${duration}ms ‚Üí Á¥Ñ${expectedSpins}ÂõûËª¢`;
          testResultDiv.appendChild(resultLine);
        };

        // „ÉÜ„Çπ„Éà1: Áü≠ÊôÇÈñìÔºàÂü∫Êú¨ÂõûËª¢Êï∞Ôºâ
        setTimeout(() => {
          const digits = [1, 2, 3];
          const durations = [800, 800, 800]; // Áü≠ÊôÇÈñì
          const expectedSpins =
            3 + Math.min(Math.max(Math.floor(Math.log(800 / 100) * 2), 0), 15);
          addResult(800, expectedSpins);
          console.log("Áü≠ÊôÇÈñì„ÉÜ„Çπ„ÉàÔºà800msÔºâ- Âü∫Êú¨ÂõûËª¢Êï∞„ÅßÂõûËª¢:", {
            digits,
            durations,
            expectedSpins,
          });
          spinFunc(digits, durations);
        }, 0);

        // „ÉÜ„Çπ„Éà2: ‰∏≠ÊôÇÈñìÔºà‰∏≠Á®ãÂ∫¶„ÅÆÂõûËª¢Êï∞Ôºâ
        setTimeout(() => {
          const digits = [4, 5, 6];
          const durations = [1500, 1500, 1500]; // ‰∏≠ÊôÇÈñì
          const expectedSpins =
            3 + Math.min(Math.max(Math.floor(Math.log(1500 / 100) * 2), 0), 15);
          addResult(1500, expectedSpins);
          console.log("‰∏≠ÊôÇÈñì„ÉÜ„Çπ„ÉàÔºà1500msÔºâ- ‰∏≠Á®ãÂ∫¶„ÅÆÂõûËª¢Êï∞„ÅßÂõûËª¢:", {
            digits,
            durations,
            expectedSpins,
          });
          spinFunc(digits, durations);
        }, 3000);

        // „ÉÜ„Çπ„Éà3: Èï∑ÊôÇÈñìÔºàÂ§öÂõûËª¢Ôºâ
        setTimeout(() => {
          const digits = [7, 8, 9];
          const durations = [2500, 2500, 2500]; // Èï∑ÊôÇÈñì
          const expectedSpins =
            3 + Math.min(Math.max(Math.floor(Math.log(2500 / 100) * 2), 0), 15);
          addResult(2500, expectedSpins);
          console.log("Èï∑ÊôÇÈñì„ÉÜ„Çπ„ÉàÔºà2500msÔºâ- Â§öÂõûËª¢„ÅßÂõûËª¢:", {
            digits,
            durations,
            expectedSpins,
          });
          spinFunc(digits, durations);
        }, 6000);

        // „ÉÜ„Çπ„Éà4: Ë∂ÖÈï∑ÊôÇÈñìÔºàÊúÄÂ§ßÂõûËª¢Ôºâ
        setTimeout(() => {
          const digits = [8, 1, 2];
          const durations = [4000, 4000, 4000]; // Ë∂ÖÈï∑ÊôÇÈñì
          const expectedSpins =
            3 + Math.min(Math.max(Math.floor(Math.log(4000 / 100) * 2), 0), 15);
          addResult(4000, expectedSpins);
          console.log("Ë∂ÖÈï∑ÊôÇÈñì„ÉÜ„Çπ„ÉàÔºà4000msÔºâ- ÊúÄÂ§ßÂõûËª¢Êï∞„ÅßÂõûËª¢:", {
            digits,
            durations,
            expectedSpins,
          });
          spinFunc(digits, durations);
        }, 10000);

        // „ÉÜ„Çπ„Éà5: Ë∂ÖË∂ÖÈï∑ÊôÇÈñìÔºà15ÁßíÔºâ
        setTimeout(() => {
          const digits = [5, 5, 5];
          const durations = [15000, 15000, 15000]; // Ë∂ÖË∂ÖÈï∑ÊôÇÈñì
          const expectedSpins =
            3 +
            Math.min(Math.max(Math.floor(Math.log(15000 / 100) * 2), 0), 15);
          addResult(15000, expectedSpins);
          console.log("Ë∂ÖË∂ÖÈï∑ÊôÇÈñì„ÉÜ„Çπ„ÉàÔºà15000msÔºâ- ÂØæÊï∞Âà∂ÈôêÂõûËª¢:", {
            digits,
            durations,
            expectedSpins,
          });
          spinFunc(digits, durations);
        }, 14000);

        console.log("ÂêÑ„ÉÜ„Çπ„Éà„ÅÆÂõûËª¢Êï∞„ÅÆÈÅï„ÅÑ„Çí„Ç≥„É≥„ÇΩ„Éº„É´„É≠„Ç∞„ÅßÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ");

        // 20ÁßíÂæå„Å´„ÉÜ„Çπ„ÉàÁµêÊûúË°®Á§∫„ÇíËá™ÂãïÂâäÈô§
        setTimeout(() => {
          if (testResultDiv && testResultDiv.parentNode) {
            testResultDiv.parentNode.removeChild(testResultDiv);
          }
        }, 20000);
      };

      // ÂæìÊù•„ÅÆÊï∞ÂÄ§ÊåáÂÆö„ÉÜ„Çπ„ÉàÔºàtestIndividualReelTiming„ÅÆÁ∂ö„ÅçÔºâ
      window.testBackwardCompatibility = (playerId = 1) => {
        console.log(`=== „Éó„É¨„Ç§„É§„Éº${playerId}„ÅÆÂæåÊñπ‰∫íÊèõÊÄß„ÉÜ„Çπ„Éà ===`);
        const spinFunc = playerId === 1 ? spinTo1 : spinTo2;

        // „ÉÜ„Çπ„Éà„Éë„Çø„Éº„É≥5: ÂæìÊù•„ÅÆÊï∞ÂÄ§ÊåáÂÆöÔºàÂæåÊñπ‰∫íÊèõÊÄßÁ¢∫Ë™çÔºâ
        setTimeout(() => {
          const digits = [8, 7, 6];
          const duration = 2500; // Âçò‰∏ÄÊï∞ÂÄ§
          console.log("ÂæìÊù•„ÅÆÊï∞ÂÄ§ÊåáÂÆö„ÉÜ„Çπ„Éà:", { digits, duration });
          spinFunc(digits, duration);
        }, 0);
      };

      // ÂõûËª¢Êï∞Ë®àÁÆó„ÅÆË©≥Á¥∞„ÇíË°®Á§∫„Åô„Çã„Éò„É´„Éë„ÉºÈñ¢Êï∞
      window.showRotationFormula = () => {
        let formulaDiv = document.getElementById("rotation-formula");
        if (!formulaDiv) {
          formulaDiv = document.createElement("div");
          formulaDiv.id = "rotation-formula";
          formulaDiv.style.cssText = `
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0,100,0,0.9);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 11px;
            max-width: 350px;
            z-index: 1000;
          `;
          document.body.appendChild(formulaDiv);
        }

        formulaDiv.innerHTML = `
          <h4>ÂõûËª¢Êï∞Ë®àÁÆóÂºèÔºàÂØæÊï∞ÁöÑÂ¢óÂä†Ôºâ</h4>
          <p><strong>Á∑èÂõûËª¢Êï∞ = Âü∫Êú¨ÂõûËª¢Êï∞ + ÊôÇÈñì„Éô„Éº„ÇπÂõûËª¢Êï∞ + „É©„É≥„ÉÄ„É†ÂõûËª¢Êï∞</strong></p>
          <ul>
            <li>Âü∫Êú¨ÂõûËª¢Êï∞: 3ÂõûËª¢ÔºàÂõ∫ÂÆöÔºâ</li>
            <li>ÊôÇÈñì„Éô„Éº„ÇπÂõûËª¢Êï∞: Math.min(Math.floor(Math.log(duration/100) * 2), 15)</li>
            <li>„É©„É≥„ÉÄ„É†ÂõûËª¢Êï∞: Math.floor(Math.random() * 1.5)</li>
          </ul>
          <p>‰æã: 1500ms ‚Üí 3 + Math.min(Math.floor(Math.log(15) * 2), 15) + 0~1 = 8~9ÂõûËª¢</p>
          <p>‰æã: 15000ms ‚Üí 3 + Math.min(Math.floor(Math.log(150) * 2), 15) + 0~1 = 13~14ÂõûËª¢</p>
          <button onclick="document.body.removeChild(document.getElementById('rotation-formula'))"
                  style="margin-top:10px; padding:5px; background:white; border:none; border-radius:3px;">
            Èñâ„Åò„Çã
          </button>
        `;
      };

      // „Çø„Çπ„ÇØ„Ç≠„É•„Éº„ÅÆ„ÉÜ„Çπ„ÉàÈñ¢Êï∞
      window.testTaskQueue = (playerId = 1, count = 3) => {
        console.log(`=== „Éó„É¨„Ç§„É§„Éº${playerId}„ÅÆ„Çø„Çπ„ÇØ„Ç≠„É•„Éº„ÉÜ„Çπ„ÉàÈñãÂßã ===`);
        const taskQueue = playerId === 1 ? taskQueue1 : taskQueue2;

        if (!taskQueue) {
          console.error("„Çø„Çπ„ÇØ„Ç≠„É•„Éº„ÅåÊú™ÂàùÊúüÂåñ„Åß„Åô");
          return;
        }

        for (let i = 0; i < count; i++) {
          const digits = [
            Math.floor(Math.random() * 8) + 1,
            Math.floor(Math.random() * 8) + 1,
            Math.floor(Math.random() * 8) + 1,
          ];

          // ÊäΩÈÅ∏„Çø„Çπ„ÇØ„ÇíÁõ¥Êé•„Ç≠„É•„Éº„Å´ËøΩÂä†
          taskQueue.addTask("lotteryNormal", {
            lotteryResult: { type: "Normal", value: Math.random() * 100 },
            slotResult: [digits, digits],
            taskType: `Test Normal Lottery ${i + 1}`,
          });

          // Áä∂ÊÖãÊõ¥Êñ∞„Çø„Çπ„ÇØ„ÇÇËøΩÂä†
          taskQueue.addTask("default", {
            after: {
              type: "Normal",
              balls: 1000 - i * 10,
            },
          });
        }
      };

      window.testMixedTasks = (playerId = 1) => {
        console.log(`=== „Éó„É¨„Ç§„É§„Éº${playerId}„ÅÆÊ∑∑Âêà„Çø„Çπ„ÇØ„ÉÜ„Çπ„ÉàÈñãÂßã ===`);
        const taskQueue = playerId === 1 ? taskQueue1 : taskQueue2;

        if (!taskQueue) {
          console.error("„Çø„Çπ„ÇØ„Ç≠„É•„Éº„ÅåÊú™ÂàùÊúüÂåñ„Åß„Åô");
          return;
        }

        // ÈÄöÂ∏∏ÊäΩÈÅ∏
        taskQueue.addTask("lotteryNormal", {
          lotteryResult: { type: "Win" },
          slotResult: [
            [1, 2, 3],
            [4, 5, 6],
          ],
          taskType: "Mixed Test Normal",
        });

        // Áä∂ÊÖãÊõ¥Êñ∞
        taskQueue.addTask("default", {
          after: { type: "Normal", balls: 950 },
        });

        // „É©„ÉÉ„Ç∑„É•ÊäΩÈÅ∏
        taskQueue.addTask("lotteryRush", {
          lotteryResult: { type: "Rush" },
          slotResult: [
            [7, 7, 7],
            [7, 7, 7],
          ],
          taskType: "Mixed Test Rush",
        });

        // „Åï„Çâ„Å´Áä∂ÊÖãÊõ¥Êñ∞
        taskQueue.addTask("default", {
          after: { type: "Rush", balls: 900, rushBalls: 50, n: 1 },
        });
      };

      // Áµ±Âêà„Éá„Éê„ÉÉ„Ç∞Èñ¢Êï∞
      window.debugAll = () => {
        console.log("=== Áµ±Âêà„Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†± ===");
        console.log("=== „Çπ„É≠„ÉÉ„ÉàÁä∂ÊÖã ===");
        console.log("„Éó„É¨„Ç§„É§„Éº1:", getSlotStatus(1));
        console.log("„Éó„É¨„Ç§„É§„Éº2:", getSlotStatus(2));
        console.log("=== „Çø„Çπ„ÇØ„Ç≠„É•„ÉºÁä∂ÊÖã ===");
        console.log(
          "„Éó„É¨„Ç§„É§„Éº1:",
          taskQueue1 ? taskQueue1.getStatus() : "Êú™ÂàùÊúüÂåñ",
        );
        console.log(
          "„Éó„É¨„Ç§„É§„Éº2:",
          taskQueue2 ? taskQueue2.getStatus() : "Êú™ÂàùÊúüÂåñ",
        );
      };

      setDigitsBoth([1, 1, 1]);

      import {
        init,
        WasmGame,
        ControlFlow,
        Config,
        BallsConfig,
        Probability,
        SlotProbability,
        JsInput,
        JsOutput,
      } from "./pachislo.js";

      // Matter.js„ÅÆ‰∏ªË¶Å„É¢„Ç∏„É•„Éº„É´„ÇíÂèñÂæó
      const {
        Engine,
        Render,
        Runner,
        Bodies,
        Composite,
        Events,
        Mouse,
        MouseConstraint,
      } = Matter;

      // „Éë„ÉÅ„É≥„Ç≥„Ç≤„Éº„É†„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÇØ„É©„Çπ
      class PachinkoGame {
        constructor(
          canvasId,
          playerId,
          keyBinding,
          nails,
          wasmGame,
          recreateWasmGame,
        ) {
          this.canvasId = canvasId;
          this.playerId = playerId;
          this.keyBinding = keyBinding;
          this.fallingBalls = [];
          this.nails_index = nails;
          this.wasmgame = wasmGame;
          this.recreateWasmGame = recreateWasmGame; // WASMGameÂÜç‰ΩúÊàêÁî®„ÅÆÈñ¢Êï∞
          this.lastLaunchTime = 0; // ÊúÄÂæå„ÅÆ„Éú„Éº„É´Áô∫Â∞ÑÊôÇÂàª„ÇíË®òÈå≤
          this.gameTimer = null; // „Ç≤„Éº„É†ÁµÇ‰∫Ü„Çø„Ç§„Éû„Éº
          this.gameDuration = 5 * 60 * 1000; // „Éá„Éï„Ç©„É´„Éà5ÂàÜ
          this.gameStartTime = null; // „Ç≤„Éº„É†ÈñãÂßãÊôÇÂàª
          this.displayTimer = null; // „Çø„Ç§„Éû„ÉºË°®Á§∫Áî®„Ç§„É≥„Çø„Éº„Éê„É´

          this.init(); // canvas„Å®Áâ©ÁêÜ„Ç®„É≥„Ç∏„É≥„ÅØÊúÄÂàù„Åã„ÇâÂàùÊúüÂåñ
        }

        run_step_with_command(command) {
          this.wasmgame.run_step_with_command(command);
        }

        init() {
          // „Ç®„É≥„Ç∏„É≥„Çí‰ΩúÊàê
          this.engine = Engine.create();
          this.world = this.engine.world;
          this.engine.world.gravity.y = 0.8;

          // „É¨„É≥„ÉÄ„É©„Éº„Çí‰ΩúÊàê
          this.setupRenderer();

          // „Ç≤„Éº„É†Ë¶ÅÁ¥†„Çí‰ΩúÊàê
          this.createWalls();
          this.createNails();
          this.createTargetZones();
          this.setupMouseControl();
          this.setupEventListeners();

          // ‰∏ñÁïå„Å´„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíËøΩÂä†
          this.addToWorld();

          // „Ç®„É≥„Ç∏„É≥„ÇíÈñãÂßã
          this.start();
        }

        async startWasmGame() {
          console.log(
            `„Éó„É¨„Ç§„É§„Éº${this.playerId}: startWasmGame()„ÅåÂëº„Å∞„Çå„Åæ„Åó„Åü„ÄÇÁèæÂú®„ÅÆisGameStarted: ${this.wasmgame.isGameStarted()}`,
          );

          if (this.wasmgame.isGameStarted()) {
            console.log(
              `„Éó„É¨„Ç§„É§„Éº${this.playerId}: Êó¢„Å´„Ç≤„Éº„É†ÈñãÂßãÊ∏à„Åø„ÅÆ„Åü„ÇÅÂá¶ÁêÜ„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Åæ„Åô`,
            );
            return; // Êó¢„Å´„Ç≤„Éº„É†ÈñãÂßãÊ∏à„Åø„ÅÆÂ†¥Âêà„ÅØ‰Ωï„ÇÇ„Åó„Å™„ÅÑ
          }

          // „Éë„ÉÅ„Çπ„É≠„Ç≤„Éº„É†„ÇíÈñãÂßã
          console.log(
            `„Éó„É¨„Ç§„É§„Éº${this.playerId}: StartGame„Ç≥„Éû„É≥„Éâ„ÇíÂÆüË°å„Åó„Åæ„Åô`,
          );
          this.run_step_with_command("StartGame");

          // Êó¢Â≠ò„ÅÆ„Çø„Ç§„Éû„Éº„Çí„ÇØ„É™„Ç¢
          if (this.displayTimer) {
            clearInterval(this.displayTimer);
            this.displayTimer = null;
          }

          // „Ç≤„Éº„É†ÈñãÂßãÊôÇÂàª„ÇíË®òÈå≤
          this.gameStartTime = Date.now();

          // Ë®≠ÂÆöÊôÇÈñìÂæå„Å´„Ç≤„Éº„É†„ÇíÁµÇ‰∫Ü„Åï„Åõ„Çã„Çø„Ç§„Éû„Éº„ÇíË®≠ÂÆö
          this.gameTimer = setTimeout(async () => {
            await this.endGame();
          }, this.gameDuration);

          // „Çø„Ç§„Éû„ÉºË°®Á§∫„ÇíÈñãÂßã
          this.startTimerDisplay();

          console.log(
            `„Éó„É¨„Ç§„É§„Éº${this.playerId}: „Ç≤„Éº„É†ÈñãÂßãÔºÅ5ÂàÜÂæå„Å´Ëá™ÂãïÁµÇ‰∫Ü„Åó„Åæ„Åô„ÄÇisGameStarted: ${this.wasmgame.isGameStarted()}`,
          );
        }

        async endGame() {
          // Êó¢„Å´„Ç≤„Éº„É†„ÅåÁµÇ‰∫Ü„Åó„Å¶„ÅÑ„Çã„ÄÅ„Åæ„Åü„ÅØÁµÇ‰∫ÜÂá¶ÁêÜ‰∏≠„ÅÆÂ†¥Âêà„ÅØ‰Ωï„ÇÇ„Åó„Å™„ÅÑ
          if (!this.wasmgame.isGameStarted()) {
            console.log(
              `„Éó„É¨„Ç§„É§„Éº${this.playerId}: endGame()„ÅåÂëº„Å∞„Çå„Åæ„Åó„Åü„Åå„ÄÅÊó¢„Å´„Ç≤„Éº„É†„ÅØÁµÇ‰∫ÜÊ∏à„Åø„Åß„Åô`,
            );
            return;
          }

          // „Éó„É¨„Ç§„É§„Éº„Å´ÂØæÂøú„Åô„Çã isProcessingFinishTask „ÇíÂèñÂæó„Åó„ÄÅtrue„Å™„ÇâÂá¶ÁêÜ‰∏≠„Å™„ÅÆ„Åß‰∏≠Êñ≠
          const isProcessing =
            this.playerId === 1
              ? isProcessingFinishTask1
              : isProcessingFinishTask2;
          if (isProcessing) {
            console.log(
              `„Éó„É¨„Ç§„É§„Éº${this.playerId}: ÁèæÂú®„ÄÅÁµÇ‰∫ÜÂá¶ÁêÜ„ÅÆ„ÇØ„Éº„É´„ÉÄ„Ç¶„É≥‰∏≠„Åß„Åô„ÄÇ`,
            );
            return;
          }

          console.log(
            `„Éó„É¨„Ç§„É§„Éº${this.playerId}: „Ç≤„Éº„É†ÁµÇ‰∫Ü„Ç∑„Éº„Ç±„É≥„Çπ„ÇíÈñãÂßã„Åó„Åæ„Åô„ÄÇ`,
          );

          // ‚óÜ „Çπ„ÉÜ„Éº„Çø„Çπ„ÇíÂç≥Â∫ß„Å´„ÄåÁµÇ‰∫ÜÂá¶ÁêÜ‰∏≠„Äç„Å´Ë®≠ÂÆö„Åó„ÄÅ„Ç≠„ÉºÂÖ•Âäõ„Çí„Éñ„É≠„ÉÉ„ÇØ
          setIsProcessingFinishTask(this.playerId, true);

          // „Çø„Ç§„Éû„ÉºÈñ¢ÈÄ£„Çí„ÇØ„É™„Ç¢
          if (this.gameTimer) clearTimeout(this.gameTimer);
          if (this.displayTimer) clearInterval(this.displayTimer);
          this.gameTimer = null;
          this.displayTimer = null;
          this.gameStartTime = null;

          // „Çø„Ç§„Éû„ÉºË°®Á§∫„Çí„É™„Çª„ÉÉ„Éà
          const timerDisplay = document.getElementById(
            `timer-display${this.playerId}`,
          );
          if (timerDisplay) {
            const minutes = Math.floor(this.gameDuration / 60000);
            timerDisplay.textContent = `${minutes}:00`;
            timerDisplay.style.color = "white";
            timerDisplay.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
          }

          // ‚óÜ UIÊõ¥Êñ∞„ÅÆ„Åü„ÇÅ„Å´FinishGame„Ç≥„Éû„É≥„Éâ„Çí„Ç≠„É•„Éº„ÅÆÊúÄÂæå„Å´ËøΩÂä†
          this.run_step_with_command("FinishGame");

          // ‚óÜ „Çø„Çπ„ÇØ„Ç≠„É•„Éº„ÅåÁ©∫„Å´„Å™„Çã„ÅÆ„ÇíÁõ£Ë¶ñ„Åô„Çã
          const checkQueueInterval = setInterval(() => {
            // „Éó„É¨„Ç§„É§„Éº„Å´ÂØæÂøú„Åô„Çã„Çø„Çπ„ÇØ„Ç≠„É•„Éº„ÇíÂèñÂæó
            const taskQueue = this.playerId === 1 ? taskQueue1 : taskQueue2;

            // „Ç≠„É•„Éº„ÅåÁ©∫„Åß„ÄÅ„Åã„Å§‰Ωï„ÇÇÂá¶ÁêÜ„Åó„Å¶„ÅÑ„Å™„ÅÑÁä∂ÊÖã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            if (
              taskQueue &&
              taskQueue.queue.length === 0 &&
              !taskQueue.isProcessing
            ) {
              // ‚óÜ Êù°‰ª∂„ÇíÊ∫Ä„Åü„Åó„Åü„ÇâÁõ£Ë¶ñ„ÇíÂÅúÊ≠¢
              clearInterval(checkQueueInterval);

              console.log(
                `„Éó„É¨„Ç§„É§„Éº${this.playerId}: ÂÖ®„Å¶„ÅÆ„Çø„Çπ„ÇØ„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü„ÄÇ10ÁßíÈñì„ÅÆ„ÇØ„Éº„É´„ÉÄ„Ç¶„É≥„ÇíÈñãÂßã„Åó„Åæ„Åô„ÄÇ`,
              );

              // ‚óÜ „Åì„Åì„Åã„Çâ10Áßí„ÅÆ„ÇØ„Éº„É´„ÉÄ„Ç¶„É≥„Çø„Ç§„Éû„Éº„ÇíÈñãÂßã
              setTimeout(() => {
                console.log(
                  `„Éó„É¨„Ç§„É§„Éº${this.playerId}: „ÇØ„Éº„É´„ÉÄ„Ç¶„É≥ÁµÇ‰∫Ü„ÄÇÊñ∞„Åó„ÅÑ„Ç≤„Éº„É†„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰ΩúÊàê„Åó„Åæ„Åô„ÄÇ`,
                );

                // Êñ∞„Åó„ÅÑWASMGame„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰ΩúÊàê
                this.wasmgame = this.recreateWasmGame();

                // window„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇÇÊõ¥Êñ∞
                if (this.playerId === 1) {
                  window.game1 = this.wasmgame;
                } else if (this.playerId === 2) {
                  window.game2 = this.wasmgame;
                }

                // ‚óÜ „Éï„É©„Ç∞„ÇíËß£Èô§„Åó„Å¶„Ç≠„ÉºÂÖ•Âäõ„ÇíÂèó„Åë‰ªò„Åë„Çã„Çà„ÅÜ„Å´„Åô„Çã
                setIsProcessingFinishTask(this.playerId, false);

                console.log(
                  `„Éó„É¨„Ç§„É§„Éº${this.playerId}: „Ç≤„Éº„É†„É™„Çª„ÉÉ„ÉàÂÆå‰∫Ü„ÄÇisGameStarted: ${this.wasmgame.isGameStarted()}`,
                );
              }, 10000); // 10Áßí„ÅÆ„ÇØ„Éº„É´„ÉÄ„Ç¶„É≥
            }
          }, 200); // 200„Éü„É™Áßí„Åî„Å®„Å´„ÉÅ„Çß„ÉÉ„ÇØ
        }

        startTimerDisplay() {
          this.displayTimer = setInterval(() => {
            if (this.gameStartTime) {
              const elapsed = Date.now() - this.gameStartTime;
              const remaining = Math.max(0, this.gameDuration - elapsed);
              const minutes = Math.floor(remaining / 60000);
              const seconds = Math.floor((remaining % 60000) / 1000);
              const timeString = `${minutes}:${seconds.toString().padStart(2, "0")}`;

              const timerDisplay = document.getElementById(
                `timer-display${this.playerId}`,
              );
              if (timerDisplay) {
                timerDisplay.textContent = timeString;
                if (remaining <= 30000) {
                  // 30Áßí‰ª•‰∏ã„ÅßËµ§Ëâ≤Ë≠¶Âëä
                  timerDisplay.style.color = "#ff4444";
                  timerDisplay.style.backgroundColor = "rgba(255, 68, 68, 0.2)";
                }
              }

              if (remaining === 0 && this.displayTimer) {
                clearInterval(this.displayTimer);
                this.displayTimer = null;
              }
            }
          }, 1000);
        }

        setGameDuration(minutes) {
          this.gameDuration = minutes * 60 * 1000;
          // „Çø„Ç§„Éû„ÉºË°®Á§∫„ÇÇÊõ¥Êñ∞
          const timerDisplay = document.getElementById(
            `timer-display${this.playerId}`,
          );
          if (timerDisplay) {
            timerDisplay.textContent = `${minutes}:00`;
            timerDisplay.style.color = "white";
            timerDisplay.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
          }
        }

        setupRenderer() {
          const canvas = document.getElementById(this.canvasId);
          this.render = Render.create({
            canvas: canvas,
            engine: this.engine,
            options: {
              width: 200,
              height: 800,
              wireframes: false,
              background: "transparent",
              showAngleIndicator: true,
              showVelocity: false,
            },
          });
        }

        createWalls() {
          this.walls = [
            Bodies.rectangle(0, 400, 30, 800, {
              isStatic: true,
              render: { fillStyle: "#444" },
            }),
            Bodies.rectangle(200, 400, 30, 800, {
              isStatic: true,
              render: { fillStyle: "#444" },
            }),
          ];
        }

        createNails() {
          this.nails = [];

          const nailRadius = 2;

          for (let { x, y } of this.nails_index) {
            const nail = Bodies.circle(x, y, nailRadius, {
              isStatic: true,
              render: {
                fillStyle: "#e74c3c",
                strokeStyle: "#c0392b",
                lineWidth: 0.5,
              },
            });

            this.nails.push(nail);
          }
        }

        createTargetZones() {
          // „ÅÇ„Åü„Çä„Ç®„É™„Ç¢ÔºàÁ∑ëÔºâ
          this.winZone = Bodies.rectangle(100, 770, 30, 30, {
            isSensor: true,
            isStatic: true,
            render: {
              fillStyle: "#2ecc71",
              strokeStyle: "#27ae60",
              lineWidth: 2,
              opacity: 0.8,
            },
          });

          // ÈÄöÂ∏∏„Ç®„É™„Ç¢ÔºàËµ§Ôºâ
          this.normalZone = Bodies.rectangle(100, 770, 160, 30, {
            isSensor: true,
            isStatic: true,
            render: {
              fillStyle: "#e74c3c",
              strokeStyle: "#c0392b",
              lineWidth: 1,
              opacity: 0.5,
            },
          });
        }

        setupMouseControl() {
          const mouse = Mouse.create(this.render.canvas);
          this.mouseConstraint = MouseConstraint.create(this.engine, {
            mouse: mouse,
            constraint: {
              stiffness: 0.2,
              render: { visible: false },
            },
          });
        }

        setupEventListeners() {
          // Ë°ùÁ™ÅÊ§úÁü•„Ç§„Éô„É≥„Éà
          Events.on(this.engine, "collisionStart", (event) => {
            this.handleCollisions(event.pairs);
          });
        }

        handleCollisions(pairs) {
          pairs.forEach((pair) => {
            const { bodyA, bodyB } = pair;

            if (bodyA === this.winZone || bodyB === this.winZone) {
              const ball = bodyA === this.winZone ? bodyB : bodyA;

              if (this.fallingBalls.includes(ball)) {
                console.log(
                  `üéâ „Éó„É¨„Ç§„É§„Éº${this.playerId}: „ÅÇ„Åü„ÇäÔºÅÁêÉ„ÅåÂΩì„Åü„Çä„Ç®„É™„Ç¢„ÇíÈÄöÈÅé„Åó„Åæ„Åó„ÅüÔºÅ (Ball ID: ${ball.id}, ‰ΩçÁΩÆ: x=${Math.round(ball.position.x)}, y=${Math.round(ball.position.y)})`,
                );

                this.run_step_with_command("CauseLottery");

                const index = this.fallingBalls.indexOf(ball);
                if (index > -1) {
                  this.fallingBalls.splice(index, 1);
                }
              }
            }
          });
        }

        addToWorld() {
          Composite.add(this.world, [
            ...this.walls,
            ...this.nails,
            this.normalZone,
            this.winZone,
            this.mouseConstraint,
          ]);
        }

        start() {
          Render.run(this.render);
          this.runner = Runner.create();
          Runner.run(this.runner, this.engine);
        }

        launchBall() {
          // Áô∫Â∞ÑÊôÇÂàª„ÇíÊõ¥Êñ∞
          this.lastLaunchTime = Date.now();

          // „Ç≤„Éº„É†Áä∂ÊÖã„Çí„ÉÅ„Çß„ÉÉ„ÇØ
          const gameState = this.wasmgame.getState();
          if (gameState.type === "Uninitialized") {
            console.log(
              `„Éó„É¨„Ç§„É§„Éº${this.playerId}: „Ç≤„Éº„É†„ÅåÊú™ÂàùÊúüÂåñ„ÅÆ„Åü„ÇÅÁêÉ„ÇíÊâì„Å¶„Åæ„Åõ„Çì - StartGame„Ç≥„Éû„É≥„Éâ„Åß„Ç≤„Éº„É†„ÇíÈñãÂßã„Åó„Å¶„Åè„Å†„Åï„ÅÑ`,
            );
            console.log(
              `„Éó„É¨„Ç§„É§„Éº${this.playerId}: ÁèæÂú®„ÅÆ„Ç≤„Éº„É†Áä∂ÊÖã:`,
              gameState,
            );
            return;
          }

          // „Çπ„É≠„ÉÉ„ÉàÂõûËª¢Áä∂ÊÖã„Çí„ÉÅ„Çß„ÉÉ„ÇØ
          if (this.wasmgame.isSlotCurrentlySpinning()) {
            console.log(
              `„Éó„É¨„Ç§„É§„Éº${this.playerId}: „Ç≤„Éº„É†ÂÅ¥„Åß„Çπ„É≠„ÉÉ„ÉàÂõûËª¢‰∏≠„ÅÆ„Åü„ÇÅÁêÉ„ÇíÊâì„Å¶„Åæ„Åõ„Çì - ÂõûËª¢ÁµÇ‰∫Ü„Åæ„ÅßÂæÖÊ©ü`,
            );
            return;
          }

          // „Çπ„É≠„ÉÉ„Éà„ÅåÂÆüÈöõ„Å´ÂõûËª¢‰∏≠„Åã„ÇÇ„ÉÅ„Çß„ÉÉ„ÇØ
          const slotStatus = getSlotStatus(this.playerId);
          if (slotStatus && slotStatus.isSpinning) {
            console.log(
              `„Éó„É¨„Ç§„É§„Éº${this.playerId}: UIÂÅ¥„Åß„Çπ„É≠„ÉÉ„ÉàÂõûËª¢‰∏≠„ÅÆ„Åü„ÇÅÁêÉ„ÇíÊâì„Å¶„Åæ„Åõ„Çì - „Ç≠„É•„ÉºÈï∑: ${slotStatus.queueLength}`,
            );
            return;
          }

          let bigBall = null;

          try {
            bigBall = Bodies.circle(50 + Math.random() * 100, 30, 6, {
              render: {
                fillStyle: "#3498db",
                strokeStyle: "#2980b9",
                lineWidth: 1.5,
              },
              restitution: 0.6,
              friction: 0.3,
            });

            this.fallingBalls.push(bigBall);
            Composite.add(this.world, bigBall);

            this.run_step_with_command("LaunchBall");

            console.log(
              `„Éó„É¨„Ç§„É§„Éº${this.playerId}: Êñ∞„Åó„ÅÑÁêÉ„ÇíËêΩ‰∏ãÈñãÂßã (ID: ${bigBall.id})`,
            );
          } catch (error) {
            console.log(
              `„Éó„É¨„Ç§„É§„Éº${this.playerId}: ÁêÉ„ÅÆÁô∫Â∞Ñ„Å´Â§±Êïó: ${error.message}`,
            );
            return;
          }

          const timeToErase = 10000;

          // timeToErase ms Âæå„Å´„Éú„Éº„É´„ÇíËá™ÂãïÂâäÈô§
          setTimeout(() => {
            // bigBall„ÅåÊ≠£Â∏∏„Å´‰ΩúÊàê„Åï„Çå„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç
            if (bigBall) {
              // „Éú„Éº„É´„ÅåÈÖçÂàó„Å´Â≠òÂú®„Åô„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
              const ballIndex = this.fallingBalls.findIndex(
                (ball) => ball.id === bigBall.id,
              );
              if (ballIndex !== -1) {
                // ÈÖçÂàó„Åã„ÇâÂâäÈô§
                this.fallingBalls.splice(ballIndex, 1);
                // Áâ©ÁêÜ‰∏ñÁïå„Åã„ÇâÂâäÈô§
                Composite.remove(this.world, bigBall);
                console.log(
                  `„Éó„É¨„Ç§„É§„Éº${this.playerId}: ÁêÉ„ÇíËá™ÂãïÂâäÈô§ (ID: ${bigBall.id})`,
                );
              }
            }
          }, timeToErase);
        }

        resetSimulation() {
          this.fallingBalls.forEach((ball) => {
            Composite.remove(this.world, ball);
          });
          this.fallingBalls = [];

          this.run_step_with_command("FinishGame");

          // „Çπ„É≠„ÉÉ„ÉàÁä∂ÊÖã„Å®„Çø„Çπ„ÇØ„Ç≠„É•„Éº„ÇÇ„É™„Çª„ÉÉ„Éà
          if (this.playerId === 1) {
            isSpinning1 = false;
            spinQueue1 = [];
            if (taskQueue1) {
              taskQueue1.clear();
            }
            console.log(
              "„Éó„É¨„Ç§„É§„Éº1: „Çπ„É≠„ÉÉ„ÉàÁä∂ÊÖã„Å®„Çø„Çπ„ÇØ„Ç≠„É•„Éº„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü",
            );
          } else if (this.playerId === 2) {
            isSpinning2 = false;
            spinQueue2 = [];
            if (taskQueue2) {
              taskQueue2.clear();
            }
            console.log(
              "„Éó„É¨„Ç§„É§„Éº2: „Çπ„É≠„ÉÉ„ÉàÁä∂ÊÖã„Å®„Çø„Çπ„ÇØ„Ç≠„É•„Éº„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü",
            );
          }

          console.log(
            `„Éó„É¨„Ç§„É§„Éº${this.playerId}: „Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü`,
          );
        }

        // „Ç≠„ÉºÂÖ•ÂäõÂá¶ÁêÜ
        handleKeyInput(key) {
          if (key === this.keyBinding) {
            this.launchBall();
            console.log(
              `„Éó„É¨„Ç§„É§„Éº${this.playerId}: ${this.keyBinding.toUpperCase()}„Ç≠„Éº„ÅßÁêÉ„ÇíËêΩ‰∏ã`,
            );
          }
        }
      }

      // Global nail arrays
      let nails1 = [];
      let nails2 = [];

      // Global configuration variables
      let config1, config2;
      let game1, game2;
      let outputFunctions1, outputFunctions2;

      async function main() {
        // video-list.json„Çí‰∫ãÂâç„Å´Ë™≠„ÅøËæº„Åø
        await preloadVideoList();

        await init();

        // Initialize nails arrays
        nails1 = [];
        nails2 = [];

        const nails_count = 100;

        for (let i = 0; i < nails_count; i++) {
          {
            const x = 20 + Math.random() * 160;
            const y = 100 + Math.random() * 600;
            nails1.push({ x: x, y: y });
          }

          {
            const x = 20 + Math.random() * 160;
            const y = 100 + Math.random() * 600;
            nails2.push({ x: x, y: y });
          }
        }

        // „Çπ„É≠„ÉÉ„ÉàÁï™Âè∑„ÇíÊõ¥Êñ∞„Åô„ÇãÈñ¢Êï∞
        function updateSlots(playerId, slot) {
          if (playerId === 1) {
            spinTo(slot, reels1);
          } else if (playerId === 2) {
            spinTo(slot, reels2);
          }
        }

        // „Ç≤„Éº„É†Áä∂ÊÖã„ÇíÊõ¥Êñ∞„Åô„ÇãÈñ¢Êï∞
        function updateState(playerId, state, withText = "") {
          if (withText != "") {
            console.log(
              `Player ${playerId} State Updated:`,
              state,
              `with: ${withText}`,
            );
          } else {
            console.log(`Player ${playerId} State Updated:`, state);
          }

          const textOfState = (state) => {
            switch (state.type) {
              case "Normal":
                return `ÁêÉÊï∞: ${state.balls}`;
              case "Rush":
                return `ÁêÉÊï∞: ${state.balls}, „É©„ÉÉ„Ç∑„É•ÁêÉ: ${state.rushBalls}, ÂõûÊï∞: ${state.n}`;
              default:
                return `Êú™ÂàùÊúüÂåñ`;
            }
          };

          const element = document.getElementById(`state${playerId}`);
          const rightPanel = document.getElementById(`right-panel${playerId}`);

          const stateText = textOfState(state);

          if (element && rightPanel) {
            // „Ç≤„Éº„É†„ÅåÈñãÂßã„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            const game = playerId === 1 ? game1 : game2;
            if (!game.wasmgame.isGameStarted()) {
              const startKey = playerId === 1 ? "A" : "L";
              element.textContent = `ÁµÇ‰∫Ü„Åó„Åæ„Åó„Åü\nÁµêÊûú: ${stateText}\n${startKey}„Ç≠„Éº„Åß„Çπ„Çø„Éº„Éà`;
              return;
            }

            element.textContent = stateText;
          }
        }

        function setTemporalyBackGroundVideo(playerId, videoPath) {
          const beforeVideo = document.getElementById(`video${playerId}`);
          const beforeSource = document.getElementById(`source${playerId}`);
          const beforeVideoPath = beforeSource.getAttribute("src") ?? "";

          beforeVideo.removeAttribute("autoplay");
          beforeVideo.removeAttribute("loop");
          beforeVideo.removeAttribute("muted");

          beforeSource.setAttribute("src", videoPath);

          const video = document.getElementById(`video${playerId}`);
          video.play();
          video.addEventListener("ended", () => {
            beforeSource.setAttribute("src", beforeVideoPath);
            beforeVideo.setAttribute("autoplay", "");
            beforeVideo.setAttribute("loop", "");
            beforeVideo.setAttribute("muted", "");
            video.load();
            video.removeEventListener("ended");
          });
        }

        // „Çø„Çπ„ÇØ„Ç≠„É•„Éº„ÇíÂàùÊúüÂåñÔºàupdateStateÈñ¢Êï∞„ÅåÂÆöÁæ©„Åï„Çå„ÅüÂæåÔºâ
        taskQueue1 = new OutputTaskQueue(1, updateState);
        taskQueue2 = new OutputTaskQueue(2, updateState);

        const input1 = new JsInput();

        const input2 = new JsInput();

        outputFunctions1 = {
          default: (transition) => {
            taskQueue1.addTask("default", transition);
          },
          finishGame: (gameState) => {
            setIsProcessingFinishTask(1, true);
            taskQueue1.addTask("finishGame", gameState);
          },
          lotteryNormal: (lotteryResult, slotResult) => {
            taskQueue1.addTask("lotteryNormal", {
              lotteryResult,
              slotResult,
              taskType: "Normal Lottery",
            });
          },
          lotteryIntoRush: (lotteryResult, slotResult) => {
            taskQueue1.addTask("lotteryIntoRush", {
              lotteryResult,
              slotResult,
              taskType: "Into Rush Lottery",
            });
          },
          lotteryRush: (lotteryResult, slotResult) => {
            taskQueue1.addTask("lotteryRush", {
              lotteryResult,
              slotResult,
              taskType: "Rush Lottery",
            });
          },
          lotteryRushContinue: (lotteryResult, slotResult) => {
            taskQueue1.addTask("lotteryRushContinue", {
              lotteryResult,
              slotResult,
              taskType: "Rush Continue",
            });
          },
          startGame: (state) => {
            taskQueue1.changeBackgroundVideo(backgroundVideoPaths.normal);
            updateState(1, state);
          },
        };

        outputFunctions2 = {
          default: (transition) => {
            taskQueue2.addTask("default", transition);
          },
          finishGame: (gameState) => {
            console.log("Finish game");
            setIsProcessingFinishTask(2, true);
            taskQueue2.addTask("finishGame", gameState);
          },
          lotteryNormal: (lotteryResult, slotResult) => {
            taskQueue2.addTask("lotteryNormal", {
              lotteryResult,
              slotResult,
              taskType: "Normal Lottery",
            });
          },
          lotteryIntoRush: (lotteryResult, slotResult) => {
            taskQueue2.addTask("lotteryIntoRush", {
              lotteryResult,
              slotResult,
              taskType: "Into Rush Lottery",
            });
          },
          lotteryRush: (lotteryResult, slotResult) => {
            taskQueue2.addTask("lotteryRush", {
              lotteryResult,
              slotResult,
              taskType: "Rush Lottery",
            });
          },
          lotteryRushContinue: (lotteryResult, slotResult) => {
            taskQueue2.addTask("lotteryRushContinue", {
              lotteryResult,
              slotResult,
              taskType: "Rush Continue",
            });
          },
          startGame: (state) => {
            taskQueue2.changeBackground(backgroundVideoPaths.normal);
            updateState(2, state);
          },
        };

        const output1 = new JsOutput(
          outputFunctions1.default,
          outputFunctions1.finishGame,
          outputFunctions1.startGame,
          outputFunctions1.lotteryNormal,
          outputFunctions1.lotteryIntoRush,
          outputFunctions1.lotteryRush,
          outputFunctions1.lotteryRushContinue,
        );

        const output2 = new JsOutput(
          outputFunctions2.default,
          outputFunctions2.finishGame,
          outputFunctions2.startGame,
          outputFunctions2.lotteryNormal,
          outputFunctions2.lotteryIntoRush,
          outputFunctions2.lotteryRush,
          outputFunctions2.lotteryRushContinue,
        );

        config1 = new Config(
          new BallsConfig(100, 15, 30),
          new Probability(
            new SlotProbability(0.16, 0.3, 0.15),
            new SlotProbability(0.8, 0.3, 0.15),
            new SlotProbability(0.48, 0.2, 0.05),
            new SlotProbability(0.5, 0.25, 0.1),
            (n) => {
              return 0.3 ** (n - 1);
            },
          ),
        );

        config2 = new Config(
          new BallsConfig(100, 15, 30),
          new Probability(
            new SlotProbability(0.16, 0.3, 0.15),
            new SlotProbability(0.8, 0.3, 0.15),
            new SlotProbability(0.48, 0.2, 0.05),
            new SlotProbability(0.5, 0.25, 0.1),
            (n) => {
              return 0.3 ** (n - 1);
            },
          ),
        );

        // 2„Å§„ÅÆ„Ç≤„Éº„É†„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰ΩúÊàê
        const wasmGame1 = new WasmGame(input1, output1, config1);
        const wasmGame2 = new WasmGame(input2, output2, config2);

        // WASMGameÂÜç‰ΩúÊàêÁî®„ÅÆÈñ¢Êï∞
        const recreateWasmGame1 = () => {
          const newInput1 = new JsInput();
          const newOutput1 = new JsOutput(
            outputFunctions1.default,
            outputFunctions1.finishGame,
            outputFunctions1.startGame,
            outputFunctions1.lotteryNormal,
            outputFunctions1.lotteryIntoRush,
            outputFunctions1.lotteryRush,
            outputFunctions1.lotteryRushContinue,
          );
          return new WasmGame(newInput1, newOutput1, config1);
        };

        const recreateWasmGame2 = () => {
          const newInput2 = new JsInput();
          const newOutput2 = new JsOutput(
            outputFunctions2.default,
            outputFunctions2.finishGame,
            outputFunctions2.startGame,
            outputFunctions2.lotteryNormal,
            outputFunctions2.lotteryIntoRush,
            outputFunctions2.lotteryRush,
            outputFunctions2.lotteryRushContinue,
          );
          return new WasmGame(newInput2, newOutput2, config2);
        };

        game1 = new PachinkoGame(
          "canvas1",
          1,
          "a",
          nails1,
          wasmGame1,
          recreateWasmGame1,
        );
        game2 = new PachinkoGame(
          "canvas2",
          2,
          "l",
          nails2,
          wasmGame2,
          recreateWasmGame2,
        );

        // Add method to recreate physics with new nails to PachinkoGame class
        PachinkoGame.prototype.recreatePhysicsWithNewNails = function () {
          console.log(
            `Recreating physics for player ${this.playerId} with new nails`,
          );

          // Remove old nails from world
          this.nails.forEach((nail) => {
            Composite.remove(this.world, nail);
          });

          // Create new nails
          this.createNails();

          // Add new nails to world
          Composite.add(this.world, this.nails);

          console.log(
            `Physics recreated for player ${this.playerId} with ${this.nails.length} nails`,
          );
        };

        // „Ç∞„É≠„Éº„Éê„É´„Ç¢„ÇØ„Çª„Çπ„ÅÆ„Åü„ÇÅwindow„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Å´Ë®≠ÂÆöÔºàWasmGame„Ç§„É≥„Çπ„Çø„É≥„ÇπÔºâ
        window.game1 = wasmGame1;
        window.game2 = wasmGame2;

        // „Éú„Çø„É≥„Åã„ÇâÂëº„Å≥Âá∫„Åï„Çå„ÇãÈñ¢Êï∞
        function launchBall1() {
          game1.launchBall();
        }
        function resetSimulation1() {
          game1.resetSimulation();
        }
        function dropBall2() {
          game2.launchBall();
        }
        function resetSimulation2() {
          game2.resetSimulation();
        }

        // „Ç≤„Éº„É†„ÇíÈñãÂßã

        // game1.run();
        // game2.run();

        // „Ç≠„Éº„Éú„Éº„Éâ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºÔºàÈï∑Êäº„ÅóÂØæÂøúÔºâ
        const pressedKeys = new Set();
        const keyIntervals = new Map(); // „Ç≠„Éº„Åî„Å®„ÅÆ„Ç§„É≥„Çø„Éº„Éê„É´ID„ÇíÁÆ°ÁêÜ
        const lastLaunchTimes = new Map(); // „Ç≠„Éº„Åî„Å®„ÅÆÊúÄÂæå„ÅÆÁô∫Â∞ÑÊôÇÂàª„ÇíÁÆ°ÁêÜ
        const LONG_PRESS_INTERVAL = 700; // 0.7ÁßíÈñìÈöî

        // ÈÄ£ÊâìÂà∂Èôê‰ªò„Åç„ÅÆ„Ç≠„ÉºÂá¶ÁêÜÔºàÂàùÂõûÊäº‰∏ãÊôÇÁî®Ôºâ
        async function handleKeyPress(key) {
          const now = Date.now();
          const lastLaunchTime = lastLaunchTimes.get(key) || 0;

          // 0.7ÁßíÈñìÈöî„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØÔºàÈÄ£ÊâìÂØæÂøúÔºâ
          if (now - lastLaunchTime < LONG_PRESS_INTERVAL) {
            console.log(
              `„Ç≠„Éº ${key} „ÅØ0.7ÁßíÈñìÈöîÂà∂Èôê„Å´„Çà„ÇäÁÑ°Ë¶ñ„Åï„Çå„Åæ„Åó„Åü (ÊÆã„ÇäÊôÇÈñì: ${LONG_PRESS_INTERVAL - (now - lastLaunchTime)}ms)`,
            );
            return;
          }

          // Áô∫Â∞ÑÊôÇÂàª„ÇíÊõ¥Êñ∞
          lastLaunchTimes.set(key, now);

          await executeKeyAction(key);
        }

        // Èï∑Êäº„ÅóÊôÇ„ÅÆ„Ç≠„ÉºÂá¶ÁêÜÔºàÂà∂Èôê„Å™„ÅóÔºâ
        async function handleLongPress(key) {
          await executeKeyAction(key);
        }

        // ÂÆüÈöõ„ÅÆ„Ç≠„Éº„Ç¢„ÇØ„Ç∑„Éß„É≥ÂÆüË°å
        async function executeKeyAction(key) {
          // Configuration keys
          if (key === "f") {
            openConfigModal(1);
            return;
          }
          if (key === "j") {
            openConfigModal(2);
            return;
          }

          // ÈÄöÂ∏∏„ÅÆ„Ç≠„ÉºÂá¶ÁêÜÔºà„Ç≤„Éº„É†ÈñãÂßãÂæå„ÅÆ„ÅøÔºâ
          if (key === game1.keyBinding) {
            console.log(`isProcessingFinishTask1: ${isProcessingFinishTask1}`);

            if (isProcessingFinishTask1) {
              return;
            }

            if (game1.wasmgame.isGameStarted()) {
              game1.handleKeyInput(game1.keyBinding);
            } else {
              console.log(
                `${game1.keyBinding}„Ç≠„Éº„ÅåÊäº„Åï„Çå„Åæ„Åó„Åü„ÄÇgame1.isGameStarted: ${game1.wasmgame.isGameStarted()}`,
              );
              if (!game1.wasmgame.isGameStarted()) {
                console.log("„Éó„É¨„Ç§„É§„Éº1„ÅÆ„Ç≤„Éº„É†„ÇíÈñãÂßã„Åó„Åæ„Åô");
                await game1.startWasmGame();
                return;
              } else {
                console.log("„Éó„É¨„Ç§„É§„Éº1„ÅØÊó¢„Å´„Ç≤„Éº„É†ÈñãÂßãÊ∏à„Åø„Åß„Åô");
              }
            }
          }
          if (key === game2.keyBinding) {
            console.log(`isProcessingFinishTask2: ${isProcessingFinishTask2}`);

            if (isProcessingFinishTask2) {
              return;
            }

            if (game2.wasmgame.isGameStarted()) {
              game2.handleKeyInput(game2.keyBinding);
            } else {
              console.log(
                `${game2.keyBinding}„Ç≠„Éº„ÅåÊäº„Åï„Çå„Åæ„Åó„Åü„ÄÇgame2.isGameStarted: ${game2.wasmgame.isGameStarted()}`,
              );
              if (!game2.wasmgame.isGameStarted()) {
                console.log("„Éó„É¨„Ç§„É§„Éº2„ÅÆ„Ç≤„Éº„É†„ÇíÈñãÂßã„Åó„Åæ„Åô");
                await game2.startWasmGame();
                return;
              } else {
                console.log("„Éó„É¨„Ç§„É§„Éº2„ÅØÊó¢„Å´„Ç≤„Éº„É†ÈñãÂßãÊ∏à„Åø„Åß„Åô");
              }
            }
          }
        }

        document.addEventListener("keydown", (event) => {
          const key = event.key.toLowerCase();

          // Êó¢„Å´Êäº„Åï„Çå„Å¶„ÅÑ„Çã„Ç≠„Éº„ÅÆÂ†¥Âêà„ÅØÁÑ°Ë¶ñÔºà„É™„Éî„Éº„Éà„Ç§„Éô„É≥„ÉàÈò≤Ê≠¢Ôºâ
          if (pressedKeys.has(key)) {
            return;
          }

          pressedKeys.add(key);

          // ÊúÄÂàù„ÅÆ„Ç≠„ÉºÂÖ•Âäõ„ÇíÂç≥Â∫ß„Å´ÂÆüË°åÔºàÈÄ£ÊâìÂà∂Èôê‰ªò„ÅçÔºâ
          handleKeyPress(key).catch(console.error);

          // Èï∑Êäº„ÅóÁî®„ÅÆ„Ç§„É≥„Çø„Éº„Éê„É´„ÇíË®≠ÂÆö
          if (key === game1.keyBinding || key === game2.keyBinding) {
            const intervalId = setInterval(() => {
              if (pressedKeys.has(key)) {
                console.log(`Long press: ${key}`);
                handleLongPress(key).catch(console.error);
              } else {
                clearInterval(intervalId);
                keyIntervals.delete(key);
              }
            }, LONG_PRESS_INTERVAL);

            keyIntervals.set(key, intervalId);
          }
        });

        document.addEventListener("keyup", (event) => {
          const key = event.key.toLowerCase();
          pressedKeys.delete(key);

          // „Ç§„É≥„Çø„Éº„Éê„É´„Çí„ÇØ„É™„Ç¢
          if (keyIntervals.has(key)) {
            clearInterval(keyIntervals.get(key));
            keyIntervals.delete(key);
          }
        });

        // „Ç¶„Ç£„É≥„Éâ„Ç¶„Éï„Ç©„Éº„Ç´„ÇπÂ§ñ„ÇåÊôÇ„Å´„Ç≠„ÉºÁä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
        window.addEventListener("blur", () => {
          console.log("Window lost focus, resetting key states");
          pressedKeys.clear();
          lastLaunchTimes.clear();

          // ÂÖ®„Å¶„ÅÆ„Ç§„É≥„Çø„Éº„Éê„É´„Çí„ÇØ„É™„Ç¢
          keyIntervals.forEach((intervalId, key) => {
            clearInterval(intervalId);
          });
          keyIntervals.clear();
        });

        // „Éö„Éº„Ç∏„ÅÆÂèØË¶ñÊÄß„ÅåÂ§â„Çè„Å£„ÅüÊôÇ„ÇÇ„É™„Çª„ÉÉ„Éà
        document.addEventListener("visibilitychange", () => {
          if (document.hidden) {
            console.log("Page hidden, resetting key states");
            pressedKeys.clear();
            lastLaunchTimes.clear();

            keyIntervals.forEach((intervalId, key) => {
              clearInterval(intervalId);
            });
            keyIntervals.clear();
          }
        });

        // „Éá„Éê„ÉÉ„Ç∞Áî®ÔºöÈï∑Êäº„ÅóÁä∂ÊÖãÁ¢∫Ë™çÈñ¢Êï∞
        window.debugKeyStates = () => {
          console.log("=== „Ç≠„ÉºÁä∂ÊÖã„Éá„Éê„ÉÉ„Ç∞ ===");
          console.log("Êäº„Åï„Çå„Å¶„ÅÑ„Çã„Ç≠„Éº:", Array.from(pressedKeys));
          console.log("Èï∑Êäº„Åó„Ç§„É≥„Çø„Éº„Éê„É´:", Array.from(keyIntervals.keys()));
          console.log("„Ç§„É≥„Çø„Éº„Éê„É´Êï∞:", keyIntervals.size);
          console.log("ÊúÄÂæå„ÅÆÁô∫Â∞ÑÊôÇÂàª:", Object.fromEntries(lastLaunchTimes));
          const now = Date.now();
          lastLaunchTimes.forEach((time, key) => {
            const elapsed = now - time;
            console.log(
              `„Ç≠„Éº ${key}: ${elapsed}msÂâç„Å´Áô∫Â∞Ñ (Ê¨°ÂõûÁô∫Â∞Ñ„Åæ„Åß${Math.max(0, LONG_PRESS_INTERVAL - elapsed)}ms)`,
            );
          });
        };

        window.clearAllKeyStates = () => {
          console.log("ÂÖ®„Å¶„ÅÆ„Ç≠„ÉºÁä∂ÊÖã„ÇíÂº∑Âà∂„ÇØ„É™„Ç¢");
          pressedKeys.clear();
          lastLaunchTimes.clear();
          keyIntervals.forEach((intervalId, key) => {
            clearInterval(intervalId);
          });
          keyIntervals.clear();
        };

        // ËÉåÊôØÂãïÁîª„ÇíË®≠ÂÆö„Åô„Çã„Åü„ÇÅ„ÅÆ„Éò„É´„Éë„ÉºÈñ¢Êï∞
        window.setBackgroundVideo = (playerId, videoSrc) => {
          const video = document.getElementById(`video${playerId}`);
          if (video && videoSrc) {
            video.src = videoSrc;
            video.load(); // Êñ∞„Åó„ÅÑ„ÇΩ„Éº„Çπ„ÇíË™≠„ÅøËæº„Åø
            console.log(`Player ${playerId}„ÅÆËÉåÊôØÂãïÁîª„ÇíË®≠ÂÆö: ${videoSrc}`);
          }
        };

        // ‰∏°Êñπ„ÅÆ„Éó„É¨„Ç§„É§„Éº„Å´Âêå„ÅòÂãïÁîª„ÇíË®≠ÂÆö„Åô„Çã„Éò„É´„Éë„ÉºÈñ¢Êï∞
        window.setBackgroundVideoForBoth = (videoSrc) => {
          window.setBackgroundVideo(1, videoSrc);
          window.setBackgroundVideo(2, videoSrc);
        };

        // ÂàùÊúüÁä∂ÊÖã„ÅÆË°®Á§∫„ÇíÊõ¥Êñ∞
        const element1 = document.getElementById("state1");
        const element2 = document.getElementById("state2");
        if (element1) element1.textContent = "A„Ç≠„Éº„Åß„Çπ„Çø„Éº„Éà";
        if (element2) element2.textContent = "L„Ç≠„Éº„Åß„Çπ„Çø„Éº„Éà";

        console.log("üéÆ „Éá„É•„Ç¢„É´„Éë„ÉÅ„É≥„Ç≥„Ç≤„Éº„É†Ê∫ñÂÇôÂÆå‰∫ÜÔºÅ");
        console.log(
          "„Éó„É¨„Ç§„É§„Éº1: A„Ç≠„Éº„ÅßÁêÉ„ÇíËêΩ„Å®„Åô (Èï∑Êäº„ÅóÂØæÂøú - 0.7ÁßíÈñìÈöî), F„Ç≠„Éº„ÅßË®≠ÂÆöÁîªÈù¢",
        );
        console.log(
          "„Éó„É¨„Ç§„É§„Éº2: „ÄÅL„Ç≠„Éº„ÅßÁêÉ„ÇíËêΩ„Å®„Åô (Èï∑Êäº„ÅóÂØæÂøú - 0.7ÁßíÈñìÈöî), J„Ç≠„Éº„ÅßË®≠ÂÆöÁîªÈù¢",
        );
        console.log(
          "„Éá„Éê„ÉÉ„Ç∞„Ç≥„Éû„É≥„Éâ: window.debugKeyStates(), window.clearAllKeyStates()",
        );
      }

      // „Çø„Ç§„Éû„ÉºË®≠ÂÆöÈñ¢Êï∞
      function toggleTimeSettings(playerId) {
        const settings = document.getElementById(`time-settings${playerId}`);
        settings.classList.toggle("visible");
      }

      function applyTimeSettings(playerId) {
        const input = document.getElementById(`timer-input${playerId}`);
        const minutes = parseInt(input.value);

        if (minutes < 1 || minutes > 60) {
          alert("Please enter a time between 1 and 60 minutes.");
          return;
        }

        // ÂØæÂøú„Åô„Çã„Ç≤„Éº„É†„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂèñÂæó„Åó„Å¶ÊôÇÈñì„ÇíË®≠ÂÆö
        const game = playerId === 1 ? game1 : game2;
        if (game) {
          game.setGameDuration(minutes);
        }

        // Ë®≠ÂÆö„Éë„Éç„É´„ÇíÈñâ„Åò„Çã
        toggleTimeSettings(playerId);
      }

      // Configuration System
      let configCanvases = {};
      let configNails = { 1: [], 2: [] };
      let configContexts = {};

      function initializeConfigSystem() {
        // Initialize nail canvases
        for (let playerId = 1; playerId <= 2; playerId++) {
          const canvas = document.getElementById(`nail-canvas-${playerId}`);
          const ctx = canvas.getContext("2d");
          configCanvases[playerId] = canvas;
          configContexts[playerId] = ctx;

          // Scale canvas for crisp rendering
          const rect = canvas.getBoundingClientRect();
          canvas.width = 200;
          canvas.height = 400;
          ctx.scale(1, 1);

          // Add click event listener
          canvas.addEventListener("click", (event) => {
            handleNailCanvasClick(event, playerId);
          });

          // Initialize with current nails
          if (playerId === 1) {
            configNails[1] = [...nails1];
          } else {
            configNails[2] = [...nails2];
          }
        }

        // Add event listeners for all buttons
        for (let playerId = 1; playerId <= 2; playerId++) {
          // Close button
          document
            .getElementById(`config-close-${playerId}`)
            .addEventListener("click", () => {
              closeConfigModal(playerId);
            });

          // Nail control buttons
          document
            .getElementById(`clear-nails-${playerId}`)
            .addEventListener("click", () => {
              clearAllNails(playerId);
            });

          document
            .getElementById(`random-nails-${playerId}`)
            .addEventListener("click", () => {
              randomNails(playerId);
            });

          document
            .getElementById(`remove-last-nail-${playerId}`)
            .addEventListener("click", () => {
              removeLastNail(playerId);
            });

          // Data control buttons
          document
            .getElementById(`export-nail-data-${playerId}`)
            .addEventListener("click", () => {
              exportNailData(playerId);
            });

          document
            .getElementById(`import-nail-data-${playerId}`)
            .addEventListener("click", () => {
              importNailData(playerId);
            });

          // Apply configuration button
          document
            .getElementById(`apply-config-${playerId}`)
            .addEventListener("click", () => {
              applyConfig(playerId);
            });

          // Modal background click to close
          const modal = document.getElementById(`config-modal-${playerId}`);
          modal.addEventListener("click", (event) => {
            if (event.target === modal) {
              closeConfigModal(playerId);
            }
          });
        }

        // Keyboard event listeners
        document.addEventListener("keydown", (event) => {
          // ESC key to close any open modal
          if (event.key === "Escape") {
            for (let pid = 1; pid <= 2; pid++) {
              const modal = document.getElementById(`config-modal-${pid}`);
              if (modal.classList.contains("visible")) {
                closeConfigModal(pid);
              }
            }
          }
        });
      }

      function openConfigModal(playerId) {
        console.log(`Opening config modal for player ${playerId}`);

        // Load current configuration values
        loadCurrentConfig(playerId);

        // Update nail canvas
        updateNailCanvas(playerId);

        // Show modal
        const modal = document.getElementById(`config-modal-${playerId}`);
        modal.classList.add("visible");

        // Prevent body scroll
        document.body.style.overflow = "hidden";
      }

      function closeConfigModal(playerId) {
        console.log(`Closing config modal for player ${playerId}`);

        const modal = document.getElementById(`config-modal-${playerId}`);
        modal.classList.remove("visible");

        // Restore body scroll
        document.body.style.overflow = "";
      }

      function loadCurrentConfig(playerId) {
        // Get current config from game
        const game = playerId === 1 ? game1 : game2;
        const currentConfig = playerId === 1 ? config1 : config2;

        // Load balls config
        document.getElementById(`config-init-balls-${playerId}`).value =
          currentConfig.balls.initBalls;
        document.getElementById(`config-incremental-balls-${playerId}`).value =
          currentConfig.balls.incrementalBalls;
        document.getElementById(`config-incremental-rush-${playerId}`).value =
          currentConfig.balls.incrementalRush;

        // Load probability config
        document.getElementById(`config-normal-win-${playerId}`).value =
          currentConfig.probability.normal.win;
        document.getElementById(`config-normal-fake-win-${playerId}`).value =
          currentConfig.probability.normal.fakeWin;
        document.getElementById(`config-normal-fake-lose-${playerId}`).value =
          currentConfig.probability.normal.fakeLose;

        document.getElementById(`config-rush-win-${playerId}`).value =
          currentConfig.probability.rush.win;
        document.getElementById(`config-rush-fake-win-${playerId}`).value =
          currentConfig.probability.rush.fakeWin;
        document.getElementById(`config-rush-fake-lose-${playerId}`).value =
          currentConfig.probability.rush.fakeLose;

        document.getElementById(`config-rush-continue-win-${playerId}`).value =
          currentConfig.probability.rushContinue.win;
        document.getElementById(
          `config-rush-continue-fake-win-${playerId}`,
        ).value = currentConfig.probability.rushContinue.fakeWin;
        document.getElementById(
          `config-rush-continue-fake-lose-${playerId}`,
        ).value = currentConfig.probability.rushContinue.fakeLose;

        // Load nail data
        const currentNails = playerId === 1 ? nails1 : nails2;
        configNails[playerId] = [...currentNails];
        document.getElementById(`nail-data-${playerId}`).value = JSON.stringify(
          currentNails,
          null,
          2,
        );
      }

      function updateNailCanvas(playerId) {
        const ctx = configContexts[playerId];
        const canvas = configCanvases[playerId];

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw background
        ctx.fillStyle = "#2a2a2a";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw walls
        ctx.fillStyle = "#444";
        ctx.fillRect(0, 0, 15, canvas.height);
        ctx.fillRect(canvas.width - 15, 0, 15, canvas.height);

        // Draw nails
        ctx.fillStyle = "#e74c3c";
        ctx.strokeStyle = "#c0392b";
        ctx.lineWidth = 0.5;

        for (const nail of configNails[playerId]) {
          const x = nail.x * (canvas.width / 200);
          const y = nail.y * (canvas.height / 800);

          ctx.beginPath();
          ctx.arc(x, y, 2, 0, 2 * Math.PI);
          ctx.fill();
          ctx.stroke();
        }
      }

      function handleNailCanvasClick(event, playerId) {
        const canvas = configCanvases[playerId];
        const rect = canvas.getBoundingClientRect();
        const x = ((event.clientX - rect.left) / rect.width) * 200;
        const y = ((event.clientY - rect.top) / rect.height) * 800;

        // Check if clicking near an existing nail (remove it)
        let nailRemoved = false;
        for (let i = configNails[playerId].length - 1; i >= 0; i--) {
          const nail = configNails[playerId][i];
          const distance = Math.sqrt((nail.x - x) ** 2 + (nail.y - y) ** 2);
          if (distance < 10) {
            configNails[playerId].splice(i, 1);
            nailRemoved = true;
            break;
          }
        }

        // If no nail was removed, add a new one
        if (!nailRemoved && x >= 20 && x <= 180 && y >= 50 && y <= 750) {
          configNails[playerId].push({ x: x, y: y });
        }

        // Update canvas and data
        updateNailCanvas(playerId);
        updateNailData(playerId);
      }

      function updateNailData(playerId) {
        document.getElementById(`nail-data-${playerId}`).value = JSON.stringify(
          configNails[playerId],
          null,
          2,
        );
      }

      function clearAllNails(playerId) {
        configNails[playerId] = [];
        updateNailCanvas(playerId);
        updateNailData(playerId);
      }

      function randomNails(playerId) {
        configNails[playerId] = [];
        const nailCount = 80 + Math.floor(Math.random() * 40);

        for (let i = 0; i < nailCount; i++) {
          const x = 20 + Math.random() * 160;
          const y = 100 + Math.random() * 600;
          configNails[playerId].push({ x: x, y: y });
        }

        updateNailCanvas(playerId);
        updateNailData(playerId);
      }

      function removeLastNail(playerId) {
        if (configNails[playerId].length > 0) {
          configNails[playerId].pop();
          updateNailCanvas(playerId);
          updateNailData(playerId);
        }
      }

      function exportNailData(playerId) {
        const data = JSON.stringify(configNails[playerId], null, 2);
        document.getElementById(`nail-data-${playerId}`).value = data;

        // Copy to clipboard
        navigator.clipboard
          .writeText(data)
          .then(() => {
            alert("Nail data copied to clipboard!");
          })
          .catch(() => {
            alert("Nail data exported to text area");
          });
      }

      function importNailData(playerId) {
        const data = document.getElementById(`nail-data-${playerId}`).value;
        try {
          const nails = JSON.parse(data);
          if (Array.isArray(nails)) {
            configNails[playerId] = nails.filter(
              (nail) =>
                nail &&
                typeof nail.x === "number" &&
                typeof nail.y === "number",
            );
            updateNailCanvas(playerId);
            updateNailData(playerId);
            alert("Nail data imported successfully!");
          } else {
            alert(
              "Invalid data format. Please provide an array of nail objects.",
            );
          }
        } catch (error) {
          alert("Invalid JSON format. Please check your data.");
        }
      }

      async function applyConfig(playerId) {
        try {
          // Get configuration values
          const initBalls = parseInt(
            document.getElementById(`config-init-balls-${playerId}`).value,
          );
          const incrementalBalls = parseInt(
            document.getElementById(`config-incremental-balls-${playerId}`)
              .value,
          );
          const incrementalRush = parseInt(
            document.getElementById(`config-incremental-rush-${playerId}`)
              .value,
          );

          const normalWin = parseFloat(
            document.getElementById(`config-normal-win-${playerId}`).value,
          );
          const normalFakeWin = parseFloat(
            document.getElementById(`config-normal-fake-win-${playerId}`).value,
          );
          const normalFakeLose = parseFloat(
            document.getElementById(`config-normal-fake-lose-${playerId}`)
              .value,
          );

          const intoRushWin = parseFloat(
            document.getElementById(`config-into-rush-win-${playerId}`).value,
          );
          const intoRushFakeWin = parseFloat(
            document.getElementById(`config-into-rush-fake-win-${playerId}`)
              .value,
          );
          const intoRushFakeLose = parseFloat(
            document.getElementById(`config-into-rush-fake-lose-${playerId}`)
              .value,
          );

          const rushWin = parseFloat(
            document.getElementById(`config-rush-win-${playerId}`).value,
          );
          const rushFakeWin = parseFloat(
            document.getElementById(`config-rush-fake-win-${playerId}`).value,
          );
          const rushFakeLose = parseFloat(
            document.getElementById(`config-rush-fake-lose-${playerId}`).value,
          );

          const rushContinueWin = parseFloat(
            document.getElementById(`config-rush-continue-win-${playerId}`)
              .value,
          );
          const rushContinueFakeWin = parseFloat(
            document.getElementById(`config-rush-continue-fake-win-${playerId}`)
              .value,
          );
          const rushContinueFakeLose = parseFloat(
            document.getElementById(
              `config-rush-continue-fake-lose-${playerId}`,
            ).value,
          );

          // Apply nail configuration
          if (playerId === 1) {
            nails1 = [...configNails[1]];
          } else {
            nails2 = [...configNails[2]];
          }

          // Create new configuration
          const newBallsConfig = new BallsConfig(
            initBalls,
            incrementalBalls,
            incrementalRush,
          );
          const newProbability = new Probability(
            new SlotProbability(normalWin, normalFakeWin, normalFakeLose),
            new SlotProbability(intoRushWin, intoRushFakeWin, intoRushFakeLose),
            new SlotProbability(rushWin, rushFakeWin, rushFakeLose),
            new SlotProbability(
              rushContinueWin,
              rushContinueFakeWin,
              rushContinueFakeLose,
            ),
            (n) => {
              return 0.6 ** (n - 1);
            },
          );
          const newConfig = new Config(newBallsConfig, newProbability);

          // Update global config variables
          if (playerId === 1) {
            config1 = newConfig;
          } else {
            config2 = newConfig;
          }

          // Recreate the game instances with new configuration
          console.log(`Applying new configuration for player ${playerId}`);

          if (playerId === 1) {
            // End current game if running
            if (game1 && game1.wasmgame.isGameStarted()) {
              await game1.endGame();
            }

            // Recreate WASM game with new config
            const newInput1 = new JsInput();
            const newOutput1 = new JsOutput(
              outputFunctions1.default,
              outputFunctions1.finishGame,
              outputFunctions1.startGame,
              outputFunctions1.lotteryNormal,
              outputFunctions1.lotteryRush,
              outputFunctions1.lotteryRushContinue,
            );
            window.game1 = new WasmGame(newInput1, newOutput1, newConfig);
            game1.wasmgame = window.game1;

            // Update physical game with new nails
            game1.nails_index = nails1;
            game1.recreatePhysicsWithNewNails();
          } else {
            // End current game if running
            if (game2 && game2.wasmgame.isGameStarted()) {
              await game2.endGame();
            }

            // Recreate WASM game with new config
            const newInput2 = new JsInput();
            const newOutput2 = new JsOutput(
              outputFunctions2.default,
              outputFunctions2.finishGame,
              outputFunctions2.startGame,
              outputFunctions2.lotteryNormal,
              outputFunctions2.lotteryRush,
              outputFunctions2.lotteryRushContinue,
            );
            window.game2 = new WasmGame(newInput2, newOutput2, newConfig);
            game2.wasmgame = window.game2;

            // Update physical game with new nails
            game2.nails_index = nails2;
            game2.recreatePhysicsWithNewNails();
          }

          console.log(
            `Configuration applied successfully for player ${playerId}`,
          );
          alert(
            `Player ${playerId} configuration applied! New game created with updated settings.`,
          );

          // Close the modal
          closeConfigModal(playerId);
        } catch (error) {
          console.error(
            `Error applying configuration for player ${playerId}:`,
            error,
          );
          alert(`Error applying configuration: ${error.message}`);
        }
      }

      main().then(() => {
        // Initialize configuration system after main completes
        setTimeout(() => {
          initializeConfigSystem();
        }, 100);
      });
    </script>
  </body>
</html>
