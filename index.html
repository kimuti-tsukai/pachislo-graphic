<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ãƒ‘ãƒã‚¹ãƒ­</title>
    <style>
      body {
        font-family: "Helvetica Neue", Arial, sans-serif;
        display: flex;
        flex-direction: column;
        gap: 18px;
        align-items: center;
        padding: 32px;
        background: #111;
        color: #eee;
      }

      .game-container {
        display: flex;
        gap: 80px;
        justify-content: center;
        align-items: flex-start;
      }

      .game-unit {
        display: flex;
        gap: 20px;
        align-items: flex-start;
      }

      .canvas-container {
        flex: 0 0 auto;
      }

      canvas {
        border: 2px solid #444;
        background-color: #2a2a2a;
      }

      .right-panel {
        flex: 0 0 250px;
        padding: 20px;
        position: relative;
        overflow: hidden;
      }

      .right-panel video {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        z-index: -1;
      }

      .right-panel > * {
        position: relative;
        z-index: 1;
      }

      .state {
        padding: 20px;
        /*background-color: rgba(0, 0, 0, 0.7);*/
        color: white;
        border-radius: 8px;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        font-weight: bold;
        margin-bottom: 10px;
      }

      .slot-container {
        margin-top: 300px;
        justify-content: center;
        align-items: center;
        display: flex;
        gap: 10px;
      }

      .slot-num {
        height: 100px;
        font-size: 50px;
        text-align: center;
        flex: 1;
      }

      :root {
        --reel-width: 120px;
        --cell-height: 64px; /* 1ã¤ã®æ•°å­—ã‚»ãƒ«ã®é«˜ã• */
        --visible-cells: 3; /* è¦‹ãˆã‚‹ã‚»ãƒ«æ•°ï¼ˆä¸­å¤®ï¼‹ä¸Šä¸‹ã®è¦‹åˆ‡ã‚Œï¼‰ */
      }

      .slot-wrap {
        display: flex;
        gap: 10px;
        justify-content: center;
        /*background-color: rgba(0, 0, 0, 0.6);*/
        padding: 15px;
        border-radius: 8px;
      }

      .reel {
        width: var(--reel-width);
        height: calc(
          var(--cell-height) * 1
        ); /* è¦‹ã›ãŸã„ä¸­å¤®ã®é«˜ã•ï¼ˆä¸­å¤®ã‚»ãƒ«1ã¤åˆ†ï¼‰ */
        position: relative;
        overflow: hidden;
        border-radius: 12px;
        background: linear-gradient(180deg, #222, #0f0f12);
        box-shadow:
          0 6px 18px rgba(0, 0, 0, 0.7),
          inset 0 2px 0 rgba(255, 255, 255, 0.02);
        display: flex;
        align-items: center;
        justify-content: center;
      }

      /* ä¸­å¤®ã®æ•°å­—ã‚’å¤§ããè¦‹ã›ã‚‹ãŸã‚ã€å†…å´ã«ä½™ç™½ã‚’æŒãŸã›ãŸã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼é ˜åŸŸã‚’ç”¨æ„ */
      .reel-viewport {
        position: relative;
        width: 100%;
        height: calc(var(--cell-height) * var(--visible-cells));
        top: calc(var(--cell-height) * -1); /* ä¸­å¤®ã‚»ãƒ«ã‚’å¯è¦–é ˜åŸŸã®ä¸­å¤®ã« */
        overflow: hidden;
      }

      .reel-list {
        /* ãƒªãƒ¼ãƒ«ã®è¦ç´ ä¸€è¦§ */
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
      }

      .cell {
        width: 100%;
        height: var(--cell-height);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 32px;
        font-weight: 700;
        color: #fff;
      }

      /* ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã§ä¸Šä¸‹ã‚’ã¼ã‹ã™ */
      .reel:before,
      .reel:after {
        content: "";
        position: absolute;
        left: 0;
        right: 0;
        height: calc(var(--cell-height) * 0.4);
        pointer-events: none;
        z-index: 2;
      }
      .reel:before {
        top: 0;
        background: linear-gradient(
          to bottom,
          rgba(17, 17, 17, 0.9) 0%,
          transparent 100%
        );
      }
      .reel:after {
        bottom: 0;
        background: linear-gradient(
          to top,
          rgba(17, 17, 17, 0.9) 0%,
          transparent 100%
        );
      }

      /* ä¸­å¤®ãƒ•ãƒ¬ãƒ¼ãƒ ã®å¼·èª¿ */
      .center-frame {
        position: absolute;
        top: 50%;
        left: 50%;
        width: calc(100% - 8px);
        height: calc(var(--cell-height) - 8px);
        transform: translate(-50%, -50%);
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-radius: 6px;
        pointer-events: none;
        z-index: 3;
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <!-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1 -->
      <div class="game-unit">
        <div class="canvas-container">
          <canvas id="canvas1"></canvas>
        </div>

        <div class="right-panel" id="right-panel1">
          <video id="video1" autoplay muted loop playsinline></video>

          <div class="state" id="state1">Uninitialized</div>

          <div class="slot-wrap" id="slot">
            <!-- 3ã¤ã®ãƒªãƒ¼ãƒ«ã‚’ç”¨æ„ -->
            <div class="reel" data-index="0">
              <div class="reel-viewport">
                <div class="reel-list"></div>
              </div>
              <div class="center-frame"></div>
            </div>

            <div class="reel" data-index="1">
              <div class="reel-viewport">
                <div class="reel-list"></div>
              </div>
              <div class="center-frame"></div>
            </div>

            <div class="reel" data-index="2">
              <div class="reel-viewport">
                <div class="reel-list"></div>
              </div>
              <div class="center-frame"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2 -->
      <div class="game-unit">
        <div class="canvas-container">
          <canvas id="canvas2"></canvas>
        </div>

        <div class="right-panel" id="right-panel2">
          <video id="video2" autoplay muted loop playsinline></video>

          <div class="state" id="state2">Uninitialized</div>

          <div class="slot-wrap" id="slot2">
            <!-- 3ã¤ã®ãƒªãƒ¼ãƒ«ã‚’ç”¨æ„ -->
            <div class="reel" data-index="0">
              <div class="reel-viewport">
                <div class="reel-list"></div>
              </div>
              <div class="center-frame"></div>
            </div>

            <div class="reel" data-index="1">
              <div class="reel-viewport">
                <div class="reel-list"></div>
              </div>
              <div class="center-frame"></div>
            </div>

            <div class="reel" data-index="2">
              <div class="reel-viewport">
                <div class="reel-list"></div>
              </div>
              <div class="center-frame"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>

    <script type="module">
      const REPEAT = 16; // æ•°å­—åˆ—ã‚’ä½•å›ç¹°ã‚Šè¿”ã™ã‹
      const numbers = [...Array(10).keys()].reverse(); // [9,8,7,6,5,4,3,2,1,0]
      const reels1 = Array.from(document.querySelectorAll("#slot .reel"));
      const reels2 = Array.from(document.querySelectorAll("#slot2 .reel"));
      const cellH =
        parseInt(
          getComputedStyle(document.documentElement).getPropertyValue(
            "--cell-height",
          ),
        ) || 64;

      // ã‚¿ã‚¹ã‚¯ã‚­ãƒ¥ãƒ¼ã‚·ã‚¹ãƒ†ãƒ 
      class OutputTaskQueue {
        constructor(playerId, updateStateFunction) {
          this.playerId = playerId;
          this.queue = [];
          this.isProcessing = false;
          this.updateState = updateStateFunction;
        }

        // ã‚¿ã‚¹ã‚¯ã‚’ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ 
        addTask(taskType, taskData) {
          console.log(
            `Player ${this.playerId} task queued: ${taskType}`,
            taskData,
          );
          this.queue.push({
            type: taskType,
            data: taskData,
            timestamp: Date.now(),
          });
          this.processNext();
        }

        // æ¬¡ã®ã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†
        async processNext() {
          if (this.isProcessing || this.queue.length === 0) {
            return;
          }

          this.isProcessing = true;
          const task = this.queue.shift();
          console.log(`Player ${this.playerId} processing task: ${task.type}`);

          try {
            await this.executeTask(task);
          } catch (error) {
            console.error(`Player ${this.playerId} task error:`, error);
          }

          this.isProcessing = false;

          // æ¬¡ã®ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Œã°ç¶šè¡Œ
          if (this.queue.length > 0) {
            setTimeout(() => this.processNext(), 100);
          }
        }

        // ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
        async executeTask(task) {
          const { type, data } = task;

          switch (type) {
            case "default":
              this.executeDefaultTask(data);
              break;
            case "finishGame":
              this.executeFinishGameTask(data);
              break;
            case "lotteryNormal":
            case "lotteryRush":
            case "lotteryRushContinue":
              await this.executeLotteryTask(data);
              break;
            default:
              console.warn(`Unknown task type: ${type}`);
          }
        }

        // defaultã‚¿ã‚¹ã‚¯ã®å®Ÿè¡Œ
        executeDefaultTask(transition) {
          console.log(`P${this.playerId} Transition:`, transition);
          if (transition.after) {
            this.updateState(this.playerId, transition.after);
          }
        }

        // finishGameã‚¿ã‚¹ã‚¯ã®å®Ÿè¡Œ
        executeFinishGameTask(gameState) {
          console.log(`P${this.playerId} Game Finished:`, gameState);
          this.updateState(this.playerId, gameState);
        }

        // æŠ½é¸ã‚¿ã‚¹ã‚¯ã®å®Ÿè¡Œï¼ˆã‚¹ãƒ­ãƒƒãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†ã‚’å¾…ã¤ï¼‰
        async executeLotteryTask(data) {
          const { lotteryResult, slotResult, taskType } = data;
          console.log(
            `P${this.playerId} ${taskType}:`,
            lotteryResult,
            slotResult,
          );

          const slot = slotResult[1] || slotResult[0];

          // ã‚¹ãƒ­ãƒƒãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹å§‹
          if (this.playerId === 1) {
            spinTo1(slot);
          } else {
            spinTo2(slot);
          }

          // ã‚¹ãƒ­ãƒƒãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†ã‚’å¾…ã¤
          await this.waitForSlotAnimation();

          console.log(
            `Player ${this.playerId} slot animation completed, task finished`,
          );
        }

        // ã‚¹ãƒ­ãƒƒãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†ã‚’å¾…ã¤
        waitForSlotAnimation() {
          return new Promise((resolve) => {
            const checkInterval = setInterval(() => {
              const status = getSlotStatus(this.playerId);
              if (!status.isSpinning && status.queueLength === 0) {
                clearInterval(checkInterval);

                // ã‚²ãƒ¼ãƒ å´ã®ã‚¹ãƒ­ãƒƒãƒˆå›è»¢çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                if (this.playerId === 1 && window.game1) {
                  window.game1.setSlotSpinning(false);
                  console.log(
                    `Player ${this.playerId} slot spinning state reset`,
                  );
                  // çŠ¶æ…‹è¡¨ç¤ºã‚’æ›´æ–°
                  this.updateState(this.playerId, window.game1.getState());
                } else if (this.playerId === 2 && window.game2) {
                  window.game2.setSlotSpinning(false);
                  console.log(
                    `Player ${this.playerId} slot spinning state reset`,
                  );
                  // çŠ¶æ…‹è¡¨ç¤ºã‚’æ›´æ–°
                  this.updateState(this.playerId, window.game2.getState());
                }

                // å°‘ã—ä½™è£•ã‚’æŒã£ã¦å®Œäº†ã‚’å¾…ã¤
                setTimeout(resolve, 300);
              }
            }, 100);

            // æœ€å¤§10ç§’ã§ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
            setTimeout(() => {
              clearInterval(checkInterval);
              console.warn(`Player ${this.playerId} slot animation timeout`);

              // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚ã‚‚ã‚¹ãƒ­ãƒƒãƒˆå›è»¢çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
              if (this.playerId === 1 && window.game1) {
                window.game1.setSlotSpinning(false);
                console.log(
                  `Player ${this.playerId} slot spinning state reset (timeout)`,
                );
                // çŠ¶æ…‹è¡¨ç¤ºã‚’æ›´æ–°
                this.updateState(this.playerId, window.game1.getState());
              } else if (this.playerId === 2 && window.game2) {
                window.game2.setSlotSpinning(false);
                console.log(
                  `Player ${this.playerId} slot spinning state reset (timeout)`,
                );
                // çŠ¶æ…‹è¡¨ç¤ºã‚’æ›´æ–°
                this.updateState(this.playerId, window.game2.getState());
              }

              resolve();
            }, 10000);
          });
        }

        // ã‚­ãƒ¥ãƒ¼ã®çŠ¶æ…‹ã‚’å–å¾—
        getStatus() {
          return {
            queueLength: this.queue.length,
            isProcessing: this.isProcessing,
            queue: [...this.queue],
          };
        }

        // ã‚­ãƒ¥ãƒ¼ã‚’ã‚¯ãƒªã‚¢
        clear() {
          this.queue = [];
          this.isProcessing = false;
          console.log(`Player ${this.playerId} task queue cleared`);
        }
      }

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ¥ã®ã‚¿ã‚¹ã‚¯ã‚­ãƒ¥ãƒ¼ï¼ˆupdateStateé–¢æ•°ã¯mainé–¢æ•°å†…ã§å®šç¾©ã•ã‚Œã‚‹ãŸã‚ã€å¾Œã§è¨­å®šï¼‰
      let taskQueue1;
      let taskQueue2;

      // æ’ä»–åˆ¶å¾¡ç”¨ã®å¤‰æ•°ï¼ˆã‚¹ãƒ­ãƒƒãƒˆãƒ¬ãƒ™ãƒ«ï¼‰
      let isSpinning1 = false;
      let isSpinning2 = false;
      let spinQueue1 = [];
      let spinQueue2 = [];

      // ã‚¹ãƒ­ãƒƒãƒˆçŠ¶æ…‹ãƒã‚§ãƒƒã‚¯é–¢æ•°
      function getSlotStatus(playerId) {
        if (playerId === 1) {
          return {
            isSpinning: isSpinning1,
            queueLength: spinQueue1.length,
            queue: [...spinQueue1],
          };
        } else if (playerId === 2) {
          return {
            isSpinning: isSpinning2,
            queueLength: spinQueue2.length,
            queue: [...spinQueue2],
          };
        }
        return null;
      }

      // å¼·åˆ¶çš„ã«ã‚¹ãƒ­ãƒƒãƒˆçŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹é–¢æ•°ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
      function forceResetSlotState(playerId) {
        if (playerId === 1) {
          isSpinning1 = false;
          spinQueue1 = [];
          if (taskQueue1) {
            taskQueue1.clear();
          }
          console.log(
            "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1: ã‚¹ãƒ­ãƒƒãƒˆçŠ¶æ…‹ã¨ã‚¿ã‚¹ã‚¯ã‚­ãƒ¥ãƒ¼ã‚’å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ",
          );
        } else if (playerId === 2) {
          isSpinning2 = false;
          spinQueue2 = [];
          if (taskQueue2) {
            taskQueue2.clear();
          }
          console.log(
            "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2: ã‚¹ãƒ­ãƒƒãƒˆçŠ¶æ…‹ã¨ã‚¿ã‚¹ã‚¯ã‚­ãƒ¥ãƒ¼ã‚’å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ",
          );
        } else if (playerId === "both") {
          isSpinning1 = false;
          isSpinning2 = false;
          spinQueue1 = [];
          spinQueue2 = [];
          if (taskQueue1) {
            taskQueue1.clear();
          }
          if (taskQueue2) {
            taskQueue2.clear();
          }
          console.log(
            "ä¸¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: ã‚¹ãƒ­ãƒƒãƒˆçŠ¶æ…‹ã¨ã‚¿ã‚¹ã‚¯ã‚­ãƒ¥ãƒ¼ã‚’å¼·åˆ¶ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ",
          );
        }
      }

      // åˆæœŸåŒ–: å„ãƒªãƒ¼ãƒ«ã«ç¹°ã‚Šè¿”ã—æ•°å­—ãƒªã‚¹ãƒˆã‚’ä½œæˆ
      function buildReelList(reelEl) {
        const list = reelEl.querySelector(".reel-list");
        list.innerHTML = "";

        // REPEATå›åˆ†ã®æ•°å­—ã‚’ä½œæˆ
        for (let r = 0; r < REPEAT; r++) {
          for (const n of numbers) {
            const div = document.createElement("div");
            div.className = "cell";
            div.textContent = n;
            list.appendChild(div);
          }
        }

        // ã•ã‚‰ã«1å‘¨åˆ†è¿½åŠ ã—ã¦ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç«¯ã§ã®ç©ºç™½ã‚’é˜²ã
        for (const n of numbers) {
          const div = document.createElement("div");
          div.className = "cell";
          div.textContent = n;
          list.appendChild(div);
        }

        // åˆæœŸä½ç½®: ä¸­å¤®ãƒ–ãƒ­ãƒƒã‚¯ã®æœ€åˆï¼ˆ0ï¼‰ãŒè¦‹ãˆã‚‹ã‚ˆã†ã«è¨­å®šï¼ˆè¡¨ç¤ºä½ç½®ã‚’2ã¤ä¸‹ã«èª¿æ•´ï¼‰
        const centerBlockStart = Math.floor(REPEAT / 2) * numbers.length;
        list.style.transform = `translateY(-${(centerBlockStart - 2) * cellH}px)`;
      }

      reels1.forEach(buildReelList);
      reels2.forEach(buildReelList);

      // æŒ‡å®šã•ã‚ŒãŸ3ã¤ã®æ•°å­—ã‚’å³åº§ã«è¡¨ç¤º
      function setDigits(digits, reelArray = reels1) {
        digits = normalizeDigits(digits);
        reelArray.forEach((reelEl, idx) => {
          const list = reelEl.querySelector(".reel-list");
          const targetNumber = digits[idx] % 10;

          // ä¸­å¤®ãƒ–ãƒ­ãƒƒã‚¯ã§ã®ç›®æ¨™ä½ç½®ã‚’è¨ˆç®—ï¼ˆè¡¨ç¤ºä½ç½®ã‚’2ã¤ä¸‹ã«èª¿æ•´ï¼‰
          const centerBlockStart = Math.floor(REPEAT / 2) * numbers.length;
          const targetPositionInBlock = numbers.indexOf(targetNumber);
          const finalPosition = centerBlockStart + targetPositionInBlock - 2;
          const offset = finalPosition * cellH;

          // ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ãªã—ã§å³åº§ã«ç§»å‹•
          list.style.transition = "none";
          list.style.transform = `translateY(-${offset}px)`;

          // æ¬¡å›ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã«ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ã‚’å¾©æ´»
          requestAnimationFrame(() => {
            list.style.transition = "transform 600ms cubic-bezier(.2,.8,.2,1)";
          });
        });
      }

      // ã‚¹ãƒ­ãƒƒãƒˆé¢¨å›è»¢: å¿…ãšä¸Šã‹ã‚‰ä¸‹ã¸å›è»¢ã—ã¦ç›®æ¨™æ•°å­—ã§åœæ­¢
      // spinDurations: ãƒªãƒ¼ãƒ«ã”ã¨ã®æ™‚é–“æŒ‡å®š
      //   - null: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ©ãƒ³ãƒ€ãƒ æ™‚é–“
      //   - æ•°å€¤: å…¨ãƒªãƒ¼ãƒ«å…±é€šã®åŸºæœ¬æ™‚é–“ï¼ˆå¾Œæ–¹äº’æ›ï¼‰
      //   - é…åˆ—: [reel0_duration, reel1_duration, reel2_duration] å„ãƒªãƒ¼ãƒ«å€‹åˆ¥æ™‚é–“
      //   ä¾‹: spinTo1([1,2,3], [1000, 1500, 2000]) // 1æ¡ç›®1ç§’ã€2æ¡ç›®1.5ç§’ã€3æ¡ç›®2ç§’
      function spinTo(digits, reelArray = reels1, spinDurations = null) {
        // æ’ä»–åˆ¶å¾¡: ã©ã¡ã‚‰ã®ãƒªãƒ¼ãƒ«ã‚»ãƒƒãƒˆã‹ã‚’åˆ¤å®š
        const isReel1 = reelArray === reels1;
        const isSpinning = isReel1 ? isSpinning1 : isSpinning2;
        const spinQueue = isReel1 ? spinQueue1 : spinQueue2;

        // ç¾åœ¨ã‚¹ãƒ”ãƒ³ä¸­ã®å ´åˆã¯ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã—ã¦çµ‚äº†
        if (isSpinning) {
          console.log(
            `Player ${isReel1 ? 1 : 2} slot is spinning, adding to queue:`,
            digits,
          );
          spinQueue.push({ digits, spinDurations });
          return;
        }

        // ã‚¹ãƒ”ãƒ³é–‹å§‹ãƒ•ãƒ©ã‚°ã‚’ã‚»ãƒƒãƒˆ
        if (isReel1) {
          isSpinning1 = true;
        } else {
          isSpinning2 = true;
        }

        console.log(`Player ${isReel1 ? 1 : 2} slot spin started:`, digits);

        digits = normalizeDigits(digits);
        const spinTimeouts = [];
        let completedReelsCount = 0; // å®Œäº†ã—ãŸãƒªãƒ¼ãƒ«æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
        let isSpinCompleted = false; // ã‚¹ãƒ”ãƒ³å®Œäº†ãƒ•ãƒ©ã‚°ï¼ˆé‡è¤‡å‡¦ç†é˜²æ­¢ï¼‰

        reelArray.forEach((reelEl, idx) => {
          const list = reelEl.querySelector(".reel-list");

          // å›è»¢æ™‚é–“ã®è¨ˆç®—
          let baseDuration, duration;
          if (spinDurations !== null && spinDurations[idx] !== undefined) {
            // æŒ‡å®šã•ã‚ŒãŸå„ãƒªãƒ¼ãƒ«ã®æ™‚é–“ã‚’ä½¿ç”¨
            baseDuration = spinDurations[idx];
            const extra = Math.random() * 100; // å°‘ã—ã®ãƒ©ãƒ³ãƒ€ãƒ è¦ç´ ã‚’æ®‹ã™
            duration = baseDuration + extra;
          } else if (
            spinDurations !== null &&
            typeof spinDurations === "number"
          ) {
            // å˜ä¸€ã®æ•°å€¤ãŒæŒ‡å®šã•ã‚ŒãŸå ´åˆï¼ˆå¾Œæ–¹äº’æ›æ€§ï¼‰
            baseDuration = spinDurations;
            const extra = idx * 100 + Math.random() * 100;
            duration = baseDuration + extra;
          } else {
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æ™‚é–“è¨ˆç®—ï¼ˆå¾Œã®ãƒªãƒ¼ãƒ«ã»ã©é•·ãã€ã°ã‚‰ã¤ãã‚’æ¸›ã‚‰ã—ã¦è‡ªç„¶ã«ï¼‰
            baseDuration = 1800 + Math.random() * 600;
            const extra = idx * 400 + Math.random() * 200;
            duration = baseDuration + extra;
          }

          const targetNumber = digits[idx] % 10;

          // ç¾åœ¨ä½ç½®ã‚’å–å¾—
          const currentTransform = parseTransformY(list);
          const currentPosition = currentTransform / cellH;

          // æœ€ä½3å‘¨ä»¥ä¸Šå›è»¢ï¼ˆã‚¹ãƒ­ãƒƒãƒˆé¢¨ï¼‰
          const minSpins = 3 + Math.floor(Math.random() * 2);
          const totalRotationCells = minSpins * numbers.length;

          const targetPositionInBlock = numbers.indexOf(targetNumber);

          // ç›®æ¨™ä½ç½®ã‚’ä¸­å¤®ãƒ–ãƒ­ãƒƒã‚¯åŸºæº–ã§ç›´æ¥è¨ˆç®—
          const centerBlockStart = Math.floor(REPEAT / 2) * numbers.length;
          const baseTargetPosition =
            centerBlockStart + targetPositionInBlock - 2;

          // ç¾åœ¨ä½ç½®ã‹ã‚‰æœ€ä½å›è»¢æ•°ã‚’ä¿è¨¼ã—ãŸç›®æ¨™ä½ç½®ã‚’è¨ˆç®—
          let targetPosition = currentPosition + totalRotationCells;

          // ç›®æ¨™ä½ç½®ã‚’ä¸­å¤®ãƒ–ãƒ­ãƒƒã‚¯ã®æ­£ã—ã„ä½ç½®ã«èª¿æ•´
          const positionDifference =
            (baseTargetPosition - targetPosition) % numbers.length;
          if (positionDifference < 0) {
            targetPosition += numbers.length + positionDifference;
          } else {
            targetPosition += positionDifference;
          }

          const targetOffset = targetPosition * cellH;

          // ã‚ˆã‚Šè‡ªç„¶ãªæ¸›é€Ÿã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
          list.style.transition = `transform ${duration}ms cubic-bezier(0.23, 1, 0.320, 1)`;

          // ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰åŠ¹æœã§é †æ¬¡é–‹å§‹
          setTimeout(() => {
            list.style.transform = `translateY(-${targetOffset}px)`;

            // transitionendã‚¤ãƒ™ãƒ³ãƒˆã§ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†ã‚’ç¢ºå®Ÿã«æ¤œçŸ¥
            const handleTransitionEnd = (event) => {
              // transform ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³å®Œäº†ã®ã¿å‡¦ç†
              if (event.propertyName === "transform") {
                list.removeEventListener("transitionend", handleTransitionEnd);

                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãªã—ã§ä¸­å¤®ãƒ–ãƒ­ãƒƒã‚¯å†…ã®é©åˆ‡ãªä½ç½®ã«ãƒªã‚»ãƒƒãƒˆ
                const centerBlockStart =
                  Math.floor(REPEAT / 2) * numbers.length;
                const resetTargetPosition =
                  centerBlockStart + targetPositionInBlock - 2;
                const resetOffset = resetTargetPosition * cellH;

                // ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ã‚’ç„¡åŠ¹åŒ–ã—ã¦ãƒªã‚»ãƒƒãƒˆ
                list.style.transition = "none";
                list.style.transform = `translateY(-${resetOffset}px)`;

                // å°‘ã—é…ã‚Œã¦ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ã‚’å¾©æ´»
                setTimeout(() => {
                  list.style.transition =
                    "transform 400ms cubic-bezier(.2,.8,.2,1)";
                }, 10);

                // å®Œäº†ã—ãŸãƒªãƒ¼ãƒ«æ•°ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ
                completedReelsCount++;
                console.log(
                  `Player ${isReel1 ? 1 : 2} reel ${idx} completed (${completedReelsCount}/${reelArray.length})`,
                );

                // å…¨ãƒªãƒ¼ãƒ«ãŒå®Œäº†ã—ãŸã‹ãƒã‚§ãƒƒã‚¯ï¼ˆé‡è¤‡å‡¦ç†é˜²æ­¢ï¼‰
                if (
                  completedReelsCount === reelArray.length &&
                  !isSpinCompleted
                ) {
                  isSpinCompleted = true;
                  console.log(
                    `Player ${isReel1 ? 1 : 2} all reels completed, waiting for settlement...`,
                  );

                  // å…¨ãƒªãƒ¼ãƒ«å®Œäº†æ™‚ã®å‡¦ç†ï¼ˆå°‘ã—é•·ã‚ã«å¾…æ©Ÿã—ã¦ç¢ºå®Ÿã«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒå®Œäº†ã—ã¦ã‹ã‚‰ï¼‰
                  setTimeout(() => {
                    // ã‚¹ãƒ”ãƒ³å®Œäº†ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
                    if (isReel1) {
                      isSpinning1 = false;
                    } else {
                      isSpinning2 = false;
                    }

                    console.log(
                      `Player ${isReel1 ? 1 : 2} slot spin completed and ready for next`,
                    );

                    // ã‚­ãƒ¥ãƒ¼ã«å¾…æ©Ÿä¸­ã®ã‚¹ãƒ”ãƒ³ãŒã‚ã‚Œã°å®Ÿè¡Œ
                    if (spinQueue.length > 0) {
                      const nextSpin = spinQueue.shift();
                      console.log(
                        `Player ${isReel1 ? 1 : 2} executing queued spin:`,
                        nextSpin.digits,
                      );
                      setTimeout(
                        () =>
                          spinTo(
                            nextSpin.digits,
                            reelArray,
                            nextSpin.spinDurations,
                          ),
                        300,
                      );
                    }
                  }, 200); // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒç¢ºå®Ÿã«å®Œäº†ã™ã‚‹ã¾ã§å¾…æ©Ÿ
                }
              }
            };

            list.addEventListener("transitionend", handleTransitionEnd);

            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆã‚¤ãƒ™ãƒ³ãƒˆãŒç™ºç«ã—ãªã„å ´åˆã®ä¿é™ºï¼‰
            // æœ€å¤§ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚é–“ã‚’è€ƒæ…®ã—ã¦ååˆ†ã«é•·ã‚ã«è¨­å®š
            const maxDuration =
              spinDurations !== null &&
              (Array.isArray(spinDurations) ||
                typeof spinDurations === "number")
                ? baseDuration +
                  (reelArray.length - 1) * 100 +
                  Math.random() * 100
                : baseDuration +
                  (reelArray.length - 1) * 400 +
                  Math.random() * 200;
            const fallbackTimeout = setTimeout(() => {
              if (!isSpinCompleted) {
                console.warn(
                  `Player ${isReel1 ? 1 : 2} reel ${idx} fallback timeout triggered`,
                );
                list.removeEventListener("transitionend", handleTransitionEnd);
                handleTransitionEnd({ propertyName: "transform" });
              }
            }, maxDuration + 1500);

            spinTimeouts.push(fallbackTimeout);
          }, idx * 200);
        });

        // åœæ­¢ç”¨ã®é–¢æ•°ã‚’è¿”ã™
        return function stop() {
          spinTimeouts.forEach((id) => clearTimeout(id));

          // ã‚¹ãƒ”ãƒ³çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
          if (isReel1) {
            isSpinning1 = false;
          } else {
            isSpinning2 = false;
          }

          // å„ãƒªãƒ¼ãƒ«ã‚’å³åº§ã«ç›®æ¨™ä½ç½®ã«ç§»å‹•
          reelArray.forEach((reelEl, idx) => {
            const list = reelEl.querySelector(".reel-list");
            list.style.transition = "transform 300ms ease-out";
          });
          setDigits(digits, reelArray);

          console.log(`Player ${isReel1 ? 1 : 2} slot spin stopped`);
        };
      }

      // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£: æ•°å­—é…åˆ—ã®æ­£è¦åŒ–
      function normalizeDigits(d) {
        console.log("normalizeDigits", d);
        if (!Array.isArray(d)) throw new Error("é…åˆ—ã§æ¸¡ã—ã¦ãã ã•ã„: [a,b,c]");
        if (d.length !== 3) throw new Error("è¦ç´ æ•°ã¯3ã¤å¿…è¦ã§ã™");
        return d.map((x) => Number(x) || 0).map((x) => ((x % 10) + 10) % 10);
      }

      // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£: ç¾åœ¨ã®translateYå€¤ã‚’å–å¾—
      function parseTransformY(list) {
        const t = getComputedStyle(list).transform;
        if (!t || t === "none") return 0;

        // matrixå½¢å¼
        const matrixMatch = t.match(
          /matrix\(([^,]+),\s*([^,]+),\s*([^,]+),\s*([^,]+),\s*([^,]+),\s*([^\)]+)\)/,
        );
        if (matrixMatch) {
          return Math.abs(parseFloat(matrixMatch[6]));
        }

        // translateYå½¢å¼
        const translateMatch = t.match(/translateY\((-?\d+(?:\.\d+)?)px\)/);
        if (translateMatch) {
          return Math.abs(parseFloat(translateMatch[1]));
        }

        // translate3då½¢å¼
        const translate3dMatch = t.match(
          /translate3d\(([^,]+),\s*(-?\d+(?:\.\d+)?)px,\s*([^\)]+)\)/,
        );
        if (translate3dMatch) {
          return Math.abs(parseFloat(translate3dMatch[2]));
        }

        return 0;
      }

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1ç”¨ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹é–¢æ•°
      function setDigits1(digits) {
        console.log("Player 1 setDigits called:", digits);
        return setDigits(digits, reels1);
      }

      function spinTo1(digits, spinDurations = null) {
        console.log("Player 1 spinTo called:", digits);
        return spinTo(digits, reels1, spinDurations);
      }

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2ç”¨ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹é–¢æ•°
      function setDigits2(digits) {
        console.log("Player 2 setDigits called:", digits);
        return setDigits(digits, reels2);
      }

      function spinTo2(digits, spinDurations = null) {
        console.log("Player 2 spinTo called:", digits);
        return spinTo(digits, reels2, spinDurations);
      }

      // ä¸¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åŒæ™‚æ“ä½œç”¨ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹é–¢æ•°
      function setDigitsBoth(digits) {
        console.log("Both players setDigits called:", digits);
        setDigits1(digits);
        setDigits2(digits);
      }

      function spinToBoth(digits, spinDurations = null) {
        spinTo1(digits, spinDurations);
        spinTo2(digits, spinDurations);
      }

      // ãƒ‡ãƒãƒƒã‚°é–¢æ•°ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã«å…¬é–‹
      window.getSlotStatus = getSlotStatus;
      window.forceResetSlotState = forceResetSlotState;
      window.debugSlots = () => {
        console.log("=== ã‚¹ãƒ­ãƒƒãƒˆçŠ¶æ…‹ ===");
        console.log("ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1:", getSlotStatus(1));
        console.log("ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2:", getSlotStatus(2));
      };
      window.getTaskQueueStatus = (playerId) => {
        if (playerId === 1) return taskQueue1 ? taskQueue1.getStatus() : null;
        if (playerId === 2) return taskQueue2 ? taskQueue2.getStatus() : null;
        return {
          player1: taskQueue1 ? taskQueue1.getStatus() : null,
          player2: taskQueue2 ? taskQueue2.getStatus() : null,
        };
      };
      window.debugTaskQueues = () => {
        console.log("=== ã‚¿ã‚¹ã‚¯ã‚­ãƒ¥ãƒ¼çŠ¶æ…‹ ===");
        console.log(
          "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1:",
          taskQueue1 ? taskQueue1.getStatus() : "æœªåˆæœŸåŒ–",
        );
        console.log(
          "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2:",
          taskQueue2 ? taskQueue2.getStatus() : "æœªåˆæœŸåŒ–",
        );
      };

      window.debugSpinningState = () => {
        console.log("=== ã‚¹ãƒ­ãƒƒãƒˆå›è»¢çŠ¶æ…‹ ===");
        console.log("UIå´ã‚¹ãƒ­ãƒƒãƒˆçŠ¶æ…‹:");
        console.log("  ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1:", getSlotStatus(1));
        console.log("  ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2:", getSlotStatus(2));
        console.log("ã‚²ãƒ¼ãƒ å´ã‚¹ãƒ­ãƒƒãƒˆçŠ¶æ…‹:");
        console.log(
          "  ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1:",
          window.game1 ? window.game1.isSlotCurrentlySpinning() : "æœªåˆæœŸåŒ–",
        );
        console.log(
          "  ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2:",
          window.game2 ? window.game2.isSlotCurrentlySpinning() : "æœªåˆæœŸåŒ–",
        );
      };

      // ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ‡ãƒãƒƒã‚°é–¢æ•°
      window.testSlotTiming = (playerId = 1, count = 3, interval = 500) => {
        console.log(`=== ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${playerId}ã®ã‚¹ãƒ­ãƒƒãƒˆé€£ç¶šãƒ†ã‚¹ãƒˆé–‹å§‹ ===`);
        const spinFunc = playerId === 1 ? spinTo1 : spinTo2;

        for (let i = 0; i < count; i++) {
          setTimeout(() => {
            const digits = [
              Math.floor(Math.random() * 10),
              Math.floor(Math.random() * 10),
              Math.floor(Math.random() * 10),
            ];
            console.log(`ãƒ†ã‚¹ãƒˆ ${i + 1}/${count}:`, digits);
            spinFunc(digits);
          }, i * interval);
        }
      };

      // ä¸¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åŒæ™‚å›è»¢ãƒ†ã‚¹ãƒˆ
      window.testBothSlots = (count = 2, interval = 1000) => {
        console.log("=== ä¸¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åŒæ™‚ã‚¹ãƒ­ãƒƒãƒˆãƒ†ã‚¹ãƒˆé–‹å§‹ ===");
        for (let i = 0; i < count; i++) {
          setTimeout(() => {
            const digits1 = [
              Math.floor(Math.random() * 10),
              Math.floor(Math.random() * 10),
              Math.floor(Math.random() * 10),
            ];
            const digits2 = [
              Math.floor(Math.random() * 10),
              Math.floor(Math.random() * 10),
              Math.floor(Math.random() * 10),
            ];
            console.log(`ä¸¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ†ã‚¹ãƒˆ ${i + 1}/${count}:`, {
              player1: digits1,
              player2: digits2,
            });
            spinTo1(digits1);
            spinTo2(digits2);
          }, i * interval);
        }
      };

      // å„ãƒªãƒ¼ãƒ«å€‹åˆ¥æ™‚é–“æŒ‡å®šãƒ†ã‚¹ãƒˆ
      window.testIndividualReelTiming = (playerId = 1) => {
        console.log(`=== ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${playerId}ã®å„ãƒªãƒ¼ãƒ«å€‹åˆ¥æ™‚é–“ãƒ†ã‚¹ãƒˆ ===`);
        const spinFunc = playerId === 1 ? spinTo1 : spinTo2;

        // ãƒ†ã‚¹ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³1: å·¦ã‹ã‚‰å³ã¸é †æ¬¡é•·ã
        setTimeout(() => {
          const digits = [7, 7, 7];
          const durations = [1000, 1500, 2000]; // 1ç§’ã€1.5ç§’ã€2ç§’
          console.log("ãƒ‘ã‚¿ãƒ¼ãƒ³1 - å·¦ã‹ã‚‰å³ã¸é †æ¬¡é•·ã:", { digits, durations });
          spinFunc(digits, durations);
        }, 0);

        // ãƒ†ã‚¹ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³2: å³ã‹ã‚‰å·¦ã¸é †æ¬¡é•·ã
        setTimeout(() => {
          const digits = [3, 3, 3];
          const durations = [2000, 1500, 1000]; // 2ç§’ã€1.5ç§’ã€1ç§’
          console.log("ãƒ‘ã‚¿ãƒ¼ãƒ³2 - å³ã‹ã‚‰å·¦ã¸é †æ¬¡é•·ã:", { digits, durations });
          spinFunc(digits, durations);
        }, 4000);

        // ãƒ†ã‚¹ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³3: ä¸­å¤®ã ã‘é•·ã
        setTimeout(() => {
          const digits = [1, 2, 3];
          const durations = [1000, 3000, 1000]; // 1ç§’ã€3ç§’ã€1ç§’
          console.log("ãƒ‘ã‚¿ãƒ¼ãƒ³3 - ä¸­å¤®ã ã‘é•·ã:", { digits, durations });
          spinFunc(digits, durations);
        }, 8000);

        // ãƒ†ã‚¹ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³4: å…¨ãƒªãƒ¼ãƒ«åŒã˜æ™‚é–“ï¼ˆé…åˆ—æŒ‡å®šï¼‰
        setTimeout(() => {
          const digits = [5, 5, 5];
          const durations = [1800, 1800, 1800]; // å…¨ã¦1.8ç§’
          console.log("ãƒ‘ã‚¿ãƒ¼ãƒ³4 - å…¨ãƒªãƒ¼ãƒ«åŒã˜æ™‚é–“ï¼ˆé…åˆ—ï¼‰:", {
            digits,
            durations,
          });
          spinFunc(digits, durations);
        }, 12000);

        // ãƒ†ã‚¹ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³5: å¾“æ¥ã®æ•°å€¤æŒ‡å®šï¼ˆå¾Œæ–¹äº’æ›æ€§ç¢ºèªï¼‰
        setTimeout(() => {
          const digits = [9, 8, 7];
          const duration = 2500; // å˜ä¸€æ•°å€¤
          console.log("ãƒ‘ã‚¿ãƒ¼ãƒ³5 - å¾“æ¥ã®æ•°å€¤æŒ‡å®š:", { digits, duration });
          spinFunc(digits, duration);
        }, 16000);
      };

      // ã‚¿ã‚¹ã‚¯ã‚­ãƒ¥ãƒ¼ã®ãƒ†ã‚¹ãƒˆé–¢æ•°
      window.testTaskQueue = (playerId = 1, count = 3) => {
        console.log(`=== ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${playerId}ã®ã‚¿ã‚¹ã‚¯ã‚­ãƒ¥ãƒ¼ãƒ†ã‚¹ãƒˆé–‹å§‹ ===`);
        const taskQueue = playerId === 1 ? taskQueue1 : taskQueue2;

        if (!taskQueue) {
          console.error("ã‚¿ã‚¹ã‚¯ã‚­ãƒ¥ãƒ¼ãŒæœªåˆæœŸåŒ–ã§ã™");
          return;
        }

        for (let i = 0; i < count; i++) {
          const digits = [
            Math.floor(Math.random() * 10),
            Math.floor(Math.random() * 10),
            Math.floor(Math.random() * 10),
          ];

          // æŠ½é¸ã‚¿ã‚¹ã‚¯ã‚’ç›´æ¥ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ 
          taskQueue.addTask("lotteryNormal", {
            lotteryResult: { type: "Normal", value: Math.random() * 100 },
            slotResult: [digits, digits],
            taskType: `Test Normal Lottery ${i + 1}`,
          });

          // çŠ¶æ…‹æ›´æ–°ã‚¿ã‚¹ã‚¯ã‚‚è¿½åŠ 
          taskQueue.addTask("default", {
            after: {
              type: "Normal",
              balls: 1000 - i * 10,
            },
          });
        }
      };

      window.testMixedTasks = (playerId = 1) => {
        console.log(`=== ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${playerId}ã®æ··åˆã‚¿ã‚¹ã‚¯ãƒ†ã‚¹ãƒˆé–‹å§‹ ===`);
        const taskQueue = playerId === 1 ? taskQueue1 : taskQueue2;

        if (!taskQueue) {
          console.error("ã‚¿ã‚¹ã‚¯ã‚­ãƒ¥ãƒ¼ãŒæœªåˆæœŸåŒ–ã§ã™");
          return;
        }

        // é€šå¸¸æŠ½é¸
        taskQueue.addTask("lotteryNormal", {
          lotteryResult: { type: "Win" },
          slotResult: [
            [1, 2, 3],
            [4, 5, 6],
          ],
          taskType: "Mixed Test Normal",
        });

        // çŠ¶æ…‹æ›´æ–°
        taskQueue.addTask("default", {
          after: { type: "Normal", balls: 950 },
        });

        // ãƒ©ãƒƒã‚·ãƒ¥æŠ½é¸
        taskQueue.addTask("lotteryRush", {
          lotteryResult: { type: "Rush" },
          slotResult: [
            [7, 7, 7],
            [7, 7, 7],
          ],
          taskType: "Mixed Test Rush",
        });

        // ã•ã‚‰ã«çŠ¶æ…‹æ›´æ–°
        taskQueue.addTask("default", {
          after: { type: "Rush", balls: 900, rushBalls: 50, n: 1 },
        });
      };

      // çµ±åˆãƒ‡ãƒãƒƒã‚°é–¢æ•°
      window.debugAll = () => {
        console.log("=== çµ±åˆãƒ‡ãƒãƒƒã‚°æƒ…å ± ===");
        console.log("=== ã‚¹ãƒ­ãƒƒãƒˆçŠ¶æ…‹ ===");
        console.log("ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1:", getSlotStatus(1));
        console.log("ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2:", getSlotStatus(2));
        console.log("=== ã‚¿ã‚¹ã‚¯ã‚­ãƒ¥ãƒ¼çŠ¶æ…‹ ===");
        console.log(
          "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1:",
          taskQueue1 ? taskQueue1.getStatus() : "æœªåˆæœŸåŒ–",
        );
        console.log(
          "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2:",
          taskQueue2 ? taskQueue2.getStatus() : "æœªåˆæœŸåŒ–",
        );
      };

      setDigitsBoth([0, 0, 0]);

      import {
        init,
        WasmGame,
        ControlFlow,
        Config,
        BallsConfig,
        Probability,
        SlotProbability,
        JsInput,
        JsOutput,
      } from "./pachislo.js";

      // Matter.jsã®ä¸»è¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å–å¾—
      const {
        Engine,
        Render,
        Runner,
        Bodies,
        Composite,
        Events,
        Mouse,
        MouseConstraint,
      } = Matter;

      // ãƒ‘ãƒãƒ³ã‚³ã‚²ãƒ¼ãƒ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚¯ãƒ©ã‚¹
      class PachinkoGame {
        constructor(
          canvasId,
          playerId,
          keyBinding,
          nails,
          wasmGame,
          recreateWasmGame,
        ) {
          this.canvasId = canvasId;
          this.playerId = playerId;
          this.keyBinding = keyBinding;
          this.fallingBalls = [];
          this.nails_index = nails;
          this.wasmgame = wasmGame;
          this.recreateWasmGame = recreateWasmGame; // WASMGameå†ä½œæˆç”¨ã®é–¢æ•°
          this.lastLaunchTime = 0; // æœ€å¾Œã®ãƒœãƒ¼ãƒ«ç™ºå°„æ™‚åˆ»ã‚’è¨˜éŒ²
          this.isGameStarted = false; // WASMã‚²ãƒ¼ãƒ ãŒé–‹å§‹ã•ã‚Œã¦ã„ã‚‹ã‹ã®ãƒ•ãƒ©ã‚°
          this.gameTimer = null; // ã‚²ãƒ¼ãƒ çµ‚äº†ã‚¿ã‚¤ãƒãƒ¼

          this.init(); // canvasã¨ç‰©ç†ã‚¨ãƒ³ã‚¸ãƒ³ã¯æœ€åˆã‹ã‚‰åˆæœŸåŒ–
        }

        run_step_with_command(command) {
          this.wasmgame.run_step_with_command(command);
        }

        init() {
          // ã‚¨ãƒ³ã‚¸ãƒ³ã‚’ä½œæˆ
          this.engine = Engine.create();
          this.world = this.engine.world;
          this.engine.world.gravity.y = 0.8;

          // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã‚’ä½œæˆ
          this.setupRenderer();

          // ã‚²ãƒ¼ãƒ è¦ç´ ã‚’ä½œæˆ
          this.createWalls();
          this.createNails();
          this.createTargetZones();
          this.setupMouseControl();
          this.setupEventListeners();

          // ä¸–ç•Œã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿½åŠ 
          this.addToWorld();

          // ã‚¨ãƒ³ã‚¸ãƒ³ã‚’é–‹å§‹
          this.start();
        }

        async startWasmGame() {
          console.log(
            `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${this.playerId}: startWasmGame()ãŒå‘¼ã°ã‚Œã¾ã—ãŸã€‚ç¾åœ¨ã®isGameStarted: ${this.isGameStarted}`,
          );

          if (this.isGameStarted) {
            console.log(
              `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${this.playerId}: æ—¢ã«ã‚²ãƒ¼ãƒ é–‹å§‹æ¸ˆã¿ã®ãŸã‚å‡¦ç†ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™`,
            );
            return; // æ—¢ã«ã‚²ãƒ¼ãƒ é–‹å§‹æ¸ˆã¿ã®å ´åˆã¯ä½•ã‚‚ã—ãªã„
          }

          // ãƒ‘ãƒã‚¹ãƒ­ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹
          console.log(
            `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${this.playerId}: StartGameã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¾ã™`,
          );
          this.run_step_with_command("StartGame");
          this.isGameStarted = true;

          // 5åˆ†å¾Œã«ã‚²ãƒ¼ãƒ ã‚’çµ‚äº†ã•ã›ã‚‹ã‚¿ã‚¤ãƒãƒ¼ã‚’è¨­å®š
          this.gameTimer = setTimeout(
            async () => {
              await this.endGame();
            },
            5 * 60 * 1000,
          ); // 5åˆ† = 300ç§’ = 300,000ãƒŸãƒªç§’

          console.log(
            `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${this.playerId}: ã‚²ãƒ¼ãƒ é–‹å§‹ï¼5åˆ†å¾Œã«è‡ªå‹•çµ‚äº†ã—ã¾ã™ã€‚isGameStarted: ${this.isGameStarted}`,
          );
        }

        async endGame() {
          if (!this.isGameStarted) {
            console.log(
              `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${this.playerId}: endGame()ãŒå‘¼ã°ã‚Œã¾ã—ãŸãŒã€æ—¢ã«ã‚²ãƒ¼ãƒ ã¯çµ‚äº†çŠ¶æ…‹ã§ã™`,
            );
            return;
          }

          console.log(`ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${this.playerId}: ã‚²ãƒ¼ãƒ çµ‚äº†ï¼`);

          // ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚¯ãƒªã‚¢
          if (this.gameTimer) {
            clearTimeout(this.gameTimer);
            this.gameTimer = null;
          }

          // ã‚²ãƒ¼ãƒ çµ‚äº†å‡¦ç†
          console.log(
            `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${this.playerId}: FinishGameã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¾ã™`,
          );
          this.run_step_with_command("FinishGame");

          // FinishGameã‚³ãƒãƒ³ãƒ‰ã®å‡¦ç†å®Œäº†ã‚’å¾…ã¤
          console.log(
            `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${this.playerId}: ã‚²ãƒ¼ãƒ çµ‚äº†å‡¦ç†ã®å®Œäº†ã‚’å¾…æ©Ÿä¸­...`,
          );
          await new Promise((resolve) => setTimeout(resolve, 100));

          // æ–°ã—ã„WASMGameã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆ
          console.log(
            `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${this.playerId}: æ–°ã—ã„WASMGameã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã—ã¾ã™`,
          );
          this.wasmgame = this.recreateWasmGame();

          // windowã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚æ›´æ–°
          if (this.playerId === 1) {
            window.game1 = this.wasmgame;
          } else if (this.playerId === 2) {
            window.game2 = this.wasmgame;
          }

          this.isGameStarted = false;
          console.log(
            `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${this.playerId}: isGameStartedã‚’${this.isGameStarted}ã«è¨­å®šã—ã¾ã—ãŸ`,
          );
        }

        setupRenderer() {
          const canvas = document.getElementById(this.canvasId);
          this.render = Render.create({
            canvas: canvas,
            engine: this.engine,
            options: {
              width: 200,
              height: 800,
              wireframes: false,
              background: "transparent",
              showAngleIndicator: true,
              showVelocity: false,
            },
          });
        }

        createWalls() {
          this.walls = [
            Bodies.rectangle(0, 400, 30, 800, {
              isStatic: true,
              render: { fillStyle: "#444" },
            }),
            Bodies.rectangle(200, 400, 30, 800, {
              isStatic: true,
              render: { fillStyle: "#444" },
            }),
          ];
        }

        createNails() {
          this.nails = [];

          const nailRadius = 2;

          for (let { x, y } of this.nails_index) {
            const nail = Bodies.circle(x, y, nailRadius, {
              isStatic: true,
              render: {
                fillStyle: "#e74c3c",
                strokeStyle: "#c0392b",
                lineWidth: 0.5,
              },
            });

            this.nails.push(nail);
          }
        }

        createTargetZones() {
          // ã‚ãŸã‚Šã‚¨ãƒªã‚¢ï¼ˆç·‘ï¼‰
          this.winZone = Bodies.rectangle(100, 770, 30, 30, {
            isSensor: true,
            isStatic: true,
            render: {
              fillStyle: "#2ecc71",
              strokeStyle: "#27ae60",
              lineWidth: 2,
              opacity: 0.8,
            },
          });

          // é€šå¸¸ã‚¨ãƒªã‚¢ï¼ˆèµ¤ï¼‰
          this.normalZone = Bodies.rectangle(100, 770, 160, 30, {
            isSensor: true,
            isStatic: true,
            render: {
              fillStyle: "#e74c3c",
              strokeStyle: "#c0392b",
              lineWidth: 1,
              opacity: 0.5,
            },
          });
        }

        setupMouseControl() {
          const mouse = Mouse.create(this.render.canvas);
          this.mouseConstraint = MouseConstraint.create(this.engine, {
            mouse: mouse,
            constraint: {
              stiffness: 0.2,
              render: { visible: false },
            },
          });
        }

        setupEventListeners() {
          // è¡çªæ¤œçŸ¥ã‚¤ãƒ™ãƒ³ãƒˆ
          Events.on(this.engine, "collisionStart", (event) => {
            this.handleCollisions(event.pairs);
          });
        }

        handleCollisions(pairs) {
          pairs.forEach((pair) => {
            const { bodyA, bodyB } = pair;

            if (bodyA === this.winZone || bodyB === this.winZone) {
              const ball = bodyA === this.winZone ? bodyB : bodyA;

              if (this.fallingBalls.includes(ball)) {
                console.log(
                  `ğŸ‰ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${this.playerId}: ã‚ãŸã‚Šï¼çƒãŒå½“ãŸã‚Šã‚¨ãƒªã‚¢ã‚’é€šéã—ã¾ã—ãŸï¼ (Ball ID: ${ball.id}, ä½ç½®: x=${Math.round(ball.position.x)}, y=${Math.round(ball.position.y)})`,
                );

                this.run_step_with_command("CauseLottery");

                const index = this.fallingBalls.indexOf(ball);
                if (index > -1) {
                  this.fallingBalls.splice(index, 1);
                }
              }
            }
          });
        }

        addToWorld() {
          Composite.add(this.world, [
            ...this.walls,
            ...this.nails,
            this.normalZone,
            this.winZone,
            this.mouseConstraint,
          ]);
        }

        start() {
          Render.run(this.render);
          this.runner = Runner.create();
          Runner.run(this.runner, this.engine);
        }

        launchBall() {
          // ç™ºå°„æ™‚åˆ»ã‚’æ›´æ–°
          this.lastLaunchTime = Date.now();

          // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯
          const gameState = this.wasmgame.getState();
          if (gameState.type === "Uninitialized") {
            console.log(
              `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${this.playerId}: ã‚²ãƒ¼ãƒ ãŒæœªåˆæœŸåŒ–ã®ãŸã‚çƒã‚’æ‰“ã¦ã¾ã›ã‚“ - StartGameã‚³ãƒãƒ³ãƒ‰ã§ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã—ã¦ãã ã•ã„`,
            );
            console.log(
              `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${this.playerId}: ç¾åœ¨ã®ã‚²ãƒ¼ãƒ çŠ¶æ…‹:`,
              gameState,
            );
            return;
          }

          // ã‚¹ãƒ­ãƒƒãƒˆå›è»¢çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯
          if (this.wasmgame.isSlotCurrentlySpinning()) {
            console.log(
              `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${this.playerId}: ã‚²ãƒ¼ãƒ å´ã§ã‚¹ãƒ­ãƒƒãƒˆå›è»¢ä¸­ã®ãŸã‚çƒã‚’æ‰“ã¦ã¾ã›ã‚“ - å›è»¢çµ‚äº†ã¾ã§å¾…æ©Ÿ`,
            );
            return;
          }

          // ã‚¹ãƒ­ãƒƒãƒˆãŒå®Ÿéš›ã«å›è»¢ä¸­ã‹ã‚‚ãƒã‚§ãƒƒã‚¯
          const slotStatus = getSlotStatus(this.playerId);
          if (slotStatus && slotStatus.isSpinning) {
            console.log(
              `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${this.playerId}: UIå´ã§ã‚¹ãƒ­ãƒƒãƒˆå›è»¢ä¸­ã®ãŸã‚çƒã‚’æ‰“ã¦ã¾ã›ã‚“ - ã‚­ãƒ¥ãƒ¼é•·: ${slotStatus.queueLength}`,
            );
            return;
          }

          let bigBall = null;

          try {
            bigBall = Bodies.circle(50 + Math.random() * 100, 30, 6, {
              render: {
                fillStyle: "#3498db",
                strokeStyle: "#2980b9",
                lineWidth: 1.5,
              },
              restitution: 0.6,
              friction: 0.3,
            });

            this.fallingBalls.push(bigBall);
            Composite.add(this.world, bigBall);

            this.run_step_with_command("LaunchBall");

            console.log(
              `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${this.playerId}: æ–°ã—ã„çƒã‚’è½ä¸‹é–‹å§‹ (ID: ${bigBall.id})`,
            );
          } catch (error) {
            console.log(
              `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${this.playerId}: çƒã®ç™ºå°„ã«å¤±æ•—: ${error.message}`,
            );
            return;
          }

          // 5ç§’å¾Œã«ãƒœãƒ¼ãƒ«ã‚’è‡ªå‹•å‰Šé™¤
          setTimeout(() => {
            // bigBallãŒæ­£å¸¸ã«ä½œæˆã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
            if (bigBall) {
              // ãƒœãƒ¼ãƒ«ãŒé…åˆ—ã«å­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
              const ballIndex = this.fallingBalls.findIndex(
                (ball) => ball.id === bigBall.id,
              );
              if (ballIndex !== -1) {
                // é…åˆ—ã‹ã‚‰å‰Šé™¤
                this.fallingBalls.splice(ballIndex, 1);
                // ç‰©ç†ä¸–ç•Œã‹ã‚‰å‰Šé™¤
                Composite.remove(this.world, bigBall);
                console.log(
                  `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${this.playerId}: çƒã‚’è‡ªå‹•å‰Šé™¤ (ID: ${bigBall.id})`,
                );
              }
            }
          }, 7000);
        }

        resetSimulation() {
          this.fallingBalls.forEach((ball) => {
            Composite.remove(this.world, ball);
          });
          this.fallingBalls = [];

          this.run_step_with_command("FinishGame");

          // ã‚¹ãƒ­ãƒƒãƒˆçŠ¶æ…‹ã¨ã‚¿ã‚¹ã‚¯ã‚­ãƒ¥ãƒ¼ã‚‚ãƒªã‚»ãƒƒãƒˆ
          if (this.playerId === 1) {
            isSpinning1 = false;
            spinQueue1 = [];
            if (taskQueue1) {
              taskQueue1.clear();
            }
            console.log(
              "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1: ã‚¹ãƒ­ãƒƒãƒˆçŠ¶æ…‹ã¨ã‚¿ã‚¹ã‚¯ã‚­ãƒ¥ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ",
            );
          } else if (this.playerId === 2) {
            isSpinning2 = false;
            spinQueue2 = [];
            if (taskQueue2) {
              taskQueue2.clear();
            }
            console.log(
              "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2: ã‚¹ãƒ­ãƒƒãƒˆçŠ¶æ…‹ã¨ã‚¿ã‚¹ã‚¯ã‚­ãƒ¥ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ",
            );
          }

          console.log(
            `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${this.playerId}: ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ`,
          );
        }

        // ã‚­ãƒ¼å…¥åŠ›å‡¦ç†
        handleKeyInput(key) {
          if (key === this.keyBinding) {
            this.launchBall();
            console.log(
              `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼${this.playerId}: ${this.keyBinding.toUpperCase()}ã‚­ãƒ¼ã§çƒã‚’è½ä¸‹`,
            );
          }
        }
      }

      async function main() {
        await init();

        let nails1 = [];
        let nails2 = [];

        const nails_count = 100;

        for (let i = 0; i < nails_count; i++) {
          {
            const x = 20 + Math.random() * 160;
            const y = 100 + Math.random() * 600;
            nails1.push({ x: x, y: y });
          }

          {
            const x = 20 + Math.random() * 160;
            const y = 100 + Math.random() * 600;
            nails2.push({ x: x, y: y });
          }
        }

        // ã‚¹ãƒ­ãƒƒãƒˆç•ªå·ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
        function updateSlots(playerId, slot) {
          if (playerId === 1) {
            spinTo(slot, reels1);
          } else if (playerId === 2) {
            spinTo(slot, reels2);
          }
        }

        // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
        function updateState(playerId, state) {
          console.log(`Player ${playerId} State Updated:`, state);

          const element = document.getElementById(`state${playerId}`);
          const rightPanel = document.getElementById(`right-panel${playerId}`);

          if (element && rightPanel) {
            // ã‚²ãƒ¼ãƒ ãŒé–‹å§‹ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            const game = playerId === 1 ? game1 : game2;
            if (!game.isGameStarted) {
              const startKey = playerId === 1 ? "S" : "K";
              element.textContent = `æœªé–‹å§‹ - ${startKey}ã‚­ãƒ¼ã§ã‚¹ã‚¿ãƒ¼ãƒˆ`;
              return;
            }

            // ã‚¹ãƒ­ãƒƒãƒˆå›è»¢çŠ¶æ…‹ã‚’å–å¾—
            const slotStatus = getSlotStatus(playerId);
            const gameSpinningState =
              playerId === 1
                ? window.game1
                  ? window.game1.isSlotCurrentlySpinning()
                  : false
                : window.game2
                  ? window.game2.isSlotCurrentlySpinning()
                  : false;

            const spinStatusText =
              (slotStatus && slotStatus.isSpinning) || gameSpinningState
                ? " ğŸ°å›è»¢ä¸­"
                : "";

            switch (state.type) {
              case "Normal":
                element.textContent = `é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ - çƒæ•°: ${state.balls}${spinStatusText}`;
                // rightPanel.style.backgroundColor = "black";
                break;
              case "Rush":
                element.textContent = `ãƒ©ãƒƒã‚·ãƒ¥ãƒ¢ãƒ¼ãƒ‰ - çƒæ•°: ${state.balls}, ãƒ©ãƒƒã‚·ãƒ¥çƒ: ${state.rushBalls}, å›æ•°: ${state.n}${spinStatusText}`;
                // rightPanel.style.backgroundColor = "white";
                break;
              default:
                element.textContent = `æœªåˆæœŸåŒ–${spinStatusText}`;
            }
          }
        }

        // ã‚¿ã‚¹ã‚¯ã‚­ãƒ¥ãƒ¼ã‚’åˆæœŸåŒ–ï¼ˆupdateStateé–¢æ•°ãŒå®šç¾©ã•ã‚ŒãŸå¾Œï¼‰
        taskQueue1 = new OutputTaskQueue(1, updateState);
        taskQueue2 = new OutputTaskQueue(2, updateState);

        const input1 = new JsInput();

        const input2 = new JsInput();

        const outputFunctions1 = {
          default: (transition) => {
            taskQueue1.addTask("default", transition);
          },
          finishGame: (gameState) => {
            taskQueue1.addTask("finishGame", gameState);
          },
          lotteryNormal: (lotteryResult, slotResult) => {
            taskQueue1.addTask("lotteryNormal", {
              lotteryResult,
              slotResult,
              taskType: "Normal Lottery",
            });
          },
          lotteryRush: (lotteryResult, slotResult) => {
            taskQueue1.addTask("lotteryRush", {
              lotteryResult,
              slotResult,
              taskType: "Rush Lottery",
            });
          },
          lotteryRushContinue: (lotteryResult, slotResult) => {
            taskQueue1.addTask("lotteryRushContinue", {
              lotteryResult,
              slotResult,
              taskType: "Rush Continue",
            });
          },
        };

        const outputFunctions2 = {
          default: (transition) => {
            taskQueue2.addTask("default", transition);
          },
          finishGame: (gameState) => {
            taskQueue2.addTask("finishGame", gameState);
          },
          lotteryNormal: (lotteryResult, slotResult) => {
            taskQueue2.addTask("lotteryNormal", {
              lotteryResult,
              slotResult,
              taskType: "Normal Lottery",
            });
          },
          lotteryRush: (lotteryResult, slotResult) => {
            taskQueue2.addTask("lotteryRush", {
              lotteryResult,
              slotResult,
              taskType: "Rush Lottery",
            });
          },
          lotteryRushContinue: (lotteryResult, slotResult) => {
            taskQueue2.addTask("lotteryRushContinue", {
              lotteryResult,
              slotResult,
              taskType: "Rush Continue",
            });
          },
        };

        const output1 = new JsOutput(
          outputFunctions1.default,
          outputFunctions1.finishGame,
          outputFunctions1.lotteryNormal,
          outputFunctions1.lotteryRush,
          outputFunctions1.lotteryRushContinue,
        );

        const output2 = new JsOutput(
          outputFunctions2.default,
          outputFunctions2.finishGame,
          outputFunctions2.lotteryNormal,
          outputFunctions2.lotteryRush,
          outputFunctions2.lotteryRushContinue,
        );

        const config1 = new Config(
          new BallsConfig(100, 15, 30),
          new Probability(
            new SlotProbability(0.16, 0.3, 0.15),
            new SlotProbability(0.48, 0.2, 0.05),
            new SlotProbability(0.5, 0.25, 0.1),
            (n) => {
              return 0.3 ** (n - 1);
            },
          ),
        );

        const config2 = new Config(
          new BallsConfig(1000, 15, 300),
          new Probability(
            new SlotProbability(0.16, 0.3, 0.15),
            new SlotProbability(0.48, 0.2, 0.05),
            new SlotProbability(0.8, 0.25, 0.1),
            (n) => {
              return 0.6 ** (n - 1);
            },
          ),
        );

        // 2ã¤ã®ã‚²ãƒ¼ãƒ ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆ
        const wasmGame1 = new WasmGame(input1, output1, config1);
        const wasmGame2 = new WasmGame(input2, output2, config2);

        // WASMGameå†ä½œæˆç”¨ã®é–¢æ•°
        const recreateWasmGame1 = () => {
          const newInput1 = new JsInput();
          const newOutput1 = new JsOutput(
            outputFunctions1.default,
            outputFunctions1.finishGame,
            outputFunctions1.lotteryNormal,
            outputFunctions1.lotteryRush,
            outputFunctions1.lotteryRushContinue,
          );
          return new WasmGame(newInput1, newOutput1, config1);
        };

        const recreateWasmGame2 = () => {
          const newInput2 = new JsInput();
          const newOutput2 = new JsOutput(
            outputFunctions2.default,
            outputFunctions2.finishGame,
            outputFunctions2.lotteryNormal,
            outputFunctions2.lotteryRush,
            outputFunctions2.lotteryRushContinue,
          );
          return new WasmGame(newInput2, newOutput2, config2);
        };

        const game1 = new PachinkoGame(
          "canvas1",
          1,
          "a",
          nails1,
          wasmGame1,
          recreateWasmGame1,
        );
        const game2 = new PachinkoGame(
          "canvas2",
          2,
          "l",
          nails2,
          wasmGame2,
          recreateWasmGame2,
        );

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¢ã‚¯ã‚»ã‚¹ã®ãŸã‚windowã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«è¨­å®šï¼ˆWasmGameã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ï¼‰
        window.game1 = wasmGame1;
        window.game2 = wasmGame2;

        // ãƒœã‚¿ãƒ³ã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã‚‹é–¢æ•°
        function launchBall1() {
          game1.launchBall();
        }
        function resetSimulation1() {
          game1.resetSimulation();
        }
        function dropBall2() {
          game2.launchBall();
        }
        function resetSimulation2() {
          game2.resetSimulation();
        }

        // ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹

        // game1.run();
        // game2.run();

        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ï¼ˆé•·æŠ¼ã—å¯¾å¿œï¼‰
        const pressedKeys = new Set();
        const keyIntervals = new Map(); // ã‚­ãƒ¼ã”ã¨ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«IDã‚’ç®¡ç†
        const lastLaunchTimes = new Map(); // ã‚­ãƒ¼ã”ã¨ã®æœ€å¾Œã®ç™ºå°„æ™‚åˆ»ã‚’ç®¡ç†
        const LONG_PRESS_INTERVAL = 700; // 0.7ç§’é–“éš”

        // é€£æ‰“åˆ¶é™ä»˜ãã®ã‚­ãƒ¼å‡¦ç†ï¼ˆåˆå›æŠ¼ä¸‹æ™‚ç”¨ï¼‰
        async function handleKeyPress(key) {
          const now = Date.now();
          const lastLaunchTime = lastLaunchTimes.get(key) || 0;

          // 0.7ç§’é–“éš”ã®ãƒã‚§ãƒƒã‚¯ï¼ˆé€£æ‰“å¯¾å¿œï¼‰
          if (now - lastLaunchTime < LONG_PRESS_INTERVAL) {
            console.log(
              `ã‚­ãƒ¼ ${key} ã¯0.7ç§’é–“éš”åˆ¶é™ã«ã‚ˆã‚Šç„¡è¦–ã•ã‚Œã¾ã—ãŸ (æ®‹ã‚Šæ™‚é–“: ${LONG_PRESS_INTERVAL - (now - lastLaunchTime)}ms)`,
            );
            return;
          }

          // ç™ºå°„æ™‚åˆ»ã‚’æ›´æ–°
          lastLaunchTimes.set(key, now);

          await executeKeyAction(key);
        }

        // é•·æŠ¼ã—æ™‚ã®ã‚­ãƒ¼å‡¦ç†ï¼ˆåˆ¶é™ãªã—ï¼‰
        async function handleLongPress(key) {
          await executeKeyAction(key);
        }

        // å®Ÿéš›ã®ã‚­ãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
        async function executeKeyAction(key) {
          // ã‚¹ã‚¿ãƒ¼ãƒˆã‚­ãƒ¼ã®ãƒã‚§ãƒƒã‚¯
          if (key === "s") {
            console.log(
              `Sã‚­ãƒ¼ãŒæŠ¼ã•ã‚Œã¾ã—ãŸã€‚game1.isGameStarted: ${game1.isGameStarted}`,
            );
            if (!game1.isGameStarted) {
              console.log("ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1ã®ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã—ã¾ã™");
              await game1.startWasmGame();
              return;
            } else {
              console.log("ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1ã¯æ—¢ã«ã‚²ãƒ¼ãƒ é–‹å§‹æ¸ˆã¿ã§ã™");
            }
          }
          if (key === "k") {
            console.log(
              `Kã‚­ãƒ¼ãŒæŠ¼ã•ã‚Œã¾ã—ãŸã€‚game2.isGameStarted: ${game2.isGameStarted}`,
            );
            if (!game2.isGameStarted) {
              console.log("ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2ã®ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã—ã¾ã™");
              await game2.startWasmGame();
              return;
            } else {
              console.log("ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2ã¯æ—¢ã«ã‚²ãƒ¼ãƒ é–‹å§‹æ¸ˆã¿ã§ã™");
            }
          }

          // é€šå¸¸ã®ã‚­ãƒ¼å‡¦ç†ï¼ˆã‚²ãƒ¼ãƒ é–‹å§‹å¾Œã®ã¿ï¼‰
          if (key === game1.keyBinding && game1.isGameStarted) {
            game1.handleKeyInput(game1.keyBinding);
          }
          if (key === game2.keyBinding && game2.isGameStarted) {
            game2.handleKeyInput(game2.keyBinding);
          }
        }

        document.addEventListener("keydown", (event) => {
          const key = event.key.toLowerCase();

          // æ—¢ã«æŠ¼ã•ã‚Œã¦ã„ã‚‹ã‚­ãƒ¼ã®å ´åˆã¯ç„¡è¦–ï¼ˆãƒªãƒ”ãƒ¼ãƒˆã‚¤ãƒ™ãƒ³ãƒˆé˜²æ­¢ï¼‰
          if (pressedKeys.has(key)) {
            return;
          }

          pressedKeys.add(key);

          // æœ€åˆã®ã‚­ãƒ¼å…¥åŠ›ã‚’å³åº§ã«å®Ÿè¡Œï¼ˆé€£æ‰“åˆ¶é™ä»˜ãï¼‰
          handleKeyPress(key).catch(console.error);

          // é•·æŠ¼ã—ç”¨ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã‚’è¨­å®š
          if (key === game1.keyBinding || key === game2.keyBinding) {
            const intervalId = setInterval(() => {
              if (pressedKeys.has(key)) {
                console.log(`Long press: ${key}`);
                handleLongPress(key).catch(console.error);
              } else {
                clearInterval(intervalId);
                keyIntervals.delete(key);
              }
            }, LONG_PRESS_INTERVAL);

            keyIntervals.set(key, intervalId);
          }
        });

        document.addEventListener("keyup", (event) => {
          const key = event.key.toLowerCase();
          pressedKeys.delete(key);

          // ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã‚’ã‚¯ãƒªã‚¢
          if (keyIntervals.has(key)) {
            clearInterval(keyIntervals.get(key));
            keyIntervals.delete(key);
          }
        });

        // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ•ã‚©ãƒ¼ã‚«ã‚¹å¤–ã‚Œæ™‚ã«ã‚­ãƒ¼çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
        window.addEventListener("blur", () => {
          console.log("Window lost focus, resetting key states");
          pressedKeys.clear();
          lastLaunchTimes.clear();

          // å…¨ã¦ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã‚’ã‚¯ãƒªã‚¢
          keyIntervals.forEach((intervalId, key) => {
            clearInterval(intervalId);
          });
          keyIntervals.clear();
        });

        // ãƒšãƒ¼ã‚¸ã®å¯è¦–æ€§ãŒå¤‰ã‚ã£ãŸæ™‚ã‚‚ãƒªã‚»ãƒƒãƒˆ
        document.addEventListener("visibilitychange", () => {
          if (document.hidden) {
            console.log("Page hidden, resetting key states");
            pressedKeys.clear();
            lastLaunchTimes.clear();

            keyIntervals.forEach((intervalId, key) => {
              clearInterval(intervalId);
            });
            keyIntervals.clear();
          }
        });

        // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šé•·æŠ¼ã—çŠ¶æ…‹ç¢ºèªé–¢æ•°
        window.debugKeyStates = () => {
          console.log("=== ã‚­ãƒ¼çŠ¶æ…‹ãƒ‡ãƒãƒƒã‚° ===");
          console.log("æŠ¼ã•ã‚Œã¦ã„ã‚‹ã‚­ãƒ¼:", Array.from(pressedKeys));
          console.log("é•·æŠ¼ã—ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«:", Array.from(keyIntervals.keys()));
          console.log("ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«æ•°:", keyIntervals.size);
          console.log("æœ€å¾Œã®ç™ºå°„æ™‚åˆ»:", Object.fromEntries(lastLaunchTimes));
          const now = Date.now();
          lastLaunchTimes.forEach((time, key) => {
            const elapsed = now - time;
            console.log(
              `ã‚­ãƒ¼ ${key}: ${elapsed}mså‰ã«ç™ºå°„ (æ¬¡å›ç™ºå°„ã¾ã§${Math.max(0, LONG_PRESS_INTERVAL - elapsed)}ms)`,
            );
          });
        };

        window.clearAllKeyStates = () => {
          console.log("å…¨ã¦ã®ã‚­ãƒ¼çŠ¶æ…‹ã‚’å¼·åˆ¶ã‚¯ãƒªã‚¢");
          pressedKeys.clear();
          lastLaunchTimes.clear();
          keyIntervals.forEach((intervalId, key) => {
            clearInterval(intervalId);
          });
          keyIntervals.clear();
        };

        // èƒŒæ™¯å‹•ç”»ã‚’è¨­å®šã™ã‚‹ãŸã‚ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
        window.setBackgroundVideo = (playerId, videoSrc) => {
          const video = document.getElementById(`video${playerId}`);
          if (video && videoSrc) {
            video.src = videoSrc;
            video.load(); // æ–°ã—ã„ã‚½ãƒ¼ã‚¹ã‚’èª­ã¿è¾¼ã¿
            console.log(`Player ${playerId}ã®èƒŒæ™¯å‹•ç”»ã‚’è¨­å®š: ${videoSrc}`);
          }
        };

        // ä¸¡æ–¹ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«åŒã˜å‹•ç”»ã‚’è¨­å®šã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
        window.setBackgroundVideoForBoth = (videoSrc) => {
          window.setBackgroundVideo(1, videoSrc);
          window.setBackgroundVideo(2, videoSrc);
        };

        // åˆæœŸçŠ¶æ…‹ã®è¡¨ç¤ºã‚’æ›´æ–°
        const element1 = document.getElementById("state1");
        const element2 = document.getElementById("state2");
        if (element1) element1.textContent = "æœªé–‹å§‹ - Sã‚­ãƒ¼ã§ã‚¹ã‚¿ãƒ¼ãƒˆ";
        if (element2) element2.textContent = "æœªé–‹å§‹ - Kã‚­ãƒ¼ã§ã‚¹ã‚¿ãƒ¼ãƒˆ";

        console.log("ğŸ® ãƒ‡ãƒ¥ã‚¢ãƒ«ãƒ‘ãƒãƒ³ã‚³ã‚²ãƒ¼ãƒ æº–å‚™å®Œäº†ï¼");
        console.log(
          "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1: Sã‚­ãƒ¼ã§ã‚²ãƒ¼ãƒ é–‹å§‹ã€Aã‚­ãƒ¼ã§çƒã‚’è½ã¨ã™ (é•·æŠ¼ã—å¯¾å¿œ - 0.7ç§’é–“éš”)",
        );
        console.log(
          "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2: Kã‚­ãƒ¼ã§ã‚²ãƒ¼ãƒ é–‹å§‹ã€Lã‚­ãƒ¼ã§çƒã‚’è½ã¨ã™ (é•·æŠ¼ã—å¯¾å¿œ - 0.7ç§’é–“éš”)",
        );
        console.log(
          "ãƒ‡ãƒãƒƒã‚°ã‚³ãƒãƒ³ãƒ‰: window.debugKeyStates(), window.clearAllKeyStates()",
        );
      }

      main();
    </script>
  </body>
</html>
