<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>パチスロ</title>
    <style>
      body {
        font-family: "Helvetica Neue", Arial, sans-serif;
        display: flex;
        flex-direction: column;
        gap: 18px;
        align-items: center;
        padding: 32px;
        background: #111;
        color: #eee;
      }

      .game-container {
        display: flex;
        gap: 90px;
        justify-content: center;
        align-items: flex-start;
      }

      .game-unit {
        display: flex;
        gap: 30px;
        align-items: flex-start;
        position: relative;
      }

      .canvas-container {
        flex: 0 0 auto;
      }

      canvas {
        border: 2px solid #444;
        background-color: #2a2a2a;
      }

      .right-panel {
        flex: 0 0 350px;
        height: 500px;
        padding: 10px;
        position: relative;
        overflow: visible;
      }

      .right-panel video {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        z-index: -999;
        transform: translateZ(-1px);
        will-change: transform;
      }

      .right-panel > * {
        position: relative;
        z-index: 1;
      }

      .timer-display {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-family: "Courier New", monospace;
        font-size: 18px;
        font-weight: bold;
        z-index: 100;
        display: inline-block;
        width: auto;
        text-align: center;
        border: 2px solid rgba(255, 255, 255, 0.3);
      }

      .time-settings {
        position: absolute;
        top: 50px;
        left: 10px;
        background-color: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 15px;
        border-radius: 8px;
        z-index: 20;
        display: none;
        border: 2px solid rgba(255, 255, 255, 0.3);
        min-width: 200px;
      }

      .time-settings.visible {
        display: block;
      }

      .time-settings label {
        display: block;
        margin-bottom: 10px;
        font-size: 14px;
      }

      .time-settings input {
        width: 60px;
        padding: 4px;
        margin-left: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }

      .time-settings button {
        background-color: #4caf50;
        color: white;
        border: none;
        padding: 6px 12px;
        margin: 5px 5px 0 0;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      }

      .time-settings button:hover {
        background-color: #45a049;
      }

      .time-settings button:last-child {
        background-color: #f44336;
      }

      .time-settings button:last-child:hover {
        background-color: #da190b;
      }

      /* Lottery video overlay styles for 9:16 aspect ratio */
      .right-panel {
        position: relative;
        overflow: visible;
        height: 500px;
        min-width: 200px;
      }

      .video-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -998;
        border-radius: 8px;
        transform: translateZ(-1px);
        will-change: transform;
      }

      .video-overlay video {
        width: 100%;
        height: 100%;
        object-fit: fill;
        border-radius: 4px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
        z-index: -999;
        transform: translateZ(-2px);
        will-change: transform;
      }

      /*.right-panel > *:not(.video-overlay) {
        position: relative;
        z-index: 2;
      }*/

      .background-video {
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -999;
        border-radius: 4px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
        transform: translateZ(-2px);
        will-change: transform;
      }

      .state {
        padding: 20px;
        /*background-color: rgba(0, 0, 0, 0.7);*/
        color: white;
        border-radius: 8px;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        background-color: rgba(0, 0, 0, 0.5);
        text-align: center;
        font-size: 20px;
        font-weight: bold;
        position: absolute;
        top: 80px;
        right: 20px;
        width: 310px;
        z-index: 100;
      }

      .slot-container {
        margin-top: 300px;
        justify-content: center;
        align-items: center;
        display: flex;
        gap: 10px;
      }

      .slot-num {
        height: 100px;
        font-size: 50px;
        text-align: center;
        flex: 1;
      }

      :root {
        --reel-width: 120px;
        --cell-height: 80px; /* 1つの数字セルの高さ */
        --visible-cells: 3; /* 見えるセル数（中央＋上下の見切れ） */
      }

      .slot-wrap {
        display: flex;
        gap: 10px;
        justify-content: center;
        /*background-color: rgba(0, 0, 0, 0.6);*/
        padding: 15px;
        border-radius: 8px;
        position: absolute;
        top: 160px;
        right: 20px;
        width: 310px;
        z-index: 100;
      }

      .reel {
        width: var(--reel-width);
        height: calc(
          var(--cell-height) * 1
        ); /* 見せたい中央の高さ（中央セル1つ分） */
        position: relative;
        overflow: hidden;
        border-radius: 12px;
        background: linear-gradient(
          180deg,
          rgba(2, 2, 2, 0.5),
          rgba(16, 16, 18, 0.5)
        );
        box-shadow:
          0 6px 18px rgba(0, 0, 0, 0.7),
          inset 0 2px 0 rgba(255, 255, 255, 0.02);
        display: flex;
        align-items: center;
        justify-content: center;
      }

      /* 中央の数字を大きく見せるため、内側に余白を持たせたオーバーフロー領域を用意 */
      .reel-viewport {
        position: relative;
        width: 100%;
        height: calc(var(--cell-height) * var(--visible-cells));
        top: calc(var(--cell-height) * -1); /* 中央セルを可視領域の中央に */
        overflow: hidden;
      }

      .reel-list {
        /* リールの要素一覧 */
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
      }

      .cell {
        width: 100%;
        height: var(--cell-height);
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: hidden;
      }

      .cell img {
        width: 90%;
        height: 90%;
        object-fit: contain;
        image-rendering: -webkit-optimize-contrast;
        image-rendering: crisp-edges;
      }

      /* フェードエフェクトで上下をぼかす */
      .reel:before,
      .reel:after {
        content: "";
        position: absolute;
        left: 0;
        right: 0;
        height: calc(var(--cell-height) * 0.4);
        pointer-events: none;
        z-index: 2;
      }
      .reel:before {
        top: 0;
        background: linear-gradient(
          to bottom,
          rgba(17, 17, 17, 0.9) 0%,
          transparent 100%
        );
      }
      .reel:after {
        bottom: 0;
        background: linear-gradient(
          to top,
          rgba(17, 17, 17, 0.9) 0%,
          transparent 100%
        );
      }

      /* 中央フレームの強調 */
      .center-frame {
        position: absolute;
        top: 50%;
        left: 50%;
        width: calc(100% - 8px);
        height: calc(var(--cell-height) - 8px);
        transform: translate(-50%, -50%);
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-radius: 6px;
        pointer-events: none;
        z-index: 3;
      }

      /* Configuration Modal Styles */
      .config-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        z-index: 1000;
      }

      .config-modal.visible {
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .config-content {
        background-color: #222;
        color: white;
        padding: 30px;
        border-radius: 12px;
        max-width: 90vw;
        max-height: 90vh;
        overflow-y: auto;
        position: relative;
        border: 2px solid #444;
      }

      .config-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 25px;
        border-bottom: 2px solid #444;
        padding-bottom: 15px;
      }

      .config-header h2 {
        margin: 0;
        color: #eee;
        font-size: 24px;
      }

      .config-close {
        background: #e74c3c;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
      }

      .config-close:hover {
        background: #c0392b;
      }

      .config-main {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 30px;
      }

      .config-section {
        background-color: #2a2a2a;
        padding: 20px;
        border-radius: 8px;
        border: 1px solid #444;
      }

      .config-section h3 {
        margin: 0 0 15px 0;
        color: #eee;
        font-size: 18px;
        border-bottom: 1px solid #444;
        padding-bottom: 10px;
      }

      .nail-canvas-container {
        position: relative;
        border: 2px solid #444;
        background-color: #2a2a2a;
        border-radius: 8px;
        overflow: hidden;
      }

      .nail-canvas {
        cursor: crosshair;
      }

      .nail-controls {
        margin-top: 15px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .nail-controls button {
        background: #3498db;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
      }

      .nail-controls button:hover {
        background: #2980b9;
      }

      .nail-controls button.danger {
        background: #e74c3c;
      }

      .nail-controls button.danger:hover {
        background: #c0392b;
      }

      .config-form {
        display: grid;
        gap: 15px;
      }

      .config-group {
        display: grid;
        gap: 10px;
      }

      .config-group label {
        font-size: 14px;
        font-weight: bold;
        color: #ccc;
      }

      .config-group input,
      .config-group textarea {
        background: #333;
        border: 1px solid #555;
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 14px;
      }

      .config-group input:focus,
      .config-group textarea:focus {
        outline: none;
        border-color: #3498db;
      }

      .config-group textarea {
        min-height: 120px;
        font-family: monospace;
        resize: vertical;
      }

      .data-controls {
        margin-top: 15px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .data-controls button {
        background: #27ae60;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
      }

      .data-controls button:hover {
        background: #229954;
      }

      .data-controls button.load {
        background: #f39c12;
      }

      .data-controls button.load:hover {
        background: #e67e22;
      }

      .config-footer {
        margin-top: 30px;
        text-align: center;
        border-top: 2px solid #444;
        padding-top: 20px;
      }

      .apply-config {
        background: #27ae60;
        color: white;
        border: none;
        padding: 12px 30px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
      }

      .apply-config:hover {
        background: #229954;
      }

      .config-instructions {
        background: #34495e;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        font-size: 14px;
        line-height: 1.5;
      }

      .config-instructions strong {
        color: #3498db;
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <!-- プレイヤー1 -->
      <div class="game-unit">
        <div class="canvas-container">
          <canvas id="canvas1"></canvas>
        </div>
        <div class="right-panel" id="right-panel1">
          <div class="timer-display" id="timer-display1">5:00</div>
          <div class="time-settings" id="time-settings1">
            <label
              >Timer (minutes):
              <input type="number" id="timer-input1" value="5" min="1" max="60"
            /></label>
            <button onclick="applyTimeSettings(1)">Apply</button>
            <button onclick="toggleTimeSettings(1)">Close</button>
          </div>
          <video
            class="background-video"
            id="video1"
            autoplay
            muted
            loop
            playsinline
          >
            <source
              src="images/background/background-normal.mp4"
              id="source1"
            />
          </video>
        </div>

        <div class="state" id="state1">Uninitialized</div>

        <div class="slot-wrap" id="slot1">
          <!-- 3つのリールを用意 -->
          <div class="reel" data-index="0">
            <div class="reel-viewport">
              <div class="reel-list"></div>
            </div>
            <div class="center-frame"></div>
          </div>

          <div class="reel" data-index="1">
            <div class="reel-viewport">
              <div class="reel-list"></div>
            </div>
            <div class="center-frame"></div>
          </div>

          <div class="reel" data-index="2">
            <div class="reel-viewport">
              <div class="reel-list"></div>
            </div>
            <div class="center-frame"></div>
          </div>
        </div>
      </div>

      <!-- プレイヤー2 -->
      <div class="game-unit">
        <div class="canvas-container">
          <canvas id="canvas2"></canvas>
        </div>
        <div class="right-panel" id="right-panel2">
          <div class="timer-display" id="timer-display2">5:00</div>
          <div class="time-settings" id="time-settings2">
            <label
              >Timer (minutes):
              <input type="number" id="timer-input2" value="5" min="1" max="60"
            /></label>
            <button onclick="applyTimeSettings(2)">Apply</button>
            <button onclick="toggleTimeSettings(2)">Close</button>
          </div>
          <video
            class="background-video"
            id="video2"
            autoplay
            muted
            loop
            playsinline
          >
            <source
              src="images/background/background-normal.mp4"
              id="source2"
            />
          </video>
        </div>

        <div class="state" id="state2">Uninitialized</div>

        <div class="slot-wrap" id="slot2">
          <!-- 3つのリールを用意 -->
          <div class="reel" data-index="0">
            <div class="reel-viewport">
              <div class="reel-list"></div>
            </div>
            <div class="center-frame"></div>
          </div>

          <div class="reel" data-index="1">
            <div class="reel-viewport">
              <div class="reel-list"></div>
            </div>
            <div class="center-frame"></div>
          </div>

          <div class="reel" data-index="2">
            <div class="reel-viewport">
              <div class="reel-list"></div>
            </div>
            <div class="center-frame"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Configuration Modal for Player 1 -->
    <div id="config-modal-1" class="config-modal">
      <div class="config-content">
        <div class="config-header">
          <h2>Player 1 Configuration</h2>
          <button class="config-close" id="config-close-1">Close</button>
        </div>

        <div class="config-instructions">
          <strong>Instructions:</strong> Click on the nail canvas to add/remove
          nails. Edit configuration values below. Changes will be applied when
          you close this modal.
        </div>

        <div class="config-main">
          <!-- Nail Editor Section -->
          <div class="config-section">
            <h3>Nail Editor</h3>
            <div class="nail-canvas-container">
              <canvas
                id="nail-canvas-1"
                class="nail-canvas"
                width="200"
                height="400"
              ></canvas>
            </div>
            <div class="nail-controls">
              <button id="clear-nails-1">Clear All</button>
              <button id="random-nails-1">Random Nails</button>
              <button class="danger" id="remove-last-nail-1">
                Remove Last
              </button>
            </div>

            <div class="config-group">
              <label>Nail Data (JSON format):</label>
              <textarea
                id="nail-data-1"
                placeholder='[{"x": 50, "y": 100}, {"x": 150, "y": 200}]'
              ></textarea>
              <div class="data-controls">
                <button id="export-nail-data-1">Export Data</button>
                <button class="load" id="import-nail-data-1">
                  Import Data
                </button>
              </div>
            </div>
          </div>

          <!-- Config Editor Section -->
          <div class="config-section">
            <h3>Game Configuration</h3>
            <div class="config-form">
              <div class="config-group">
                <label>Initial Balls:</label>
                <input
                  type="number"
                  id="config-init-balls-1"
                  min="1"
                  max="10000"
                  value="1000"
                />
              </div>
              <div class="config-group">
                <label>Incremental Balls:</label>
                <input
                  type="number"
                  id="config-incremental-balls-1"
                  min="1"
                  max="1000"
                  value="15"
                />
              </div>
              <div class="config-group">
                <label>Incremental Rush:</label>
                <input
                  type="number"
                  id="config-incremental-rush-1"
                  min="1"
                  max="1000"
                  value="300"
                />
              </div>

              <div class="config-group">
                <label>Normal Win Probability:</label>
                <input
                  type="number"
                  id="config-normal-win-1"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.16"
                />
              </div>
              <div class="config-group">
                <label>Normal Fake Win Probability:</label>
                <input
                  type="number"
                  id="config-normal-fake-win-1"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.3"
                />
              </div>
              <div class="config-group">
                <label>Normal Fake Lose Probability:</label>
                <input
                  type="number"
                  id="config-normal-fake-lose-1"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.15"
                />
              </div>

              <div class="config-group">
                <label>Into Rush Win Probability:</label>
                <input
                  type="number"
                  id="config-into-rush-win-1"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.8"
                />
              </div>
              <div class="config-group">
                <label>Into Rush Fake Win Probability:</label>
                <input
                  type="number"
                  id="config-into-rush-fake-win-1"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.1"
                />
              </div>
              <div class="config-group">
                <label>Into Rush Fake Lose Probability:</label>
                <input
                  type="number"
                  id="config-into-rush-fake-lose-1"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.1"
                />
              </div>

              <div class="config-group">
                <label>Rush Win Probability:</label>
                <input
                  type="number"
                  id="config-rush-win-1"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.48"
                />
              </div>
              <div class="config-group">
                <label>Rush Fake Win Probability:</label>
                <input
                  type="number"
                  id="config-rush-fake-win-1"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.2"
                />
              </div>
              <div class="config-group">
                <label>Rush Fake Lose Probability:</label>
                <input
                  type="number"
                  id="config-rush-fake-lose-1"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.05"
                />
              </div>

              <div class="config-group">
                <label>Rush Continue Win Probability:</label>
                <input
                  type="number"
                  id="config-rush-continue-win-1"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.5"
                />
              </div>
              <div class="config-group">
                <label>Rush Continue Fake Win Probability:</label>
                <input
                  type="number"
                  id="config-rush-continue-fake-win-1"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.25"
                />
              </div>
              <div class="config-group">
                <label>Rush Continue Fake Lose Probability:</label>
                <input
                  type="number"
                  id="config-rush-continue-fake-lose-1"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.1"
                />
              </div>
            </div>
          </div>
        </div>

        <div class="config-footer">
          <button class="apply-config" id="apply-config-1">
            Apply Configuration
          </button>
        </div>
      </div>
    </div>

    <!-- Configuration Modal for Player 2 -->
    <div id="config-modal-2" class="config-modal">
      <div class="config-content">
        <div class="config-header">
          <h2>Player 2 Configuration</h2>
          <button class="config-close" id="config-close-2">Close</button>
        </div>

        <div class="config-instructions">
          <strong>Instructions:</strong> Click on the nail canvas to add/remove
          nails. Edit configuration values below. Changes will be applied when
          you close this modal.
        </div>

        <div class="config-main">
          <!-- Nail Editor Section -->
          <div class="config-section">
            <h3>Nail Editor</h3>
            <div class="nail-canvas-container">
              <canvas
                id="nail-canvas-2"
                class="nail-canvas"
                width="200"
                height="400"
              ></canvas>
            </div>
            <div class="nail-controls">
              <button id="clear-nails-2">Clear All</button>
              <button id="random-nails-2">Random Nails</button>
              <button class="danger" id="remove-last-nail-2">
                Remove Last
              </button>
            </div>

            <div class="config-group">
              <label>Nail Data (JSON format):</label>
              <textarea
                id="nail-data-2"
                placeholder='[{"x": 50, "y": 100}, {"x": 150, "y": 200}]'
              ></textarea>
              <div class="data-controls">
                <button id="export-nail-data-2">Export Data</button>
                <button class="load" id="import-nail-data-2">
                  Import Data
                </button>
              </div>
            </div>
          </div>

          <!-- Config Editor Section -->
          <div class="config-section">
            <h3>Game Configuration</h3>
            <div class="config-form">
              <div class="config-group">
                <label>Initial Balls:</label>
                <input
                  type="number"
                  id="config-init-balls-2"
                  min="1"
                  max="10000"
                  value="1000"
                />
              </div>
              <div class="config-group">
                <label>Incremental Balls:</label>
                <input
                  type="number"
                  id="config-incremental-balls-2"
                  min="1"
                  max="1000"
                  value="15"
                />
              </div>
              <div class="config-group">
                <label>Incremental Rush:</label>
                <input
                  type="number"
                  id="config-incremental-rush-2"
                  min="1"
                  max="1000"
                  value="300"
                />
              </div>

              <div class="config-group">
                <label>Normal Win Probability:</label>
                <input
                  type="number"
                  id="config-normal-win-2"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.16"
                />
              </div>
              <div class="config-group">
                <label>Normal Fake Win Probability:</label>
                <input
                  type="number"
                  id="config-normal-fake-win-2"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.3"
                />
              </div>
              <div class="config-group">
                <label>Normal Fake Lose Probability:</label>
                <input
                  type="number"
                  id="config-normal-fake-lose-2"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.15"
                />
              </div>

              <div class="config-group">
                <label>Into Rush Win Probability:</label>
                <input
                  type="number"
                  id="config-into-rush-win-2"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.8"
                />
              </div>
              <div class="config-group">
                <label>Into Rush Fake Win Probability:</label>
                <input
                  type="number"
                  id="config-into-rush-fake-win-2"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.1"
                />
              </div>
              <div class="config-group">
                <label>Into Rush Fake Lose Probability:</label>
                <input
                  type="number"
                  id="config-into-rush-fake-lose-2"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.1"
                />
              </div>

              <div class="config-group">
                <label>Rush Win Probability:</label>
                <input
                  type="number"
                  id="config-rush-win-2"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.48"
                />
              </div>
              <div class="config-group">
                <label>Rush Fake Win Probability:</label>
                <input
                  type="number"
                  id="config-rush-fake-win-2"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.2"
                />
              </div>
              <div class="config-group">
                <label>Rush Fake Lose Probability:</label>
                <input
                  type="number"
                  id="config-rush-fake-lose-2"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.05"
                />
              </div>

              <div class="config-group">
                <label>Rush Continue Win Probability:</label>
                <input
                  type="number"
                  id="config-rush-continue-win-2"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.8"
                />
              </div>
              <div class="config-group">
                <label>Rush Continue Fake Win Probability:</label>
                <input
                  type="number"
                  id="config-rush-continue-fake-win-2"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.25"
                />
              </div>
              <div class="config-group">
                <label>Rush Continue Fake Lose Probability:</label>
                <input
                  type="number"
                  id="config-rush-continue-fake-lose-2"
                  min="0"
                  max="1"
                  step="0.01"
                  value="0.1"
                />
              </div>
            </div>
          </div>
        </div>

        <div class="config-footer">
          <button class="apply-config" id="apply-config-2">
            Apply Configuration
          </button>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>

    <script type="module">
      // グローバルビデオリストキャッシュ
      let globalVideoList = null;

      // video-list.jsonを事前に読み込む関数
      async function preloadVideoList() {
        try {
          const response = await fetch("video-list.json");
          if (response.ok) {
            globalVideoList = await response.json();
            console.log(
              "📚 video-list.json preloaded successfully:",
              globalVideoList,
            );
          } else {
            console.error(
              `❌ Failed to preload video-list.json: ${response.status}`,
            );
            globalVideoList = null;
          }
        } catch (error) {
          console.error("💥 Error preloading video-list.json:", error);
          globalVideoList = null;
        }
      }

      const REPEAT = 30; // 数字列を何回繰り返すか
      const numbers = [1, 2, 3, 4, 5, 6, 7, 8]; // [1,2,3,4,5,6,7,8]
      const reels1 = Array.from(document.querySelectorAll("#slot1 .reel"));
      const reels2 = Array.from(document.querySelectorAll("#slot2 .reel"));
      const cellH =
        parseInt(
          getComputedStyle(document.documentElement).getPropertyValue(
            "--cell-height",
          ),
        ) || 64;

      const backgroundVideoPaths = {
        normal: "images/background/background-normal.mp4",
        rush: "images/background/background-rush.mp4",
      };

      let isProcessingFinishTask1 = false;
      let isProcessingFinishTask2 = false;

      function setIsProcessingFinishTask(playerId, isFinish) {
        console.log(
          `Player ${playerId} isProcessingFinishTask set to ${isFinish}`,
        );
        if (playerId === 1) {
          isProcessingFinishTask1 = isFinish;
        } else if (playerId === 2) {
          isProcessingFinishTask2 = isFinish;
        }
      }

      // タスクキューシステム
      class OutputTaskQueue {
        constructor(playerId, updateStateFunction) {
          this.playerId = playerId;
          this.queue = [];
          this.isProcessing = false;
          this.updateState = updateStateFunction;
        }

        // タスクをキューに追加
        addTask(taskType, taskData) {
          console.log(
            `Player ${this.playerId} task queued: ${taskType}`,
            taskData,
          );
          this.queue.push({
            type: taskType,
            data: taskData,
            timestamp: Date.now(),
          });
          this.processNext();
        }

        // 次のタスクを処理
        async processNext() {
          if (this.isProcessing || this.queue.length === 0) {
            return;
          }

          console.log(`Player ${this.playerId} queue: ${this.queue}`);

          this.isProcessing = true;
          const task = this.queue.shift();
          console.log(`Player ${this.playerId} processing task: ${task.type}`);

          try {
            await this.executeTask(task);
          } catch (error) {
            console.error(`Player ${this.playerId} task error:`, error);
          }

          this.isProcessing = false;

          // 次のタスクがあれば続行
          if (this.queue.length > 0) {
            setTimeout(() => this.processNext(), 100);
          }
        }

        // タスクを実行
        async executeTask(task) {
          const { type, data } = task;

          switch (type) {
            case "default":
              this.executeDefaultTask(data);
              break;
            case "finishGame":
              this.executeFinishGameTask(data);
              break;
            case "lotteryNormal":
              await this.executeNormalLotteryTask(data);
              break;
            case "lotteryIntoRush":
              await this.executeIntoRushLotteryTask(data);
              break;
            case "lotteryRush":
              await this.executeRushLotteryTask(data);
              break;
            case "lotteryRushContinue":
              await this.executeRushContinueTask(data);
              break;
            default:
              console.warn(`Unknown task type: ${type}`);
          }
        }

        // defaultタスクの実行
        executeDefaultTask(transition) {
          console.log(`P${this.playerId} Transition:`, transition);
          if (transition.after) {
            if (transition.before) {
              if (
                transition.before.type === "Normal" &&
                transition.after.type === "Rush"
              ) {
                this.changeBackgroundVideo(backgroundVideoPaths.rush);
              } else if (
                transition.before.type === "Rush" &&
                transition.after.type === "Normal"
              ) {
                this.changeBackgroundVideo(backgroundVideoPaths.normal);
              }
            }
            this.updateState(this.playerId, transition.after);
          }
        }

        // finishGameタスクの実行
        executeFinishGameTask(gameState) {
          console.log(`P${this.playerId} Game Finished:`, gameState);
          this.updateState(this.playerId, gameState, "終了しました");
          this.changeBackgroundVideo(backgroundVideoPaths.normal);
        }

        async executeNormalLotteryTask(data) {
          await this.executeLotteryTask(data);
        }

        async executeIntoRushLotteryTask(data) {
          await this.executeLotteryTask(data);
        }

        async executeRushLotteryTask(data) {
          await this.executeLotteryTask(data);
        }

        async executeRushContinueTask(data) {
          await this.executeLotteryTask(data);
        }

        // 抽選タスクの実行（映像再生とスロット回転）
        async executeLotteryTask(data) {
          const { lotteryResult, slotResult, taskType } = data;
          console.log(
            `P${this.playerId} ${taskType}:`,
            lotteryResult,
            slotResult,
          );

          const slot = slotResult[1] || slotResult[0];

          // 抽選結果に基づいて映像フォルダを決定
          let videoFolder = "";
          console.log(
            `P${this.playerId} Lottery result structure:`,
            lotteryResult,
          );

          // Handle different possible lottery result formats
          if (lotteryResult.Win !== undefined) {
            // Rust-style enum format: { Win: "Default" } or { Win: "FakeWin" }
            videoFolder =
              lotteryResult.Win === "Default" ? "images/win" : "images/fakewin";
          } else if (lotteryResult.Lose !== undefined) {
            // Rust-style enum format: { Lose: "Default" } or { Lose: "FakeLose" }
            videoFolder =
              lotteryResult.Lose === "FakeLose" ? "images/lose" : "";
          } else if (lotteryResult.type === "Win") {
            // JavaScript-style format: { type: "Win", winType: "Default" }
            videoFolder =
              lotteryResult.winType === "Default"
                ? "images/win"
                : "images/fakewin";
          } else if (lotteryResult.type === "Lose") {
            // JavaScript-style format: { type: "Lose", loseType: "Default" }
            videoFolder =
              lotteryResult.loseType === "FakeLose" ? "images/lose" : "";
          }

          console.log(
            `P${this.playerId} Selected video folder: ${videoFolder}`,
          );

          // If no video folder specified (regular lose), just spin slots
          if (!videoFolder) {
            console.log(
              `P${this.playerId} No video needed for regular lose, spinning slots only`,
            );
            await this.fallbackToDefaultSlot(slot);
            return;
          }

          try {
            // フォルダから映像ファイルを取得してランダム選択
            const videoFile = await this.selectRandomVideo(videoFolder);
            if (!videoFile) {
              console.warn(
                `No video found in ${videoFolder}, using default slot animation`,
              );
              await this.fallbackToDefaultSlot(slot);
              return;
            }

            console.log(`P${this.playerId} Selected video: ${videoFile}`);

            try {
              // 映像を背景で再生し、長さを取得
              const videoDuration = await this.playBackgroundVideo(
                videoFile,
                defaultDuration + 2 * defaultLag,
              );
              console.log(
                `P${this.playerId} Playing ${videoFile} for ${videoDuration}ms`,
              );

              // スロットをその長さだけ回転させる
              await this.spinSlotForVideoDuration(slot, videoDuration);
            } catch (videoError) {
              console.warn(
                `P${this.playerId} Video playback failed:`,
                videoError.message,
              );
              console.log(
                `P${this.playerId} Falling back to default slot animation`,
              );
              await this.fallbackToDefaultSlot(slot);
            }
          } catch (error) {
            console.error(
              `P${this.playerId} Error in lottery task execution:`,
              error,
            );
            await this.fallbackToDefaultSlot(slot);
          }

          console.log(`Player ${this.playerId} lottery task completed`);
        }

        // フォルダからランダムに映像ファイルを選択（フォールバック付き）
        async selectRandomVideo(folderPath) {
          console.log(
            `🎯 Loading videos from cached JSON for folder: ${folderPath}`,
          );

          const folderName = folderPath.split("/").pop(); // Extract folder name (win, fakewin, lose, etc.)

          // グローバルキャッシュから取得を試行
          let fallbackFiles = {};
          if (globalVideoList) {
            const videos = globalVideoList[folderName] || [];

            console.log(`🎬 Found ${videos.length} videos:`, videos);
            if (videos.length > 0) {
              const randomIndex = Math.floor(Math.random() * videos.length);
              const selectedVideo = `${folderPath}/${videos[randomIndex]}`;
              console.log(`✅ Selected video: ${selectedVideo}`);
              return selectedVideo;
            }

            // Update fallbackFiles from cached video-list.json
            fallbackFiles = {
              "images/win": globalVideoList["win"] || [],
              "images/fakewin": globalVideoList["fakewin"] || [],
              "images/lose": globalVideoList["lose"] || [],
            };
          } else {
            console.warn(
              `⚠️ Global video list not available, using static fallback`,
            );
            // Static fallback files if global video list is not available
            fallbackFiles = {
              "images/win": ["once-input-win.mov"],
              "images/fakewin": ["once-input-fakewin.mov"],
              "images/lose": ["once-input-lose.mov"],
            };
          }

          // Use fallback files if API fails or returns empty
          const fallback = fallbackFiles[folderPath];
          if (fallback && fallback.length > 0) {
            const randomIndex = Math.floor(Math.random() * fallback.length);
            const fallbackVideo = `${folderPath}/${fallback[randomIndex]}`;
            console.log(`🔄 Using fallback video: ${fallbackVideo}`);
            return fallbackVideo;
          }

          console.error(`❌ No fallback available for folder: ${folderPath}`);
          return null;
        }

        async changeBackgroundVideo(videoPath) {
          const originalVideo = document.getElementById(
            `video${this.playerId}`,
          );
          const originalVideoSource = document.getElementById(
            `source${this.playerId}`,
          );
          if (!originalVideoSource) {
            console.error(
              `❌ Source element not found for player ${this.playerId}`,
            );
            return;
          }
          originalVideoSource.src = videoPath;
          await originalVideo.load();
        }

        // 新しいvideoタグを作成し既存タグと入れ替えて映像を再生
        async playBackgroundVideo(videoPath, withSleep = 0) {
          return new Promise((resolve, reject) => {
            const rightPanel = document.getElementById(
              `right-panel${this.playerId}`,
            );
            const originalVideo = document.getElementById(
              `video${this.playerId}`,
            );

            if (!rightPanel || !originalVideo) {
              reject(
                new Error(
                  `Required elements not found for player ${this.playerId}`,
                ),
              );
              return;
            }

            // 新しいvideoタグを作成
            const newVideo = document.createElement("video");
            const newSource = document.createElement("source");

            // 新しいvideoタグの設定
            newVideo.id = `temp-video${this.playerId}`;
            newVideo.style.position = "absolute";
            newVideo.style.top = "0";
            newVideo.style.left = "0";
            newVideo.style.width = "100%";
            newVideo.style.height = "100%";
            newVideo.style.objectFit = "cover";
            newVideo.style.zIndex = "5";
            newVideo.style.borderRadius = "8px";
            newVideo.muted = false;
            newVideo.autoplay = false;
            newVideo.playsInline = true;
            newVideo.preload = "auto";

            newSource.src = videoPath;
            newVideo.appendChild(newSource);

            // Timeout for loading
            const loadTimeout = setTimeout(() => {
              console.warn(`Video loading timeout: ${videoPath}`);
              reject(new Error(`Video loading timeout: ${videoPath}`));
            }, 10000); // 10秒タイムアウト

            const onLoadedMetadata = () => {
              clearTimeout(loadTimeout);
              const duration = newVideo.duration * 1000; // ミリ秒に変換
              console.log(
                `Video loaded successfully: ${videoPath}, duration: ${duration}ms`,
              );

              const playerId = this.playerId;
              const stateElement = document.getElementById(`state${playerId}`);
              const slotWrap = document.getElementById(`slot${playerId}`);

              // 映像の準備完了を待つ
              const waitForCanPlay = () => {
                return new Promise((resolve) => {
                  if (newVideo.readyState >= 3) {
                    // HAVE_FUTURE_DATA以上
                    resolve();
                  } else {
                    const onCanPlay = () => {
                      newVideo.removeEventListener("canplay", onCanPlay);
                      resolve();
                    };
                    newVideo.addEventListener("canplay", onCanPlay);
                  }
                });
              };

              // 映像の準備を開始
              waitForCanPlay()
                .then(() => {
                  console.log(`Video ready for playback: ${videoPath}`);

                  // スロット開始のタイミングで映像を入れ替えて開始
                  setTimeout(() => {
                    // 映像再生時に既存のvideoタグと入れ替え
                    originalVideo.style.display = "none";
                    rightPanel.appendChild(newVideo);

                    // ステート要素を非表示に
                    stateElement.style.display = "none";
                    slotWrap.style.transform =
                      "translate(50px, -170px) scale(0.8)";

                    // DOM操作とブラウザレンダリングの完了を待ってから再生開始
                    requestAnimationFrame(() => {
                      requestAnimationFrame(() => {
                        newVideo.currentTime = 0; // 再生位置を確実にリセット
                        newVideo.play().catch((error) => {
                          console.warn(
                            `Failed to play video: ${error.message}`,
                          );
                        });
                      });
                    });
                  }, withSleep);
                })
                .catch((error) => {
                  console.warn(`Video preparation failed: ${error.message}`);
                  // フォールバック処理
                  setTimeout(
                    () => {
                      originalVideo.style.display = "none";
                      rightPanel.appendChild(newVideo);
                      requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                          newVideo.play().catch((error) => {
                            console.warn(
                              `Fallback video play failed: ${error.message}`,
                            );
                          });
                        });
                      });
                    },
                    defaultDuration + 2 * defaultLag,
                  );
                });

              // 映像終了後のクリーンアップ
              const onVideoEnded = () => {
                try {
                  // 新しいvideoタグを削除
                  if (newVideo.parentNode) {
                    newVideo.parentNode.removeChild(newVideo);
                  }

                  // 元のvideoタグを表示に戻す
                  originalVideo.style.display = "";

                  console.log(
                    `Player ${this.playerId} video replaced back to original`,
                  );

                  // ステート要素を表示に戻す
                  stateElement.style.display = "";
                  slotWrap.style.transform = "";
                } catch (error) {
                  console.warn(`Failed to restore video elements:`, error);
                }

                // イベントリスナーを削除
                newVideo.removeEventListener("ended", onVideoEnded);
                newVideo.removeEventListener(
                  "loadedmetadata",
                  onLoadedMetadata,
                );
                newVideo.removeEventListener("error", onVideoError);
              };

              newVideo.addEventListener("ended", onVideoEnded);

              // Default duration fallback if video duration is invalid
              resolve(duration > 0 ? duration : 3000); // 最低3秒
            };

            const onVideoError = (error) => {
              clearTimeout(loadTimeout);
              console.error(`Video error for ${videoPath}:`, error);

              // エラー時のクリーンアップ
              try {
                if (newVideo.parentNode) {
                  newVideo.parentNode.removeChild(newVideo);
                }
                originalVideo.style.display = "";
              } catch (cleanupError) {
                console.warn(
                  `Failed to cleanup after video error:`,
                  cleanupError,
                );
              }

              // イベントリスナーを削除
              newVideo.removeEventListener("loadedmetadata", onLoadedMetadata);
              newVideo.removeEventListener("error", onVideoError);

              reject(new Error(`Failed to load video: ${videoPath}`));
            };

            newVideo.addEventListener("loadedmetadata", onLoadedMetadata);
            newVideo.addEventListener("error", onVideoError);

            console.log(
              `Player ${this.playerId} loading new video: ${videoPath}`,
            );
          });
        }

        // フォールバック：デフォルトスロットアニメーション
        async fallbackToDefaultSlot(slot) {
          console.log(`P${this.playerId} Executing fallback slot animation`);
          if (this.playerId === 1) {
            spinTo1(slot);
          } else {
            spinTo2(slot);
          }
          await this.waitForSlotAnimation();
        }

        // 指定時間だけスロットを回転
        async spinSlotForVideoDuration(slot, duration) {
          duration += defaultDuration + 2 * defaultLag - 1000;

          // スロット回転開始
          console.log(`P${this.playerId} Starting slot spin for ${duration}ms`);
          if (this.playerId === 1) {
            spinTo1(slot, [defaultDuration, duration, defaultDuration]);
          } else {
            spinTo2(slot, [defaultDuration, duration, defaultDuration]);
          }

          // 指定時間待機
          await new Promise((resolve) => setTimeout(resolve, duration));

          // スロット回転完了を待つ
          console.log(
            `P${this.playerId} Waiting for slot animation to complete`,
          );
          await this.waitForSlotAnimation();
        }

        // スロットアニメーション完了を待つ
        waitForSlotAnimation() {
          return new Promise((resolve) => {
            const checkInterval = setInterval(() => {
              const status = getSlotStatus(this.playerId);
              if (!status.isSpinning && status.queueLength === 0) {
                clearInterval(checkInterval);

                // ゲーム側のスロット回転状態をリセット
                if (this.playerId === 1 && window.game1) {
                  window.game1.setSlotSpinning(false);
                  console.log(
                    `Player ${this.playerId} slot spinning state reset`,
                  );
                  // 状態表示を更新
                  // this.updateState(this.playerId, window.game1.getState());
                } else if (this.playerId === 2 && window.game2) {
                  window.game2.setSlotSpinning(false);
                  console.log(
                    `Player ${this.playerId} slot spinning state reset`,
                  );
                  // 状態表示を更新
                  // this.updateState(this.playerId, window.game2.getState());
                }

                // 少し余裕を持って完了を待つ
                setTimeout(resolve, 300);
              }
            }, 100);

            // const timeOutTime = 10000;

            // // 最大 timeOutTime ms でタイムアウト
            // setTimeout(() => {
            //   clearInterval(checkInterval);
            //   console.warn(`Player ${this.playerId} slot animation timeout`);

            //   // タイムアウト時もスロット回転状態をリセット
            //   if (this.playerId === 1 && window.game1) {
            //     window.game1.setSlotSpinning(false);
            //     console.log(
            //       `Player ${this.playerId} slot spinning state reset (timeout)`,
            //     );
            //     // 状態表示を更新
            //     this.updateState(this.playerId, window.game1.getState());
            //   } else if (this.playerId === 2 && window.game2) {
            //     window.game2.setSlotSpinning(false);
            //     console.log(
            //       `Player ${this.playerId} slot spinning state reset (timeout)`,
            //     );
            //     // 状態表示を更新
            //     this.updateState(this.playerId, window.game2.getState());
            //   }

            //   resolve();
            // }, timeOutTime);
          });
        }

        // キューの状態を取得
        getStatus() {
          return {
            queueLength: this.queue.length,
            isProcessing: this.isProcessing,
            queue: [...this.queue],
          };
        }

        // キューをクリア
        clear() {
          this.queue = [];
          this.isProcessing = false;
          console.log(`Player ${this.playerId} task queue cleared`);
        }
      }

      // プレイヤー別のタスクキュー（updateState関数はmain関数内で定義されるため、後で設定）
      let taskQueue1;
      let taskQueue2;

      // 排他制御用の変数（スロットレベル）
      let isSpinning1 = false;
      let isSpinning2 = false;
      let spinQueue1 = [];
      let spinQueue2 = [];

      // スロット状態チェック関数
      function getSlotStatus(playerId) {
        if (playerId === 1) {
          return {
            isSpinning: isSpinning1,
            queueLength: spinQueue1.length,
            queue: [...spinQueue1],
          };
        } else if (playerId === 2) {
          return {
            isSpinning: isSpinning2,
            queueLength: spinQueue2.length,
            queue: [...spinQueue2],
          };
        }
        return null;
      }

      // 強制的にスロット状態をリセットする関数（デバッグ用）
      function forceResetSlotState(playerId) {
        if (playerId === 1) {
          isSpinning1 = false;
          spinQueue1 = [];
          if (taskQueue1) {
            taskQueue1.clear();
          }
          console.log(
            "プレイヤー1: スロット状態とタスクキューを強制リセットしました",
          );
        } else if (playerId === 2) {
          isSpinning2 = false;
          spinQueue2 = [];
          if (taskQueue2) {
            taskQueue2.clear();
          }
          console.log(
            "プレイヤー2: スロット状態とタスクキューを強制リセットしました",
          );
        } else if (playerId === "both") {
          isSpinning1 = false;
          isSpinning2 = false;
          spinQueue1 = [];
          spinQueue2 = [];
          if (taskQueue1) {
            taskQueue1.clear();
          }
          if (taskQueue2) {
            taskQueue2.clear();
          }
          console.log(
            "両プレイヤー: スロット状態とタスクキューを強制リセットしました",
          );
        }
      }

      // 初期化: 各リールに繰り返し数字リストを作成
      function buildReelList(reelEl) {
        const list = reelEl.querySelector(".reel-list");
        list.innerHTML = "";

        // REPEAT回分の数字を作成
        for (let r = 0; r < REPEAT; r++) {
          for (const n of numbers) {
            const div = document.createElement("div");
            div.className = "cell";
            const img = document.createElement("img");
            img.src = `images/numbers/num${n}.png`;
            img.alt = n.toString();
            div.appendChild(img);
            list.appendChild(div);
          }
        }

        // さらに1周分追加してスクロール端での空白を防ぐ
        for (const n of numbers) {
          const div = document.createElement("div");
          div.className = "cell";
          const img = document.createElement("img");
          img.src = `images/numbers/num${n}.png`;
          img.alt = n.toString();
          div.appendChild(img);
          list.appendChild(div);
        }

        // 初期位置: 中央ブロックの最初（1）が見えるように設定（表示位置を2つ下に調整）
        const centerBlockStart = Math.floor(REPEAT / 2) * numbers.length;
        list.style.transform = `translateY(-${(centerBlockStart - 2) * cellH}px)`;
      }

      reels1.forEach(buildReelList);
      reels2.forEach(buildReelList);

      // 指定された3つの数字を即座に表示
      function setDigits(digits, reelArray = reels1) {
        digits = normalizeDigits(digits);
        reelArray.forEach((reelEl, idx) => {
          const list = reelEl.querySelector(".reel-list");
          const targetNumber = digits[idx];

          // 中央ブロックでの目標位置を計算（表示位置を2つ下に調整）
          const centerBlockStart = Math.floor(REPEAT / 2) * numbers.length;
          const targetPositionInBlock = numbers.indexOf(targetNumber);
          const finalPosition = centerBlockStart + targetPositionInBlock - 2;
          const offset = finalPosition * cellH;

          // トランジションなしで即座に移動
          list.style.transition = "none";
          list.style.transform = `translateY(-${offset}px)`;

          // 次回のアニメーション用にトランジションを復活
          requestAnimationFrame(() => {
            list.style.transition = "transform 600ms cubic-bezier(.2,.8,.2,1)";
          });
        });
      }

      const defaultDuration = 800;
      const defaultLag = 300;

      // スロット風回転: 必ず上から下へ回転して目標数字で停止
      // spinDurations: リールごとの時間指定
      //   - null: デフォルトのランダム時間
      //   - 数値: 全リール共通の基本時間（後方互換）
      //   - 配列: [reel0_duration, reel1_duration, reel2_duration] 各リール個別時間
      //   例: spinTo1([1,2,3], [1000, 1500, 2000]) // 1桁目1秒、2桁目1.5秒、3桁目2秒
      function spinTo(digits, reelArray = reels1, spinDurations = null) {
        // 排他制御: どちらのリールセットかを判定
        const isReel1 = reelArray === reels1;
        const isSpinning = isReel1 ? isSpinning1 : isSpinning2;
        const spinQueue = isReel1 ? spinQueue1 : spinQueue2;

        // 現在スピン中の場合はキューに追加して終了
        if (isSpinning) {
          console.log(
            `Player ${isReel1 ? 1 : 2} slot is spinning, adding to queue:`,
            digits,
          );
          spinQueue.push({ digits, spinDurations });
          return;
        }

        // スピン開始フラグをセット
        if (isReel1) {
          isSpinning1 = true;
        } else {
          isSpinning2 = true;
        }

        console.log(`Player ${isReel1 ? 1 : 2} slot spin started:`, digits);

        digits = normalizeDigits(digits);
        const spinTimeouts = [];
        let completedReelsCount = 0; // 完了したリール数をカウント
        let isSpinCompleted = false; // スピン完了フラグ（重複処理防止）

        reelArray.forEach((reelEl, idx) => {
          const list = reelEl.querySelector(".reel-list");

          // 回転時間の計算
          let baseDuration, duration;
          if (spinDurations !== null && spinDurations[idx] !== undefined) {
            // 指定された各リールの時間を使用
            baseDuration = spinDurations[idx];
            const extra = Math.random() * 100; // 少しのランダム要素を残す
            duration = baseDuration + extra;
          } else if (
            spinDurations !== null &&
            typeof spinDurations === "number"
          ) {
            // 単一の数値が指定された場合（後方互換性）
            baseDuration = spinDurations;
            const extra = idx * 100 + Math.random() * 100;
            duration = baseDuration + extra;
          } else {
            // デフォルトの時間計算（後のリールほど長く、ばらつきを減らして自然に）
            baseDuration = defaultDuration + Math.random() * 600;
            const extra = idx * defaultLag + Math.random() * 200;
            duration = baseDuration + extra;
          }

          const targetNumber = digits[idx];

          // 現在位置を取得
          const currentTransform = parseTransformY(list);
          const currentPosition = currentTransform / cellH;

          // より現実的な回転数計算（対数的増加）
          // 基本3回転 + 対数的に増加する追加回転（最大15回転まで）
          const baseSpins = 1; // 最低回転数
          const timeBasedSpins = Math.floor(Math.log(duration / 100) * 2); // 対数的増加
          const maxTimeBasedSpins = 15; // 最大追加回転数を制限
          const actualTimeBasedSpins = Math.min(
            Math.max(timeBasedSpins, 0),
            maxTimeBasedSpins,
          );
          const randomSpins = Math.floor(Math.random() * 1.5); // ランダム要素
          const minSpins = baseSpins + actualTimeBasedSpins + randomSpins;

          console.log(
            `Player ${isReel1 ? 1 : 2} reel ${idx}: duration=${duration}ms, spins=${minSpins} (base=${baseSpins}, time-based=${actualTimeBasedSpins}/${timeBasedSpins}, random=${randomSpins})`,
          );
          const totalRotationCells = minSpins * numbers.length;

          const targetPositionInBlock = numbers.indexOf(targetNumber);

          // 目標位置を中央ブロック基準で直接計算
          const centerBlockStart = Math.floor(REPEAT / 2) * numbers.length;
          const baseTargetPosition =
            centerBlockStart + targetPositionInBlock - 2;

          // 現在位置から最低回転数を保証した目標位置を計算
          let targetPosition = currentPosition + totalRotationCells;

          // 目標位置を中央ブロックの正しい位置に調整
          const positionDifference =
            (baseTargetPosition - targetPosition) % numbers.length;
          if (positionDifference < 0) {
            targetPosition += numbers.length + positionDifference;
          } else {
            targetPosition += positionDifference;
          }

          const targetOffset = targetPosition * cellH;

          // より自然な減速アニメーション
          list.style.transition = `transform ${duration}ms cubic-bezier(0.23, 1, 0.320, 1)`;

          // カスケード効果で順次開始
          setTimeout(() => {
            list.style.transform = `translateY(-${targetOffset}px)`;

            // transitionendイベントでアニメーション完了を確実に検知
            const handleTransitionEnd = (event) => {
              // transform プロパティのトランジション完了のみ処理
              if (event.propertyName === "transform") {
                list.removeEventListener("transitionend", handleTransitionEnd);

                // アニメーションなしで中央ブロック内の適切な位置にリセット
                const centerBlockStart =
                  Math.floor(REPEAT / 2) * numbers.length;
                const resetTargetPosition =
                  centerBlockStart + targetPositionInBlock - 2;
                const resetOffset = resetTargetPosition * cellH;

                // トランジションを無効化してリセット
                list.style.transition = "none";
                list.style.transform = `translateY(-${resetOffset}px)`;

                // 少し遅れてトランジションを復活
                setTimeout(() => {
                  list.style.transition =
                    "transform 400ms cubic-bezier(.2,.8,.2,1)";
                }, 10);

                // 完了したリール数をインクリメント
                completedReelsCount++;
                console.log(
                  `Player ${isReel1 ? 1 : 2} reel ${idx} completed (${completedReelsCount}/${reelArray.length})`,
                );

                // 全リールが完了したかチェック（重複処理防止）
                if (
                  completedReelsCount === reelArray.length &&
                  !isSpinCompleted
                ) {
                  isSpinCompleted = true;
                  console.log(
                    `Player ${isReel1 ? 1 : 2} all reels completed, waiting for settlement...`,
                  );

                  // 全リール完了時の処理（少し長めに待機して確実にアニメーションが完了してから）
                  setTimeout(() => {
                    // スピン完了フラグをリセット
                    if (isReel1) {
                      isSpinning1 = false;
                    } else {
                      isSpinning2 = false;
                    }

                    console.log(
                      `Player ${isReel1 ? 1 : 2} slot spin completed and ready for next`,
                    );

                    // キューに待機中のスピンがあれば実行
                    if (spinQueue.length > 0) {
                      const nextSpin = spinQueue.shift();
                      console.log(
                        `Player ${isReel1 ? 1 : 2} executing queued spin:`,
                        nextSpin.digits,
                      );
                      setTimeout(
                        () =>
                          spinTo(
                            nextSpin.digits,
                            reelArray,
                            nextSpin.spinDurations,
                          ),
                        300,
                      );
                    }
                  }, 200); // アニメーションが確実に完了するまで待機
                }
              }
            };

            list.addEventListener("transitionend", handleTransitionEnd);

            // // フォールバックタイムアウト（イベントが発火しない場合の保険）
            // // 最大アニメーション時間を考慮して十分に長めに設定
            // const maxDuration =
            //   spinDurations !== null &&
            //   (Array.isArray(spinDurations) ||
            //     typeof spinDurations === "number")
            //     ? baseDuration +
            //       (reelArray.length - 1) * 100 +
            //       Math.random() * 100
            //     : baseDuration +
            //       (reelArray.length - 1) * 400 +
            //       Math.random() * 200;
            // const fallbackTimeout = setTimeout(() => {
            //   if (!isSpinCompleted) {
            //     console.warn(
            //       `Player ${isReel1 ? 1 : 2} reel ${idx} fallback timeout triggered`,
            //     );
            //     list.removeEventListener("transitionend", handleTransitionEnd);
            //     handleTransitionEnd({ propertyName: "transform" });
            //   }
            // }, maxDuration + 1500);

            // spinTimeouts.push(fallbackTimeout);
          }, idx * 200);
        });

        // 停止用の関数を返す
        return function stop() {
          spinTimeouts.forEach((id) => clearTimeout(id));

          // スピン状態をリセット
          if (isReel1) {
            isSpinning1 = false;
          } else {
            isSpinning2 = false;
          }

          // 各リールを即座に目標位置に移動
          reelArray.forEach((reelEl, idx) => {
            const list = reelEl.querySelector(".reel-list");
            list.style.transition = "transform 300ms ease-out";
          });
          setDigits(digits, reelArray);

          console.log(`Player ${isReel1 ? 1 : 2} slot spin stopped`);
        };
      }

      // ユーティリティ: 数字配列の正規化
      function normalizeDigits(d) {
        console.log("normalizeDigits", d);
        if (!Array.isArray(d)) throw new Error("配列で渡してください: [a,b,c]");
        if (d.length !== 3) throw new Error("要素数は3つ必要です");
        return d.map((x) => Number(x) || 1).map((x) => ((x - 1) % 8) + 1);
      }

      // ユーティリティ: 現在のtranslateY値を取得
      function parseTransformY(list) {
        const t = getComputedStyle(list).transform;
        if (!t || t === "none") return 0;

        // matrix形式
        const matrixMatch = t.match(
          /matrix\(([^,]+),\s*([^,]+),\s*([^,]+),\s*([^,]+),\s*([^,]+),\s*([^\)]+)\)/,
        );
        if (matrixMatch) {
          return Math.abs(parseFloat(matrixMatch[6]));
        }

        // translateY形式
        const translateMatch = t.match(/translateY\((-?\d+(?:\.\d+)?)px\)/);
        if (translateMatch) {
          return Math.abs(parseFloat(translateMatch[1]));
        }

        // translate3d形式
        const translate3dMatch = t.match(
          /translate3d\(([^,]+),\s*(-?\d+(?:\.\d+)?)px,\s*([^\)]+)\)/,
        );
        if (translate3dMatch) {
          return Math.abs(parseFloat(translate3dMatch[2]));
        }

        return 0;
      }

      // プレイヤー1用のエイリアス関数
      function setDigits1(digits) {
        console.log("Player 1 setDigits called:", digits);
        return setDigits(digits, reels1);
      }

      function spinTo1(digits, spinDurations = null) {
        console.log("Player 1 spinTo called:", digits);
        return spinTo(digits, reels1, spinDurations);
      }

      // プレイヤー2用のエイリアス関数
      function setDigits2(digits) {
        console.log("Player 2 setDigits called:", digits);
        return setDigits(digits, reels2);
      }

      function spinTo2(digits, spinDurations = null) {
        console.log("Player 2 spinTo called:", digits);
        return spinTo(digits, reels2, spinDurations);
      }

      // 両プレイヤー同時操作用のエイリアス関数
      function setDigitsBoth(digits) {
        console.log("Both players setDigits called:", digits);
        setDigits1(digits);
        setDigits2(digits);
      }

      function spinToBoth(digits, spinDurations = null) {
        spinTo1(digits, spinDurations);
        spinTo2(digits, spinDurations);
      }

      // デバッグ関数をグローバルスコープに公開
      window.getSlotStatus = getSlotStatus;
      window.forceResetSlotState = forceResetSlotState;
      window.debugSlots = () => {
        console.log("=== スロット状態 ===");
        console.log("プレイヤー1:", getSlotStatus(1));
        console.log("プレイヤー2:", getSlotStatus(2));
      };
      window.getTaskQueueStatus = (playerId) => {
        if (playerId === 1) return taskQueue1 ? taskQueue1.getStatus() : null;
        if (playerId === 2) return taskQueue2 ? taskQueue2.getStatus() : null;
        return {
          player1: taskQueue1 ? taskQueue1.getStatus() : null,
          player2: taskQueue2 ? taskQueue2.getStatus() : null,
        };
      };
      window.debugTaskQueues = () => {
        console.log("=== タスクキュー状態 ===");
        console.log(
          "プレイヤー1:",
          taskQueue1 ? taskQueue1.getStatus() : "未初期化",
        );
        console.log(
          "プレイヤー2:",
          taskQueue2 ? taskQueue2.getStatus() : "未初期化",
        );
      };

      window.debugSpinningState = () => {
        console.log("=== スロット回転状態 ===");
        console.log("UI側スロット状態:");
        console.log("  プレイヤー1:", getSlotStatus(1));
        console.log("  プレイヤー2:", getSlotStatus(2));
        console.log("ゲーム側スロット状態:");
        console.log(
          "  プレイヤー1:",
          window.game1 ? window.game1.isSlotCurrentlySpinning() : "未初期化",
        );
        console.log(
          "  プレイヤー2:",
          window.game2 ? window.game2.isSlotCurrentlySpinning() : "未初期化",
        );
      };

      // テスト用のデバッグ関数
      window.testSlotTiming = (playerId = 1, count = 3, interval = 500) => {
        console.log(`=== プレイヤー${playerId}のスロット連続テスト開始 ===`);
        const spinFunc = playerId === 1 ? spinTo1 : spinTo2;

        for (let i = 0; i < count; i++) {
          setTimeout(() => {
            const digits = [
              Math.floor(Math.random() * 8) + 1,
              Math.floor(Math.random() * 8) + 1,
              Math.floor(Math.random() * 8) + 1,
            ];
            console.log(`テスト ${i + 1}/${count}:`, digits);
            spinFunc(digits);
          }, i * interval);
        }
      };

      // 両プレイヤー同時回転テスト
      window.testBothSlots = (count = 2, interval = 1000) => {
        console.log("=== 両プレイヤー同時スロットテスト開始 ===");
        for (let i = 0; i < count; i++) {
          setTimeout(() => {
            const digits1 = [
              Math.floor(Math.random() * 8) + 1,
              Math.floor(Math.random() * 8) + 1,
              Math.floor(Math.random() * 8) + 1,
            ];
            const digits2 = [
              Math.floor(Math.random() * 8) + 1,
              Math.floor(Math.random() * 8) + 1,
              Math.floor(Math.random() * 8) + 1,
            ];
            console.log(`両プレイヤーテスト ${i + 1}/${count}:`, {
              player1: digits1,
              player2: digits2,
            });
            spinTo1(digits1);
            spinTo2(digits2);
          }, i * interval);
        }
      };

      // 各リール個別時間指定テスト
      window.testIndividualReelTiming = (playerId = 1) => {
        console.log(`=== プレイヤー${playerId}の各リール個別時間テスト ===`);
        const spinFunc = playerId === 1 ? spinTo1 : spinTo2;

        // テストパターン1: 左から右へ順次長く
        setTimeout(() => {
          const digits = [7, 7, 7];
          const durations = [1000, 1500, 2000]; // 1秒、1.5秒、2秒
          console.log("パターン1 - 左から右へ順次長く:", { digits, durations });
          spinFunc(digits, durations);
        }, 0);

        // テストパターン2: 右から左へ順次長く
        setTimeout(() => {
          const digits = [3, 3, 3];
          const durations = [2000, 1500, 1000]; // 2秒、1.5秒、1秒
          console.log("パターン2 - 右から左へ順次長く:", { digits, durations });
          spinFunc(digits, durations);
        }, 4000);

        // テストパターン3: 中央だけ長く
        setTimeout(() => {
          const digits = [1, 2, 3];
          const durations = [1000, 3000, 1000]; // 1秒、3秒、1秒
          console.log("パターン3 - 中央だけ長く:", { digits, durations });
          spinFunc(digits, durations);
        }, 8000);

        // テストパターン4: 全リール同じ時間（配列指定）
        setTimeout(() => {
          const digits = [5, 5, 5];
          const durations = [1800, 1800, 1800]; // 全て1.8秒
          console.log("パターン4 - 全リール同じ時間（配列）:", {
            digits,
            durations,
          });
          spinFunc(digits, durations);
        }, 12000);
      };

      // 回転時間と回転数の比例関係テスト
      window.testRotationCountByDuration = (playerId = 1) => {
        console.log(
          `=== プレイヤー${playerId}の回転時間・回転数比例テスト ===`,
        );
        const spinFunc = playerId === 1 ? spinTo1 : spinTo2;

        // テスト結果表示用の要素を作成
        let testResultDiv = document.getElementById("rotation-test-results");
        if (!testResultDiv) {
          testResultDiv = document.createElement("div");
          testResultDiv.id = "rotation-test-results";
          testResultDiv.style.cssText = `
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            max-width: 300px;
            z-index: 1000;
          `;
          document.body.appendChild(testResultDiv);
        }
        testResultDiv.innerHTML = `<h4>回転数テスト結果 (Player ${playerId})</h4>`;

        const addResult = (duration, expectedSpins) => {
          const resultLine = document.createElement("div");
          resultLine.textContent = `${duration}ms → 約${expectedSpins}回転`;
          testResultDiv.appendChild(resultLine);
        };

        // テスト1: 短時間（基本回転数）
        setTimeout(() => {
          const digits = [1, 2, 3];
          const durations = [800, 800, 800]; // 短時間
          const expectedSpins =
            3 + Math.min(Math.max(Math.floor(Math.log(800 / 100) * 2), 0), 15);
          addResult(800, expectedSpins);
          console.log("短時間テスト（800ms）- 基本回転数で回転:", {
            digits,
            durations,
            expectedSpins,
          });
          spinFunc(digits, durations);
        }, 0);

        // テスト2: 中時間（中程度の回転数）
        setTimeout(() => {
          const digits = [4, 5, 6];
          const durations = [1500, 1500, 1500]; // 中時間
          const expectedSpins =
            3 + Math.min(Math.max(Math.floor(Math.log(1500 / 100) * 2), 0), 15);
          addResult(1500, expectedSpins);
          console.log("中時間テスト（1500ms）- 中程度の回転数で回転:", {
            digits,
            durations,
            expectedSpins,
          });
          spinFunc(digits, durations);
        }, 3000);

        // テスト3: 長時間（多回転）
        setTimeout(() => {
          const digits = [7, 8, 9];
          const durations = [2500, 2500, 2500]; // 長時間
          const expectedSpins =
            3 + Math.min(Math.max(Math.floor(Math.log(2500 / 100) * 2), 0), 15);
          addResult(2500, expectedSpins);
          console.log("長時間テスト（2500ms）- 多回転で回転:", {
            digits,
            durations,
            expectedSpins,
          });
          spinFunc(digits, durations);
        }, 6000);

        // テスト4: 超長時間（最大回転）
        setTimeout(() => {
          const digits = [8, 1, 2];
          const durations = [4000, 4000, 4000]; // 超長時間
          const expectedSpins =
            3 + Math.min(Math.max(Math.floor(Math.log(4000 / 100) * 2), 0), 15);
          addResult(4000, expectedSpins);
          console.log("超長時間テスト（4000ms）- 最大回転数で回転:", {
            digits,
            durations,
            expectedSpins,
          });
          spinFunc(digits, durations);
        }, 10000);

        // テスト5: 超超長時間（15秒）
        setTimeout(() => {
          const digits = [5, 5, 5];
          const durations = [15000, 15000, 15000]; // 超超長時間
          const expectedSpins =
            3 +
            Math.min(Math.max(Math.floor(Math.log(15000 / 100) * 2), 0), 15);
          addResult(15000, expectedSpins);
          console.log("超超長時間テスト（15000ms）- 対数制限回転:", {
            digits,
            durations,
            expectedSpins,
          });
          spinFunc(digits, durations);
        }, 14000);

        console.log("各テストの回転数の違いをコンソールログで確認してください");

        // 20秒後にテスト結果表示を自動削除
        setTimeout(() => {
          if (testResultDiv && testResultDiv.parentNode) {
            testResultDiv.parentNode.removeChild(testResultDiv);
          }
        }, 20000);
      };

      // 従来の数値指定テスト（testIndividualReelTimingの続き）
      window.testBackwardCompatibility = (playerId = 1) => {
        console.log(`=== プレイヤー${playerId}の後方互換性テスト ===`);
        const spinFunc = playerId === 1 ? spinTo1 : spinTo2;

        // テストパターン5: 従来の数値指定（後方互換性確認）
        setTimeout(() => {
          const digits = [8, 7, 6];
          const duration = 2500; // 単一数値
          console.log("従来の数値指定テスト:", { digits, duration });
          spinFunc(digits, duration);
        }, 0);
      };

      // 回転数計算の詳細を表示するヘルパー関数
      window.showRotationFormula = () => {
        let formulaDiv = document.getElementById("rotation-formula");
        if (!formulaDiv) {
          formulaDiv = document.createElement("div");
          formulaDiv.id = "rotation-formula";
          formulaDiv.style.cssText = `
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0,100,0,0.9);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 11px;
            max-width: 350px;
            z-index: 1000;
          `;
          document.body.appendChild(formulaDiv);
        }

        formulaDiv.innerHTML = `
          <h4>回転数計算式（対数的増加）</h4>
          <p><strong>総回転数 = 基本回転数 + 時間ベース回転数 + ランダム回転数</strong></p>
          <ul>
            <li>基本回転数: 3回転（固定）</li>
            <li>時間ベース回転数: Math.min(Math.floor(Math.log(duration/100) * 2), 15)</li>
            <li>ランダム回転数: Math.floor(Math.random() * 1.5)</li>
          </ul>
          <p>例: 1500ms → 3 + Math.min(Math.floor(Math.log(15) * 2), 15) + 0~1 = 8~9回転</p>
          <p>例: 15000ms → 3 + Math.min(Math.floor(Math.log(150) * 2), 15) + 0~1 = 13~14回転</p>
          <button onclick="document.body.removeChild(document.getElementById('rotation-formula'))"
                  style="margin-top:10px; padding:5px; background:white; border:none; border-radius:3px;">
            閉じる
          </button>
        `;
      };

      // タスクキューのテスト関数
      window.testTaskQueue = (playerId = 1, count = 3) => {
        console.log(`=== プレイヤー${playerId}のタスクキューテスト開始 ===`);
        const taskQueue = playerId === 1 ? taskQueue1 : taskQueue2;

        if (!taskQueue) {
          console.error("タスクキューが未初期化です");
          return;
        }

        for (let i = 0; i < count; i++) {
          const digits = [
            Math.floor(Math.random() * 8) + 1,
            Math.floor(Math.random() * 8) + 1,
            Math.floor(Math.random() * 8) + 1,
          ];

          // 抽選タスクを直接キューに追加
          taskQueue.addTask("lotteryNormal", {
            lotteryResult: { type: "Normal", value: Math.random() * 100 },
            slotResult: [digits, digits],
            taskType: `Test Normal Lottery ${i + 1}`,
          });

          // 状態更新タスクも追加
          taskQueue.addTask("default", {
            after: {
              type: "Normal",
              balls: 1000 - i * 10,
            },
          });
        }
      };

      window.testMixedTasks = (playerId = 1) => {
        console.log(`=== プレイヤー${playerId}の混合タスクテスト開始 ===`);
        const taskQueue = playerId === 1 ? taskQueue1 : taskQueue2;

        if (!taskQueue) {
          console.error("タスクキューが未初期化です");
          return;
        }

        // 通常抽選
        taskQueue.addTask("lotteryNormal", {
          lotteryResult: { type: "Win" },
          slotResult: [
            [1, 2, 3],
            [4, 5, 6],
          ],
          taskType: "Mixed Test Normal",
        });

        // 状態更新
        taskQueue.addTask("default", {
          after: { type: "Normal", balls: 950 },
        });

        // ラッシュ抽選
        taskQueue.addTask("lotteryRush", {
          lotteryResult: { type: "Rush" },
          slotResult: [
            [7, 7, 7],
            [7, 7, 7],
          ],
          taskType: "Mixed Test Rush",
        });

        // さらに状態更新
        taskQueue.addTask("default", {
          after: { type: "Rush", balls: 900, rushBalls: 50, n: 1 },
        });
      };

      // 統合デバッグ関数
      window.debugAll = () => {
        console.log("=== 統合デバッグ情報 ===");
        console.log("=== スロット状態 ===");
        console.log("プレイヤー1:", getSlotStatus(1));
        console.log("プレイヤー2:", getSlotStatus(2));
        console.log("=== タスクキュー状態 ===");
        console.log(
          "プレイヤー1:",
          taskQueue1 ? taskQueue1.getStatus() : "未初期化",
        );
        console.log(
          "プレイヤー2:",
          taskQueue2 ? taskQueue2.getStatus() : "未初期化",
        );
      };

      setDigitsBoth([1, 1, 1]);

      import {
        init,
        WasmGame,
        ControlFlow,
        Config,
        BallsConfig,
        Probability,
        SlotProbability,
        JsInput,
        JsOutput,
      } from "./pachislo.js";

      // Matter.jsの主要モジュールを取得
      const {
        Engine,
        Render,
        Runner,
        Bodies,
        Composite,
        Events,
        Mouse,
        MouseConstraint,
      } = Matter;

      // パチンコゲームコンポーネントクラス
      class PachinkoGame {
        constructor(
          canvasId,
          playerId,
          keyBinding,
          nails,
          wasmGame,
          recreateWasmGame,
        ) {
          this.canvasId = canvasId;
          this.playerId = playerId;
          this.keyBinding = keyBinding;
          this.fallingBalls = [];
          this.nails_index = nails;
          this.wasmgame = wasmGame;
          this.recreateWasmGame = recreateWasmGame; // WASMGame再作成用の関数
          this.lastLaunchTime = 0; // 最後のボール発射時刻を記録
          this.gameTimer = null; // ゲーム終了タイマー
          this.gameDuration = 5 * 60 * 1000; // デフォルト5分
          this.gameStartTime = null; // ゲーム開始時刻
          this.displayTimer = null; // タイマー表示用インターバル

          this.init(); // canvasと物理エンジンは最初から初期化
        }

        run_step_with_command(command) {
          this.wasmgame.run_step_with_command(command);
        }

        init() {
          // エンジンを作成
          this.engine = Engine.create();
          this.world = this.engine.world;
          this.engine.world.gravity.y = 0.8;

          // レンダラーを作成
          this.setupRenderer();

          // ゲーム要素を作成
          this.createWalls();
          this.createNails();
          this.createTargetZones();
          this.setupMouseControl();
          this.setupEventListeners();

          // 世界にオブジェクトを追加
          this.addToWorld();

          // エンジンを開始
          this.start();
        }

        async startWasmGame() {
          console.log(
            `プレイヤー${this.playerId}: startWasmGame()が呼ばれました。現在のisGameStarted: ${this.wasmgame.isGameStarted()}`,
          );

          if (this.wasmgame.isGameStarted()) {
            console.log(
              `プレイヤー${this.playerId}: 既にゲーム開始済みのため処理をスキップします`,
            );
            return; // 既にゲーム開始済みの場合は何もしない
          }

          // パチスロゲームを開始
          console.log(
            `プレイヤー${this.playerId}: StartGameコマンドを実行します`,
          );
          this.run_step_with_command("StartGame");

          // 既存のタイマーをクリア
          if (this.displayTimer) {
            clearInterval(this.displayTimer);
            this.displayTimer = null;
          }

          // ゲーム開始時刻を記録
          this.gameStartTime = Date.now();

          // 設定時間後にゲームを終了させるタイマーを設定
          this.gameTimer = setTimeout(async () => {
            await this.endGame();
          }, this.gameDuration);

          // タイマー表示を開始
          this.startTimerDisplay();

          console.log(
            `プレイヤー${this.playerId}: ゲーム開始！5分後に自動終了します。isGameStarted: ${this.wasmgame.isGameStarted()}`,
          );
        }

        async endGame() {
          // 既にゲームが終了している、または終了処理中の場合は何もしない
          if (!this.wasmgame.isGameStarted()) {
            console.log(
              `プレイヤー${this.playerId}: endGame()が呼ばれましたが、既にゲームは終了済みです`,
            );
            return;
          }

          // プレイヤーに対応する isProcessingFinishTask を取得し、trueなら処理中なので中断
          const isProcessing =
            this.playerId === 1
              ? isProcessingFinishTask1
              : isProcessingFinishTask2;
          if (isProcessing) {
            console.log(
              `プレイヤー${this.playerId}: 現在、終了処理のクールダウン中です。`,
            );
            return;
          }

          console.log(
            `プレイヤー${this.playerId}: ゲーム終了シーケンスを開始します。`,
          );

          // ◆ ステータスを即座に「終了処理中」に設定し、キー入力をブロック
          setIsProcessingFinishTask(this.playerId, true);

          // タイマー関連をクリア
          if (this.gameTimer) clearTimeout(this.gameTimer);
          if (this.displayTimer) clearInterval(this.displayTimer);
          this.gameTimer = null;
          this.displayTimer = null;
          this.gameStartTime = null;

          // タイマー表示をリセット
          const timerDisplay = document.getElementById(
            `timer-display${this.playerId}`,
          );
          if (timerDisplay) {
            const minutes = Math.floor(this.gameDuration / 60000);
            timerDisplay.textContent = `${minutes}:00`;
            timerDisplay.style.color = "white";
            timerDisplay.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
          }

          // ◆ UI更新のためにFinishGameコマンドをキューの最後に追加
          this.run_step_with_command("FinishGame");

          // ◆ タスクキューが空になるのを監視する
          const checkQueueInterval = setInterval(() => {
            // プレイヤーに対応するタスクキューを取得
            const taskQueue = this.playerId === 1 ? taskQueue1 : taskQueue2;

            // キューが空で、かつ何も処理していない状態かチェック
            if (
              taskQueue &&
              taskQueue.queue.length === 0 &&
              !taskQueue.isProcessing
            ) {
              // ◆ 条件を満たしたら監視を停止
              clearInterval(checkQueueInterval);

              console.log(
                `プレイヤー${this.playerId}: 全てのタスクが完了しました。10秒間のクールダウンを開始します。`,
              );

              // ◆ ここから10秒のクールダウンタイマーを開始
              setTimeout(() => {
                console.log(
                  `プレイヤー${this.playerId}: クールダウン終了。新しいゲームインスタンスを作成します。`,
                );

                // 新しいWASMGameインスタンスを作成
                this.wasmgame = this.recreateWasmGame();

                // windowオブジェクトも更新
                if (this.playerId === 1) {
                  window.game1 = this.wasmgame;
                } else if (this.playerId === 2) {
                  window.game2 = this.wasmgame;
                }

                // ◆ フラグを解除してキー入力を受け付けるようにする
                setIsProcessingFinishTask(this.playerId, false);

                console.log(
                  `プレイヤー${this.playerId}: ゲームリセット完了。isGameStarted: ${this.wasmgame.isGameStarted()}`,
                );
              }, 10000); // 10秒のクールダウン
            }
          }, 200); // 200ミリ秒ごとにチェック
        }

        startTimerDisplay() {
          this.displayTimer = setInterval(() => {
            if (this.gameStartTime) {
              const elapsed = Date.now() - this.gameStartTime;
              const remaining = Math.max(0, this.gameDuration - elapsed);
              const minutes = Math.floor(remaining / 60000);
              const seconds = Math.floor((remaining % 60000) / 1000);
              const timeString = `${minutes}:${seconds.toString().padStart(2, "0")}`;

              const timerDisplay = document.getElementById(
                `timer-display${this.playerId}`,
              );
              if (timerDisplay) {
                timerDisplay.textContent = timeString;
                if (remaining <= 30000) {
                  // 30秒以下で赤色警告
                  timerDisplay.style.color = "#ff4444";
                  timerDisplay.style.backgroundColor = "rgba(255, 68, 68, 0.2)";
                }
              }

              if (remaining === 0 && this.displayTimer) {
                clearInterval(this.displayTimer);
                this.displayTimer = null;
              }
            }
          }, 1000);
        }

        setGameDuration(minutes) {
          this.gameDuration = minutes * 60 * 1000;
          // タイマー表示も更新
          const timerDisplay = document.getElementById(
            `timer-display${this.playerId}`,
          );
          if (timerDisplay) {
            timerDisplay.textContent = `${minutes}:00`;
            timerDisplay.style.color = "white";
            timerDisplay.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
          }
        }

        setupRenderer() {
          const canvas = document.getElementById(this.canvasId);
          this.render = Render.create({
            canvas: canvas,
            engine: this.engine,
            options: {
              width: 200,
              height: 800,
              wireframes: false,
              background: "transparent",
              showAngleIndicator: true,
              showVelocity: false,
            },
          });
        }

        createWalls() {
          this.walls = [
            Bodies.rectangle(0, 400, 30, 800, {
              isStatic: true,
              render: { fillStyle: "#444" },
            }),
            Bodies.rectangle(200, 400, 30, 800, {
              isStatic: true,
              render: { fillStyle: "#444" },
            }),
          ];
        }

        createNails() {
          this.nails = [];

          const nailRadius = 2;

          for (let { x, y } of this.nails_index) {
            const nail = Bodies.circle(x, y, nailRadius, {
              isStatic: true,
              render: {
                fillStyle: "#e74c3c",
                strokeStyle: "#c0392b",
                lineWidth: 0.5,
              },
            });

            this.nails.push(nail);
          }
        }

        createTargetZones() {
          // あたりエリア（緑）
          this.winZone = Bodies.rectangle(100, 770, 30, 30, {
            isSensor: true,
            isStatic: true,
            render: {
              fillStyle: "#2ecc71",
              strokeStyle: "#27ae60",
              lineWidth: 2,
              opacity: 0.8,
            },
          });

          // 通常エリア（赤）
          this.normalZone = Bodies.rectangle(100, 770, 160, 30, {
            isSensor: true,
            isStatic: true,
            render: {
              fillStyle: "#e74c3c",
              strokeStyle: "#c0392b",
              lineWidth: 1,
              opacity: 0.5,
            },
          });
        }

        setupMouseControl() {
          const mouse = Mouse.create(this.render.canvas);
          this.mouseConstraint = MouseConstraint.create(this.engine, {
            mouse: mouse,
            constraint: {
              stiffness: 0.2,
              render: { visible: false },
            },
          });
        }

        setupEventListeners() {
          // 衝突検知イベント
          Events.on(this.engine, "collisionStart", (event) => {
            this.handleCollisions(event.pairs);
          });
        }

        handleCollisions(pairs) {
          pairs.forEach((pair) => {
            const { bodyA, bodyB } = pair;

            if (bodyA === this.winZone || bodyB === this.winZone) {
              const ball = bodyA === this.winZone ? bodyB : bodyA;

              if (this.fallingBalls.includes(ball)) {
                console.log(
                  `🎉 プレイヤー${this.playerId}: あたり！球が当たりエリアを通過しました！ (Ball ID: ${ball.id}, 位置: x=${Math.round(ball.position.x)}, y=${Math.round(ball.position.y)})`,
                );

                this.run_step_with_command("CauseLottery");

                const index = this.fallingBalls.indexOf(ball);
                if (index > -1) {
                  this.fallingBalls.splice(index, 1);
                }
              }
            }
          });
        }

        addToWorld() {
          Composite.add(this.world, [
            ...this.walls,
            ...this.nails,
            this.normalZone,
            this.winZone,
            this.mouseConstraint,
          ]);
        }

        start() {
          Render.run(this.render);
          this.runner = Runner.create();
          Runner.run(this.runner, this.engine);
        }

        launchBall() {
          // 発射時刻を更新
          this.lastLaunchTime = Date.now();

          // ゲーム状態をチェック
          const gameState = this.wasmgame.getState();
          if (gameState.type === "Uninitialized") {
            console.log(
              `プレイヤー${this.playerId}: ゲームが未初期化のため球を打てません - StartGameコマンドでゲームを開始してください`,
            );
            console.log(
              `プレイヤー${this.playerId}: 現在のゲーム状態:`,
              gameState,
            );
            return;
          }

          // スロット回転状態をチェック
          if (this.wasmgame.isSlotCurrentlySpinning()) {
            console.log(
              `プレイヤー${this.playerId}: ゲーム側でスロット回転中のため球を打てません - 回転終了まで待機`,
            );
            return;
          }

          // スロットが実際に回転中かもチェック
          const slotStatus = getSlotStatus(this.playerId);
          if (slotStatus && slotStatus.isSpinning) {
            console.log(
              `プレイヤー${this.playerId}: UI側でスロット回転中のため球を打てません - キュー長: ${slotStatus.queueLength}`,
            );
            return;
          }

          let bigBall = null;

          try {
            bigBall = Bodies.circle(50 + Math.random() * 100, 30, 6, {
              render: {
                fillStyle: "#3498db",
                strokeStyle: "#2980b9",
                lineWidth: 1.5,
              },
              restitution: 0.6,
              friction: 0.3,
            });

            this.fallingBalls.push(bigBall);
            Composite.add(this.world, bigBall);

            this.run_step_with_command("LaunchBall");

            console.log(
              `プレイヤー${this.playerId}: 新しい球を落下開始 (ID: ${bigBall.id})`,
            );
          } catch (error) {
            console.log(
              `プレイヤー${this.playerId}: 球の発射に失敗: ${error.message}`,
            );
            return;
          }

          const timeToErase = 10000;

          // timeToErase ms 後にボールを自動削除
          setTimeout(() => {
            // bigBallが正常に作成されていることを確認
            if (bigBall) {
              // ボールが配列に存在するかチェック
              const ballIndex = this.fallingBalls.findIndex(
                (ball) => ball.id === bigBall.id,
              );
              if (ballIndex !== -1) {
                // 配列から削除
                this.fallingBalls.splice(ballIndex, 1);
                // 物理世界から削除
                Composite.remove(this.world, bigBall);
                console.log(
                  `プレイヤー${this.playerId}: 球を自動削除 (ID: ${bigBall.id})`,
                );
              }
            }
          }, timeToErase);
        }

        resetSimulation() {
          this.fallingBalls.forEach((ball) => {
            Composite.remove(this.world, ball);
          });
          this.fallingBalls = [];

          this.run_step_with_command("FinishGame");

          // スロット状態とタスクキューもリセット
          if (this.playerId === 1) {
            isSpinning1 = false;
            spinQueue1 = [];
            if (taskQueue1) {
              taskQueue1.clear();
            }
            console.log(
              "プレイヤー1: スロット状態とタスクキューをリセットしました",
            );
          } else if (this.playerId === 2) {
            isSpinning2 = false;
            spinQueue2 = [];
            if (taskQueue2) {
              taskQueue2.clear();
            }
            console.log(
              "プレイヤー2: スロット状態とタスクキューをリセットしました",
            );
          }

          console.log(
            `プレイヤー${this.playerId}: シミュレーションをリセットしました`,
          );
        }

        // キー入力処理
        handleKeyInput(key) {
          if (key === this.keyBinding) {
            this.launchBall();
            console.log(
              `プレイヤー${this.playerId}: ${this.keyBinding.toUpperCase()}キーで球を落下`,
            );
          }
        }
      }

      // Global nail arrays
      let nails1 = [];
      let nails2 = [];

      // Global configuration variables
      let config1, config2;
      let game1, game2;
      let outputFunctions1, outputFunctions2;

      async function main() {
        // video-list.jsonを事前に読み込み
        await preloadVideoList();

        await init();

        // Initialize nails arrays
        nails1 = [];
        nails2 = [];

        const nails_count = 100;

        for (let i = 0; i < nails_count; i++) {
          {
            const x = 20 + Math.random() * 160;
            const y = 100 + Math.random() * 600;
            nails1.push({ x: x, y: y });
          }

          {
            const x = 20 + Math.random() * 160;
            const y = 100 + Math.random() * 600;
            nails2.push({ x: x, y: y });
          }
        }

        // スロット番号を更新する関数
        function updateSlots(playerId, slot) {
          if (playerId === 1) {
            spinTo(slot, reels1);
          } else if (playerId === 2) {
            spinTo(slot, reels2);
          }
        }

        // ゲーム状態を更新する関数
        function updateState(playerId, state, withText = "") {
          if (withText != "") {
            console.log(
              `Player ${playerId} State Updated:`,
              state,
              `with: ${withText}`,
            );
          } else {
            console.log(`Player ${playerId} State Updated:`, state);
          }

          const textOfState = (state) => {
            switch (state.type) {
              case "Normal":
                return `球数: ${state.balls}`;
              case "Rush":
                return `球数: ${state.balls}, ラッシュ球: ${state.rushBalls}, 回数: ${state.n}`;
              default:
                return `未初期化`;
            }
          };

          const element = document.getElementById(`state${playerId}`);
          const rightPanel = document.getElementById(`right-panel${playerId}`);

          const stateText = textOfState(state);

          if (element && rightPanel) {
            // ゲームが開始されているかチェック
            const game = playerId === 1 ? game1 : game2;
            if (!game.wasmgame.isGameStarted()) {
              const startKey = playerId === 1 ? "A" : "L";
              element.textContent = `終了しました\n結果: ${stateText}\n${startKey}キーでスタート`;
              return;
            }

            element.textContent = stateText;
          }
        }

        function setTemporalyBackGroundVideo(playerId, videoPath) {
          const beforeVideo = document.getElementById(`video${playerId}`);
          const beforeSource = document.getElementById(`source${playerId}`);
          const beforeVideoPath = beforeSource.getAttribute("src") ?? "";

          beforeVideo.removeAttribute("autoplay");
          beforeVideo.removeAttribute("loop");
          beforeVideo.removeAttribute("muted");

          beforeSource.setAttribute("src", videoPath);

          const video = document.getElementById(`video${playerId}`);
          video.play();
          video.addEventListener("ended", () => {
            beforeSource.setAttribute("src", beforeVideoPath);
            beforeVideo.setAttribute("autoplay", "");
            beforeVideo.setAttribute("loop", "");
            beforeVideo.setAttribute("muted", "");
            video.load();
            video.removeEventListener("ended");
          });
        }

        // タスクキューを初期化（updateState関数が定義された後）
        taskQueue1 = new OutputTaskQueue(1, updateState);
        taskQueue2 = new OutputTaskQueue(2, updateState);

        const input1 = new JsInput();

        const input2 = new JsInput();

        outputFunctions1 = {
          default: (transition) => {
            taskQueue1.addTask("default", transition);
          },
          finishGame: (gameState) => {
            setIsProcessingFinishTask(1, true);
            taskQueue1.addTask("finishGame", gameState);
          },
          lotteryNormal: (lotteryResult, slotResult) => {
            taskQueue1.addTask("lotteryNormal", {
              lotteryResult,
              slotResult,
              taskType: "Normal Lottery",
            });
          },
          lotteryIntoRush: (lotteryResult, slotResult) => {
            taskQueue1.addTask("lotteryIntoRush", {
              lotteryResult,
              slotResult,
              taskType: "Into Rush Lottery",
            });
          },
          lotteryRush: (lotteryResult, slotResult) => {
            taskQueue1.addTask("lotteryRush", {
              lotteryResult,
              slotResult,
              taskType: "Rush Lottery",
            });
          },
          lotteryRushContinue: (lotteryResult, slotResult) => {
            taskQueue1.addTask("lotteryRushContinue", {
              lotteryResult,
              slotResult,
              taskType: "Rush Continue",
            });
          },
          startGame: (state) => {
            taskQueue1.changeBackgroundVideo(backgroundVideoPaths.normal);
            updateState(1, state);
          },
        };

        outputFunctions2 = {
          default: (transition) => {
            taskQueue2.addTask("default", transition);
          },
          finishGame: (gameState) => {
            console.log("Finish game");
            setIsProcessingFinishTask(2, true);
            taskQueue2.addTask("finishGame", gameState);
          },
          lotteryNormal: (lotteryResult, slotResult) => {
            taskQueue2.addTask("lotteryNormal", {
              lotteryResult,
              slotResult,
              taskType: "Normal Lottery",
            });
          },
          lotteryIntoRush: (lotteryResult, slotResult) => {
            taskQueue2.addTask("lotteryIntoRush", {
              lotteryResult,
              slotResult,
              taskType: "Into Rush Lottery",
            });
          },
          lotteryRush: (lotteryResult, slotResult) => {
            taskQueue2.addTask("lotteryRush", {
              lotteryResult,
              slotResult,
              taskType: "Rush Lottery",
            });
          },
          lotteryRushContinue: (lotteryResult, slotResult) => {
            taskQueue2.addTask("lotteryRushContinue", {
              lotteryResult,
              slotResult,
              taskType: "Rush Continue",
            });
          },
          startGame: (state) => {
            taskQueue2.changeBackground(backgroundVideoPaths.normal);
            updateState(2, state);
          },
        };

        const output1 = new JsOutput(
          outputFunctions1.default,
          outputFunctions1.finishGame,
          outputFunctions1.startGame,
          outputFunctions1.lotteryNormal,
          outputFunctions1.lotteryIntoRush,
          outputFunctions1.lotteryRush,
          outputFunctions1.lotteryRushContinue,
        );

        const output2 = new JsOutput(
          outputFunctions2.default,
          outputFunctions2.finishGame,
          outputFunctions2.startGame,
          outputFunctions2.lotteryNormal,
          outputFunctions2.lotteryIntoRush,
          outputFunctions2.lotteryRush,
          outputFunctions2.lotteryRushContinue,
        );

        config1 = new Config(
          new BallsConfig(100, 15, 30),
          new Probability(
            new SlotProbability(0.16, 0.3, 0.15),
            new SlotProbability(0.8, 0.3, 0.15),
            new SlotProbability(0.48, 0.2, 0.05),
            new SlotProbability(0.5, 0.25, 0.1),
            (n) => {
              return 0.3 ** (n - 1);
            },
          ),
        );

        config2 = new Config(
          new BallsConfig(100, 15, 30),
          new Probability(
            new SlotProbability(0.16, 0.3, 0.15),
            new SlotProbability(0.8, 0.3, 0.15),
            new SlotProbability(0.48, 0.2, 0.05),
            new SlotProbability(0.5, 0.25, 0.1),
            (n) => {
              return 0.3 ** (n - 1);
            },
          ),
        );

        // 2つのゲームインスタンスを作成
        const wasmGame1 = new WasmGame(input1, output1, config1);
        const wasmGame2 = new WasmGame(input2, output2, config2);

        // WASMGame再作成用の関数
        const recreateWasmGame1 = () => {
          const newInput1 = new JsInput();
          const newOutput1 = new JsOutput(
            outputFunctions1.default,
            outputFunctions1.finishGame,
            outputFunctions1.startGame,
            outputFunctions1.lotteryNormal,
            outputFunctions1.lotteryIntoRush,
            outputFunctions1.lotteryRush,
            outputFunctions1.lotteryRushContinue,
          );
          return new WasmGame(newInput1, newOutput1, config1);
        };

        const recreateWasmGame2 = () => {
          const newInput2 = new JsInput();
          const newOutput2 = new JsOutput(
            outputFunctions2.default,
            outputFunctions2.finishGame,
            outputFunctions2.startGame,
            outputFunctions2.lotteryNormal,
            outputFunctions2.lotteryIntoRush,
            outputFunctions2.lotteryRush,
            outputFunctions2.lotteryRushContinue,
          );
          return new WasmGame(newInput2, newOutput2, config2);
        };

        game1 = new PachinkoGame(
          "canvas1",
          1,
          "a",
          nails1,
          wasmGame1,
          recreateWasmGame1,
        );
        game2 = new PachinkoGame(
          "canvas2",
          2,
          "l",
          nails2,
          wasmGame2,
          recreateWasmGame2,
        );

        // Add method to recreate physics with new nails to PachinkoGame class
        PachinkoGame.prototype.recreatePhysicsWithNewNails = function () {
          console.log(
            `Recreating physics for player ${this.playerId} with new nails`,
          );

          // Remove old nails from world
          this.nails.forEach((nail) => {
            Composite.remove(this.world, nail);
          });

          // Create new nails
          this.createNails();

          // Add new nails to world
          Composite.add(this.world, this.nails);

          console.log(
            `Physics recreated for player ${this.playerId} with ${this.nails.length} nails`,
          );
        };

        // グローバルアクセスのためwindowオブジェクトに設定（WasmGameインスタンス）
        window.game1 = wasmGame1;
        window.game2 = wasmGame2;

        // ボタンから呼び出される関数
        function launchBall1() {
          game1.launchBall();
        }
        function resetSimulation1() {
          game1.resetSimulation();
        }
        function dropBall2() {
          game2.launchBall();
        }
        function resetSimulation2() {
          game2.resetSimulation();
        }

        // ゲームを開始

        // game1.run();
        // game2.run();

        // キーボードイベントリスナー（長押し対応）
        const pressedKeys = new Set();
        const keyIntervals = new Map(); // キーごとのインターバルIDを管理
        const lastLaunchTimes = new Map(); // キーごとの最後の発射時刻を管理
        const LONG_PRESS_INTERVAL = 700; // 0.7秒間隔

        // 連打制限付きのキー処理（初回押下時用）
        async function handleKeyPress(key) {
          const now = Date.now();
          const lastLaunchTime = lastLaunchTimes.get(key) || 0;

          // 0.7秒間隔のチェック（連打対応）
          if (now - lastLaunchTime < LONG_PRESS_INTERVAL) {
            console.log(
              `キー ${key} は0.7秒間隔制限により無視されました (残り時間: ${LONG_PRESS_INTERVAL - (now - lastLaunchTime)}ms)`,
            );
            return;
          }

          // 発射時刻を更新
          lastLaunchTimes.set(key, now);

          await executeKeyAction(key);
        }

        // 長押し時のキー処理（制限なし）
        async function handleLongPress(key) {
          await executeKeyAction(key);
        }

        // 実際のキーアクション実行
        async function executeKeyAction(key) {
          // Configuration keys
          if (key === "f") {
            openConfigModal(1);
            return;
          }
          if (key === "j") {
            openConfigModal(2);
            return;
          }

          // 通常のキー処理（ゲーム開始後のみ）
          if (key === game1.keyBinding) {
            console.log(`isProcessingFinishTask1: ${isProcessingFinishTask1}`);

            if (isProcessingFinishTask1) {
              return;
            }

            if (game1.wasmgame.isGameStarted()) {
              game1.handleKeyInput(game1.keyBinding);
            } else {
              console.log(
                `${game1.keyBinding}キーが押されました。game1.isGameStarted: ${game1.wasmgame.isGameStarted()}`,
              );
              if (!game1.wasmgame.isGameStarted()) {
                console.log("プレイヤー1のゲームを開始します");
                await game1.startWasmGame();
                return;
              } else {
                console.log("プレイヤー1は既にゲーム開始済みです");
              }
            }
          }
          if (key === game2.keyBinding) {
            console.log(`isProcessingFinishTask2: ${isProcessingFinishTask2}`);

            if (isProcessingFinishTask2) {
              return;
            }

            if (game2.wasmgame.isGameStarted()) {
              game2.handleKeyInput(game2.keyBinding);
            } else {
              console.log(
                `${game2.keyBinding}キーが押されました。game2.isGameStarted: ${game2.wasmgame.isGameStarted()}`,
              );
              if (!game2.wasmgame.isGameStarted()) {
                console.log("プレイヤー2のゲームを開始します");
                await game2.startWasmGame();
                return;
              } else {
                console.log("プレイヤー2は既にゲーム開始済みです");
              }
            }
          }
        }

        document.addEventListener("keydown", (event) => {
          const key = event.key.toLowerCase();

          // 既に押されているキーの場合は無視（リピートイベント防止）
          if (pressedKeys.has(key)) {
            return;
          }

          pressedKeys.add(key);

          // 最初のキー入力を即座に実行（連打制限付き）
          handleKeyPress(key).catch(console.error);

          // 長押し用のインターバルを設定
          if (key === game1.keyBinding || key === game2.keyBinding) {
            const intervalId = setInterval(() => {
              if (pressedKeys.has(key)) {
                console.log(`Long press: ${key}`);
                handleLongPress(key).catch(console.error);
              } else {
                clearInterval(intervalId);
                keyIntervals.delete(key);
              }
            }, LONG_PRESS_INTERVAL);

            keyIntervals.set(key, intervalId);
          }
        });

        document.addEventListener("keyup", (event) => {
          const key = event.key.toLowerCase();
          pressedKeys.delete(key);

          // インターバルをクリア
          if (keyIntervals.has(key)) {
            clearInterval(keyIntervals.get(key));
            keyIntervals.delete(key);
          }
        });

        // ウィンドウフォーカス外れ時にキー状態をリセット
        window.addEventListener("blur", () => {
          console.log("Window lost focus, resetting key states");
          pressedKeys.clear();
          lastLaunchTimes.clear();

          // 全てのインターバルをクリア
          keyIntervals.forEach((intervalId, key) => {
            clearInterval(intervalId);
          });
          keyIntervals.clear();
        });

        // ページの可視性が変わった時もリセット
        document.addEventListener("visibilitychange", () => {
          if (document.hidden) {
            console.log("Page hidden, resetting key states");
            pressedKeys.clear();
            lastLaunchTimes.clear();

            keyIntervals.forEach((intervalId, key) => {
              clearInterval(intervalId);
            });
            keyIntervals.clear();
          }
        });

        // デバッグ用：長押し状態確認関数
        window.debugKeyStates = () => {
          console.log("=== キー状態デバッグ ===");
          console.log("押されているキー:", Array.from(pressedKeys));
          console.log("長押しインターバル:", Array.from(keyIntervals.keys()));
          console.log("インターバル数:", keyIntervals.size);
          console.log("最後の発射時刻:", Object.fromEntries(lastLaunchTimes));
          const now = Date.now();
          lastLaunchTimes.forEach((time, key) => {
            const elapsed = now - time;
            console.log(
              `キー ${key}: ${elapsed}ms前に発射 (次回発射まで${Math.max(0, LONG_PRESS_INTERVAL - elapsed)}ms)`,
            );
          });
        };

        window.clearAllKeyStates = () => {
          console.log("全てのキー状態を強制クリア");
          pressedKeys.clear();
          lastLaunchTimes.clear();
          keyIntervals.forEach((intervalId, key) => {
            clearInterval(intervalId);
          });
          keyIntervals.clear();
        };

        // 背景動画を設定するためのヘルパー関数
        window.setBackgroundVideo = (playerId, videoSrc) => {
          const video = document.getElementById(`video${playerId}`);
          if (video && videoSrc) {
            video.src = videoSrc;
            video.load(); // 新しいソースを読み込み
            console.log(`Player ${playerId}の背景動画を設定: ${videoSrc}`);
          }
        };

        // 両方のプレイヤーに同じ動画を設定するヘルパー関数
        window.setBackgroundVideoForBoth = (videoSrc) => {
          window.setBackgroundVideo(1, videoSrc);
          window.setBackgroundVideo(2, videoSrc);
        };

        // 初期状態の表示を更新
        const element1 = document.getElementById("state1");
        const element2 = document.getElementById("state2");
        if (element1) element1.textContent = "Aキーでスタート";
        if (element2) element2.textContent = "Lキーでスタート";

        console.log("🎮 デュアルパチンコゲーム準備完了！");
        console.log(
          "プレイヤー1: Aキーで球を落とす (長押し対応 - 0.7秒間隔), Fキーで設定画面",
        );
        console.log(
          "プレイヤー2: 、Lキーで球を落とす (長押し対応 - 0.7秒間隔), Jキーで設定画面",
        );
        console.log(
          "デバッグコマンド: window.debugKeyStates(), window.clearAllKeyStates()",
        );
      }

      // タイマー設定関数
      function toggleTimeSettings(playerId) {
        const settings = document.getElementById(`time-settings${playerId}`);
        settings.classList.toggle("visible");
      }

      function applyTimeSettings(playerId) {
        const input = document.getElementById(`timer-input${playerId}`);
        const minutes = parseInt(input.value);

        if (minutes < 1 || minutes > 60) {
          alert("Please enter a time between 1 and 60 minutes.");
          return;
        }

        // 対応するゲームインスタンスを取得して時間を設定
        const game = playerId === 1 ? game1 : game2;
        if (game) {
          game.setGameDuration(minutes);
        }

        // 設定パネルを閉じる
        toggleTimeSettings(playerId);
      }

      // Configuration System
      let configCanvases = {};
      let configNails = { 1: [], 2: [] };
      let configContexts = {};

      function initializeConfigSystem() {
        // Initialize nail canvases
        for (let playerId = 1; playerId <= 2; playerId++) {
          const canvas = document.getElementById(`nail-canvas-${playerId}`);
          const ctx = canvas.getContext("2d");
          configCanvases[playerId] = canvas;
          configContexts[playerId] = ctx;

          // Scale canvas for crisp rendering
          const rect = canvas.getBoundingClientRect();
          canvas.width = 200;
          canvas.height = 400;
          ctx.scale(1, 1);

          // Add click event listener
          canvas.addEventListener("click", (event) => {
            handleNailCanvasClick(event, playerId);
          });

          // Initialize with current nails
          if (playerId === 1) {
            configNails[1] = [...nails1];
          } else {
            configNails[2] = [...nails2];
          }
        }

        // Add event listeners for all buttons
        for (let playerId = 1; playerId <= 2; playerId++) {
          // Close button
          document
            .getElementById(`config-close-${playerId}`)
            .addEventListener("click", () => {
              closeConfigModal(playerId);
            });

          // Nail control buttons
          document
            .getElementById(`clear-nails-${playerId}`)
            .addEventListener("click", () => {
              clearAllNails(playerId);
            });

          document
            .getElementById(`random-nails-${playerId}`)
            .addEventListener("click", () => {
              randomNails(playerId);
            });

          document
            .getElementById(`remove-last-nail-${playerId}`)
            .addEventListener("click", () => {
              removeLastNail(playerId);
            });

          // Data control buttons
          document
            .getElementById(`export-nail-data-${playerId}`)
            .addEventListener("click", () => {
              exportNailData(playerId);
            });

          document
            .getElementById(`import-nail-data-${playerId}`)
            .addEventListener("click", () => {
              importNailData(playerId);
            });

          // Apply configuration button
          document
            .getElementById(`apply-config-${playerId}`)
            .addEventListener("click", () => {
              applyConfig(playerId);
            });

          // Modal background click to close
          const modal = document.getElementById(`config-modal-${playerId}`);
          modal.addEventListener("click", (event) => {
            if (event.target === modal) {
              closeConfigModal(playerId);
            }
          });
        }

        // Keyboard event listeners
        document.addEventListener("keydown", (event) => {
          // ESC key to close any open modal
          if (event.key === "Escape") {
            for (let pid = 1; pid <= 2; pid++) {
              const modal = document.getElementById(`config-modal-${pid}`);
              if (modal.classList.contains("visible")) {
                closeConfigModal(pid);
              }
            }
          }
        });
      }

      function openConfigModal(playerId) {
        console.log(`Opening config modal for player ${playerId}`);

        // Load current configuration values
        loadCurrentConfig(playerId);

        // Update nail canvas
        updateNailCanvas(playerId);

        // Show modal
        const modal = document.getElementById(`config-modal-${playerId}`);
        modal.classList.add("visible");

        // Prevent body scroll
        document.body.style.overflow = "hidden";
      }

      function closeConfigModal(playerId) {
        console.log(`Closing config modal for player ${playerId}`);

        const modal = document.getElementById(`config-modal-${playerId}`);
        modal.classList.remove("visible");

        // Restore body scroll
        document.body.style.overflow = "";
      }

      function loadCurrentConfig(playerId) {
        // Get current config from game
        const game = playerId === 1 ? game1 : game2;
        const currentConfig = playerId === 1 ? config1 : config2;

        // Load balls config
        document.getElementById(`config-init-balls-${playerId}`).value =
          currentConfig.balls.initBalls;
        document.getElementById(`config-incremental-balls-${playerId}`).value =
          currentConfig.balls.incrementalBalls;
        document.getElementById(`config-incremental-rush-${playerId}`).value =
          currentConfig.balls.incrementalRush;

        // Load probability config
        document.getElementById(`config-normal-win-${playerId}`).value =
          currentConfig.probability.normal.win;
        document.getElementById(`config-normal-fake-win-${playerId}`).value =
          currentConfig.probability.normal.fakeWin;
        document.getElementById(`config-normal-fake-lose-${playerId}`).value =
          currentConfig.probability.normal.fakeLose;

        document.getElementById(`config-rush-win-${playerId}`).value =
          currentConfig.probability.rush.win;
        document.getElementById(`config-rush-fake-win-${playerId}`).value =
          currentConfig.probability.rush.fakeWin;
        document.getElementById(`config-rush-fake-lose-${playerId}`).value =
          currentConfig.probability.rush.fakeLose;

        document.getElementById(`config-rush-continue-win-${playerId}`).value =
          currentConfig.probability.rushContinue.win;
        document.getElementById(
          `config-rush-continue-fake-win-${playerId}`,
        ).value = currentConfig.probability.rushContinue.fakeWin;
        document.getElementById(
          `config-rush-continue-fake-lose-${playerId}`,
        ).value = currentConfig.probability.rushContinue.fakeLose;

        // Load nail data
        const currentNails = playerId === 1 ? nails1 : nails2;
        configNails[playerId] = [...currentNails];
        document.getElementById(`nail-data-${playerId}`).value = JSON.stringify(
          currentNails,
          null,
          2,
        );
      }

      function updateNailCanvas(playerId) {
        const ctx = configContexts[playerId];
        const canvas = configCanvases[playerId];

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw background
        ctx.fillStyle = "#2a2a2a";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw walls
        ctx.fillStyle = "#444";
        ctx.fillRect(0, 0, 15, canvas.height);
        ctx.fillRect(canvas.width - 15, 0, 15, canvas.height);

        // Draw nails
        ctx.fillStyle = "#e74c3c";
        ctx.strokeStyle = "#c0392b";
        ctx.lineWidth = 0.5;

        for (const nail of configNails[playerId]) {
          const x = nail.x * (canvas.width / 200);
          const y = nail.y * (canvas.height / 800);

          ctx.beginPath();
          ctx.arc(x, y, 2, 0, 2 * Math.PI);
          ctx.fill();
          ctx.stroke();
        }
      }

      function handleNailCanvasClick(event, playerId) {
        const canvas = configCanvases[playerId];
        const rect = canvas.getBoundingClientRect();
        const x = ((event.clientX - rect.left) / rect.width) * 200;
        const y = ((event.clientY - rect.top) / rect.height) * 800;

        // Check if clicking near an existing nail (remove it)
        let nailRemoved = false;
        for (let i = configNails[playerId].length - 1; i >= 0; i--) {
          const nail = configNails[playerId][i];
          const distance = Math.sqrt((nail.x - x) ** 2 + (nail.y - y) ** 2);
          if (distance < 10) {
            configNails[playerId].splice(i, 1);
            nailRemoved = true;
            break;
          }
        }

        // If no nail was removed, add a new one
        if (!nailRemoved && x >= 20 && x <= 180 && y >= 50 && y <= 750) {
          configNails[playerId].push({ x: x, y: y });
        }

        // Update canvas and data
        updateNailCanvas(playerId);
        updateNailData(playerId);
      }

      function updateNailData(playerId) {
        document.getElementById(`nail-data-${playerId}`).value = JSON.stringify(
          configNails[playerId],
          null,
          2,
        );
      }

      function clearAllNails(playerId) {
        configNails[playerId] = [];
        updateNailCanvas(playerId);
        updateNailData(playerId);
      }

      function randomNails(playerId) {
        configNails[playerId] = [];
        const nailCount = 80 + Math.floor(Math.random() * 40);

        for (let i = 0; i < nailCount; i++) {
          const x = 20 + Math.random() * 160;
          const y = 100 + Math.random() * 600;
          configNails[playerId].push({ x: x, y: y });
        }

        updateNailCanvas(playerId);
        updateNailData(playerId);
      }

      function removeLastNail(playerId) {
        if (configNails[playerId].length > 0) {
          configNails[playerId].pop();
          updateNailCanvas(playerId);
          updateNailData(playerId);
        }
      }

      function exportNailData(playerId) {
        const data = JSON.stringify(configNails[playerId], null, 2);
        document.getElementById(`nail-data-${playerId}`).value = data;

        // Copy to clipboard
        navigator.clipboard
          .writeText(data)
          .then(() => {
            alert("Nail data copied to clipboard!");
          })
          .catch(() => {
            alert("Nail data exported to text area");
          });
      }

      function importNailData(playerId) {
        const data = document.getElementById(`nail-data-${playerId}`).value;
        try {
          const nails = JSON.parse(data);
          if (Array.isArray(nails)) {
            configNails[playerId] = nails.filter(
              (nail) =>
                nail &&
                typeof nail.x === "number" &&
                typeof nail.y === "number",
            );
            updateNailCanvas(playerId);
            updateNailData(playerId);
            alert("Nail data imported successfully!");
          } else {
            alert(
              "Invalid data format. Please provide an array of nail objects.",
            );
          }
        } catch (error) {
          alert("Invalid JSON format. Please check your data.");
        }
      }

      async function applyConfig(playerId) {
        try {
          // Get configuration values
          const initBalls = parseInt(
            document.getElementById(`config-init-balls-${playerId}`).value,
          );
          const incrementalBalls = parseInt(
            document.getElementById(`config-incremental-balls-${playerId}`)
              .value,
          );
          const incrementalRush = parseInt(
            document.getElementById(`config-incremental-rush-${playerId}`)
              .value,
          );

          const normalWin = parseFloat(
            document.getElementById(`config-normal-win-${playerId}`).value,
          );
          const normalFakeWin = parseFloat(
            document.getElementById(`config-normal-fake-win-${playerId}`).value,
          );
          const normalFakeLose = parseFloat(
            document.getElementById(`config-normal-fake-lose-${playerId}`)
              .value,
          );

          const intoRushWin = parseFloat(
            document.getElementById(`config-into-rush-win-${playerId}`).value,
          );
          const intoRushFakeWin = parseFloat(
            document.getElementById(`config-into-rush-fake-win-${playerId}`)
              .value,
          );
          const intoRushFakeLose = parseFloat(
            document.getElementById(`config-into-rush-fake-lose-${playerId}`)
              .value,
          );

          const rushWin = parseFloat(
            document.getElementById(`config-rush-win-${playerId}`).value,
          );
          const rushFakeWin = parseFloat(
            document.getElementById(`config-rush-fake-win-${playerId}`).value,
          );
          const rushFakeLose = parseFloat(
            document.getElementById(`config-rush-fake-lose-${playerId}`).value,
          );

          const rushContinueWin = parseFloat(
            document.getElementById(`config-rush-continue-win-${playerId}`)
              .value,
          );
          const rushContinueFakeWin = parseFloat(
            document.getElementById(`config-rush-continue-fake-win-${playerId}`)
              .value,
          );
          const rushContinueFakeLose = parseFloat(
            document.getElementById(
              `config-rush-continue-fake-lose-${playerId}`,
            ).value,
          );

          // Apply nail configuration
          if (playerId === 1) {
            nails1 = [...configNails[1]];
          } else {
            nails2 = [...configNails[2]];
          }

          // Create new configuration
          const newBallsConfig = new BallsConfig(
            initBalls,
            incrementalBalls,
            incrementalRush,
          );
          const newProbability = new Probability(
            new SlotProbability(normalWin, normalFakeWin, normalFakeLose),
            new SlotProbability(intoRushWin, intoRushFakeWin, intoRushFakeLose),
            new SlotProbability(rushWin, rushFakeWin, rushFakeLose),
            new SlotProbability(
              rushContinueWin,
              rushContinueFakeWin,
              rushContinueFakeLose,
            ),
            (n) => {
              return 0.6 ** (n - 1);
            },
          );
          const newConfig = new Config(newBallsConfig, newProbability);

          // Update global config variables
          if (playerId === 1) {
            config1 = newConfig;
          } else {
            config2 = newConfig;
          }

          // Recreate the game instances with new configuration
          console.log(`Applying new configuration for player ${playerId}`);

          if (playerId === 1) {
            // End current game if running
            if (game1 && game1.wasmgame.isGameStarted()) {
              await game1.endGame();
            }

            // Recreate WASM game with new config
            const newInput1 = new JsInput();
            const newOutput1 = new JsOutput(
              outputFunctions1.default,
              outputFunctions1.finishGame,
              outputFunctions1.startGame,
              outputFunctions1.lotteryNormal,
              outputFunctions1.lotteryRush,
              outputFunctions1.lotteryRushContinue,
            );
            window.game1 = new WasmGame(newInput1, newOutput1, newConfig);
            game1.wasmgame = window.game1;

            // Update physical game with new nails
            game1.nails_index = nails1;
            game1.recreatePhysicsWithNewNails();
          } else {
            // End current game if running
            if (game2 && game2.wasmgame.isGameStarted()) {
              await game2.endGame();
            }

            // Recreate WASM game with new config
            const newInput2 = new JsInput();
            const newOutput2 = new JsOutput(
              outputFunctions2.default,
              outputFunctions2.finishGame,
              outputFunctions2.startGame,
              outputFunctions2.lotteryNormal,
              outputFunctions2.lotteryRush,
              outputFunctions2.lotteryRushContinue,
            );
            window.game2 = new WasmGame(newInput2, newOutput2, newConfig);
            game2.wasmgame = window.game2;

            // Update physical game with new nails
            game2.nails_index = nails2;
            game2.recreatePhysicsWithNewNails();
          }

          console.log(
            `Configuration applied successfully for player ${playerId}`,
          );
          alert(
            `Player ${playerId} configuration applied! New game created with updated settings.`,
          );

          // Close the modal
          closeConfigModal(playerId);
        } catch (error) {
          console.error(
            `Error applying configuration for player ${playerId}:`,
            error,
          );
          alert(`Error applying configuration: ${error.message}`);
        }
      }

      main().then(() => {
        // Initialize configuration system after main completes
        setTimeout(() => {
          initializeConfigSystem();
        }, 100);
      });
    </script>
  </body>
</html>
